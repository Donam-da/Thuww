<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Solar System Image Gallery</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; }
        canvas { display: block; }
        #main-scene {
            position: relative; z-index: 2; /* Giữ thuộc tính này */
        }
        #main-scene { display: none; }
        #loader-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #000; display: flex; justify-content: center;
            align-items: center; z-index: 3000; transition: opacity 0.5s ease;
        }
        .loader-container { text-align: center; }
        .progress-circle {
            width: 120px; height: 120px; border-radius: 50%;
            background: conic-gradient(#3498db 0%, #1a1a1a 0%);
            display: flex; justify-content: center; align-items: center;
            margin: 0 auto 20px auto;
        }
        .progress-circle-inner {
            width: 100px; height: 100px; background-color: #000;
            border-radius: 50%; display: flex; justify-content: center;
            align-items: center;
        }
        .loader-text {
            font-size: 24px; color: white; font-family: Arial, sans-serif;
        }
        #fullscreen-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.85); display: none; justify-content: center;
            align-items: center; z-index: 1000;
        }
        #fullscreen-image { max-width: 90%; max-height: 80%; }
        #close-btn {
            position: absolute; top: 20px; right: 30px; color: white;
            font-size: 30px; cursor: pointer; text-decoration: none; font-family: Arial, sans-serif;
        }
        #download-btn {
            position: absolute;
            bottom: 20px; /* Cách đáy 20px */
            right: 30px; /* Cách phải 30px */
            color: white;
            font-size: 16px;
            cursor: pointer;
            text-decoration: none;
            font-family: Arial, sans-serif;
            padding: 8px 15px; border: 1px solid white; border-radius: 5px;
            display: none; /* Ẩn theo mặc định */
        }
        .planet-label {
            color: #FFF;
            font-family: sans-serif;
            padding: 2px 5px;
            background: transparent;
            font-size: 7px;
            white-space: nowrap;
            cursor: pointer;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.9);
        }
        #select-planet-btn {
            /* Vị trí được quản lý bởi #main-ui-controls */
            z-index: 1001;
            padding: 10px 15px;
            background-color: transparent; /* Nền trong suốt */
            color: white; /* Giữ màu chữ */
            border: none; /* Bỏ viền */
            border-radius: 5px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            font-size: 16px;
            /* Đã loại bỏ định vị cố định */
            display: block; /* Đảm bảo nút luôn hiển thị */
        }
        #overview-btn { /* Kiểu dáng cho nút mới */
            position: fixed; /* Định vị cố định */
            bottom: 20px; /* Mặc định ở góc dưới bên phải cho desktop */
            right: 20px;
            z-index: 1001;
            padding: 10px 15px;
            background-color: transparent;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            display: block; /* Đảm bảo nút luôn hiển thị */
            font-size: 16px;
        }
        /* Desktop styles for main-ui-controls */
        #planet-list-overlay {
            position: fixed;
            top: 60px; /* Định vị dưới nút "Chọn hành tinh" (top 20px + padding 10px + border 1px + khoảng cách) */
            left: 20px; /* Căn chỉnh với lề trái của nút */
            width: fit-content; /* Chiều rộng vừa với nội dung */
            min-width: 180px; /* Đảm bảo chiều rộng tối thiểu, có thể điều chỉnh */
            /* max-height và overflow-y bị loại bỏ để hiển thị tất cả và bỏ thanh cuộn */
            background-color: rgba(0,0,0,0.7); /* Nền của dropmenu */
            padding: 15px; /* Giảm khoảng đệm bên trong dropmenu */
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,255,255,0.5); /* Hiệu ứng đổ bóng cho dropmenu */
            z-index: 1002;
            display: none; /* Hidden by default */
            font-family: Arial, sans-serif;
        }
        #close-dropmenu-btn {
            position: absolute;
            top: 5px; /* Khoảng cách từ trên xuống */
            right: 10px; /* Khoảng cách từ phải sang */
            color: white;
            font-size: 20px; /* Kích thước chữ X */
            cursor: pointer;
            z-index: 1003; /* Đảm bảo nó nằm trên các phần tử khác trong overlay */
        }
        .planet-list-item {
            color: white;
            padding: 10px;
            margin-bottom: 5px;
            background-color: rgba(0,0,0,0.5); /* Semi-transparent background */
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .planet-list-item:hover {
            background-color: rgba(0,0,0,0.7); /* Darker on hover */
        }

        /* --- Music Player Styles --- */
        #select-song-btn {
            position: fixed;
            /* Vị trí được quản lý bởi #main-ui-controls */
            z-index: 1001;
            background-color: transparent; /* Giữ nền trong suốt */
            color: white; /* Giữ màu chữ */
            border: none; /* Bỏ viền */
            border-radius: 5px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            font-size: 16px;
        }
        #song-list-overlay {
            position: fixed;
            top: 60px;
            right: 20px; /* Align with the button */
            width: fit-content;
            min-width: 220px; /* Increased width for longer names */
            background-color: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,255,255,0.5);
            z-index: 1002;
            display: none; /* Hidden by default */
            font-family: Arial, sans-serif;
        }
        #close-song-menu-btn {
            position: absolute;
            top: 5px;
            right: 10px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            z-index: 1003;
        }
        .song-list-item {
            color: white;
            padding: 10px;
            margin-bottom: 5px;
            background-color: rgba(0,0,0,0.5);
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .song-list-item:hover {
            background-color: rgba(0,0,0,0.7);
        }
        /* --- 2D Music Controls Styles --- */
        #music-controls-2d {
            position: fixed;
            /* Position handled by #main-ui-controls on desktop */ /* Removed fixed positioning here */
            /* display: flex; */ /* This will be set by JS when music is active */
            flex-direction: column; /* Xếp chồng các phần tử con theo chiều dọc */
            justify-content: center; /* Căn giữa các phần tử con theo chiều dọc */
            align-items: center; /* Căn giữa các phần tử con theo chiều ngang */
            gap: 5px; /* Khoảng cách giữa thanh tiến trình và hàng nút */
            background-color: rgba(0,0,0,0.5); /* Semi-transparent background */
            background-color: transparent; /* Làm nền trong suốt */
            padding: 5px 10px; /* Giữ padding */
            border-radius: 5px;
            border: none; /* Bỏ viền */
        }
        .music-player-buttons-row { /* Class mới cho hàng nút điều khiển */
            display: flex;
            gap: 10px; /* Khoảng cách giữa các nút */
            justify-content: center; /* Căn giữa các nút trong hàng */
            margin-top: -10px; /* Di chuyển các nút lên trên 15px */
            width: 300px; /* Đặt chiều rộng bằng thanh tiến trình trên desktop */
            transform: translateX(-5px); /* Dịch sang trái 5px */
            width: 200px; /* Giảm chiều rộng cho cân đối */
        }
        #music-controls-2d button {
            background: none;
            border: none; /* Bỏ viền */
            color: white;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }
        #music-controls-2d button:hover {
            background-color: rgba(0,0,0,0.7);
        }
        #music-player-scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none; /* Cho phép click xuyên qua để tương tác với scene chính */
        }
        #music-player-progress-container-2d {
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            height: 5px;
            cursor: pointer;
            width: 240px; /* Giảm chiều rộng đi 5px cho desktop */
            margin: 0 auto; /* Căn giữa theo chiều ngang trong container cha */
            transform: translateX(-5px); /* Dịch sang phải 5px (từ vị trí -10px, giờ là -5px) */
            position: relative; /* Cần thiết để định vị chấm kéo bên trong */
        }
        #music-player-progress-handle-2d {
            width: 12px; /* Kích thước của chấm kéo */
            height: 12px;
            background-color: #ffffff; /* Màu trắng */
            border-radius: 50%; /* Hình tròn */
            position: absolute;
            top: 50%; /* Căn giữa theo chiều dọc */
            transform: translateY(-50%); /* Dịch chuyển lên trên 50% chiều cao của chính nó */
            left: 0; /* Vị trí ban đầu, sẽ được JS cập nhật */
            cursor: grab; /* Con trỏ kéo */
        }
        #music-player-song-title-2d { /* Tên bài hát 2D mới */
            /* Loại bỏ định vị tuyệt đối để nó hiển thị theo luồng flex-direction: column */
            /* position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); */
            color: white;
            font-size: 12px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px; /* Đặt chiều rộng tối đa cho desktop */
            text-align: center; /* Căn giữa văn bản */
            pointer-events: none; /* Cho phép click xuyên qua để tương tác với thanh tiến trình */
            margin: 5px auto; /* Khoảng cách trên dưới và căn giữa ngang */
            background-color: rgba(0, 0, 0, 0.6); /* Nền hơi tối để dễ đọc */
            padding: 2px 5px;
            border-radius: 3px;
        }
        #music-player-progress-bar-2d {
            background-color: #3498db;
            height: 100%;
            width: 0%;
            border-radius: 5px;
        }
        /* --- 3D Music Player Styles --- */
        .music-player-container-3d {
            background-color: transparent; /* Nền hoàn toàn trong suốt */
            border: none; /* Bỏ viền */
            border-radius: 10px;
            padding: 10px;
            width: 250px;
            color: white;
            font-family: Arial, sans-serif;
            box-shadow: none; /* Bỏ hiệu ứng đổ bóng */
            backdrop-filter: none; /* Bỏ hiệu ứng làm mờ nền */
            -webkit-backdrop-filter: none; /* Bỏ hiệu ứng làm mờ nền cho trình duyệt Webkit */
            position: relative;
            pointer-events: auto; /* Allow interaction with the player */
        }
        .music-player-title {
            /* Existing styles */
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            
            /* New styles for scrolling */
            white-space: nowrap; /* Ensure text stays on one line */
            overflow: hidden; /* Hide anything outside the container */
            text-overflow: ellipsis; /* Fallback for non-scrolling state */
            position: relative; /* Needed for positioning inner elements */
            width: 100%; /* Take full width of parent */
            height: 1.2em; /* Fixed height to prevent layout shifts */
            line-height: 1.2em; /* Vertically align text */
        }
        .music-player-title-scroll-container {
            display: inline-block; /* Allows it to be wider than its parent */
            white-space: nowrap; /* Keeps content on one line */
            position: absolute; /* Position absolutely within .music-player-title */
            left: 0;
            top: 0;
        }
        .music-player-title-text,
        .music-player-title-text-duplicate {
            display: inline-block; /* Allows them to sit side-by-side */
            padding-right: 20px; /* Space between original and duplicate text */
        }
        @keyframes scrollText {
            0% { transform: translateX(0); }
            100% { transform: translateX(var(--scroll-distance)); } /* Dynamically set scroll distance */
        }
        .music-player-title.scrolling .music-player-title-scroll-container {
            animation: scrollText var(--scroll-duration) linear infinite;
        }
        .music-player-time {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            margin-top: 5px;
        }
        .music-player-visualizer {
            display: block; /* Đảm bảo canvas là block element để căn giữa */
            margin: 5px auto; /* Căn giữa bên dưới tiêu đề/thời gian */
            background-color: transparent; /* Nền trong suốt */
            border-radius: 3px;
            border: none; /* Bỏ viền */
        }

        /* New container for main UI buttons */
        #main-ui-controls {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px; /* Extends across the top */
            z-index: 1001;
            display: flex;
            justify-content: space-between; /* Distribute items */
            align-items: center;
            background-color: transparent; /* Làm nền trong suốt */
            border: none; /* Bỏ viền */
            pointer-events: none; /* Allow clicks to pass through to the scene by default */
        }

        #main-ui-controls > * {
            pointer-events: auto; /* Make children interactive */
        }

        /* Remove fixed positioning from individual buttons, let flexbox handle it */
        #select-planet-btn,
        #select-song-btn {
            /* Các nút này giờ là con của #main-ui-controls, nên position: static là phù hợp */
            position: static;
            margin: 0;
        }

        /* Remove fixed positioning from 2D music controls */
        #music-controls-2d {
            position: static;
            margin: 0;
        }

        /* Mobile Layout (max-width: 768px) */
        @media (max-width: 768px) {
            /* Main UI Controls Bar at the bottom */
            #main-ui-controls {
                top: auto; /* Remove top positioning */
                bottom: 10px; /* Position at the bottom */
                left: 10px;
                right: 10px;
                display: flex;
                flex-wrap: wrap; /* Allow items to wrap to the next line */
                justify-content: center; /* Center items when they wrap */
                align-items: center; /* Vertically align items within the bar */
                gap: 5px; /* Giảm khoảng cách giữa các nút và hàng khi wrap */
                padding: 5px; /* Add some padding */
                background-color: rgba(0,0,0,0.5); /* Nền hơi tối để dễ đọc */
                border-radius: 8px;
                border: none; /* Bỏ viền */
            }

            #select-planet-btn,
            #select-song-btn {
                /* Áp dụng kiểu dáng cụ thể cho mobile */
                padding: 5px 8px; /* Giảm padding thêm */
                font-size: 11px; /* Giảm font size thêm */
                border: none; /* Bỏ viền */
            }

            #music-controls-2d {
                padding: 2px 6px; /* Smaller padding */
                gap: 4px; /* Smaller gap */
                border: none; /* Bỏ viền */
            }

            #music-controls-2d button {
                /* Kích thước nút đã được giữ nguyên */
                width: 22px; /* Giảm kích thước thêm */
                height: 22px; /* Giảm kích thước thêm */
                font-size: 9px; /* Giảm kích thước chữ thêm */
            }

            #music-player-progress-container-2d {
                width: 100px; /* Giảm chiều rộng thêm */
            }
            .music-player-buttons-row {
                width: 100px; /* Giảm chiều rộng thêm */
                transform: translateX(0); /* Bỏ dịch chuyển để căn giữa tốt hơn */
            }
            #music-player-song-title-2d { /* Điều chỉnh chiều rộng cho mobile */
                max-width: 100px; /* Giảm chiều rộng thêm */
            }

            #overview-btn { /* Kiểu dáng mobile cho nút mới */
                top: 20px; /* Di chuyển lên góc trên bên phải cho mobile */
                bottom: auto; /* Hủy bỏ định vị bottom */
                padding: 8px 12px; /* Smaller padding */
                font-size: 14px; /* Smaller font size */
                border: none; /* Bỏ viền */
            }

            /* Overlays for mobile (positioned above the bottom control bar) */
            #planet-list-overlay,
            #song-list-overlay {
                top: auto; /* Remove top positioning */
                bottom: 70px; /* Position above the bottom control bar */
                bottom: 60px; /* Đặt vị trí cách lề dưới 60px (để tránh thanh điều khiển chính) */
                left: 50%; /* Center horizontally */
                transform: translateX(-50%); /* Center horizontally */
                width: 90%; /* Take up most of the width */
                max-width: 250px; /* Max width for larger phones, further reduced */
                min-width: 180px; /* Đặt lại min-width để tránh quá nhỏ */
                padding: 8px; /* Adjust padding */
                background-color: rgba(0,0,0,0.8); /* Darker background for readability */
                max-height: calc(100vh - 70px); /* Chiều cao tối đa để không tràn màn hình (100vh - 60px bottom - 10px top margin) */
                overflow-y: auto; /* Cho phép cuộn nếu nội dung quá dài */
                box-shadow: 0 0 10px rgba(0,255,255,0.7); /* Slightly stronger shadow */
            }

            #close-dropmenu-btn,
            #close-song-menu-btn {
                top: 5px;
                right: 8px; /* Điều chỉnh vị trí nút đóng */
                font-size: 18px;
            }

            .planet-list-item,
            .song-list-item {
                padding: 6px; /* Smaller padding */
                font-size: 12px;
            }

            /* Fullscreen overlay adjustments */
            #close-btn {
                top: 10px;
                right: 10px;
                font-size: 24px;
            }

            #download-btn {
                bottom: 10px;
                right: 10px;
                padding: 5px 10px;
                font-size: 11px; /* Giảm kích thước thêm */
            }

            /* 3D Music Player (internal styling) */
            .music-player-container-3d {
                width: 150px; /* Smaller width for mobile */
                padding: 6px;
            }
            .music-player-title {
                font-size: 9px; /* Smaller font size */
                height: 1.3em; /* Adjust height for new font size */
                line-height: 1.3em; /* Adjust line height */
            }
            .music-player-time {
                font-size: 7px; /* Smaller font size */
            }
            .music-player-visualizer {
                width: 110px; /* Adjust visualizer width to match container */
                height: 25px; /* Adjust height */
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
</head>
<body>
    <div id="music-player-scene-container"></div>

    <div id="loader-overlay">
        <div class="loader-container">
            <div class="progress-circle">
                <div class="progress-circle-inner">
                    <span id="progress-text" class="loader-text">0%</span>
                </div>
            </div>
            <span class="loader-text">Đang tải tài nguyên ...</span>
        </div>
    </div>
    <div id="fullscreen-overlay">
        <span id="close-btn">&times;</span>
        <img id="fullscreen-image" src="" alt="fullscreen-image" />
        <a id="download-btn" href="#" download style="display: none;">Tải xuống</a>
    </div>

    <div id="main-scene">
        <!-- New container for UI buttons -->
        <div id="main-ui-controls">
            <button id="select-planet-btn">Hành tinh</button>
            <!-- <button id="overview-btn">Toàn cảnh</button> Removed from here -->
            <div id="music-controls-2d" style="display: none;">
                <div id="music-player-progress-container-2d">
                    <div id="music-player-progress-bar-2d"></div>
                    <div id="music-player-progress-handle-2d"></div> <!-- Chấm kéo mới -->
                </div>
                <span id="music-player-song-title-2d"></span> <!-- Tên bài hát 2D mới -->
                <div class="music-player-buttons-row"> <!-- Hàng nút điều khiển mới -->
                    <button id="music-player-prev-2d">⏮</button>
                    <button id="music-player-play-pause-2d">▶</button>
                    <button id="music-player-next-2d">⏭</button>
                </div>
            </div>
            <button id="select-song-btn">Chọn nhạc</button>
        </div>
        <!-- Existing overlays -->
        <div id="planet-list-overlay">
            <span id="close-dropmenu-btn">&times;</span>
            <ul id="planet-selection-list" style="list-style: none; padding: 0; margin: 0;">
                <!-- Planet items will be inserted here -->
            </ul>
        </div>
        <div id="song-list-overlay">
            <span id="close-song-menu-btn">&times;</span>
            <ul id="song-selection-list" style="list-style: none; padding: 0; margin: 0;">
                <!-- Song items will be inserted here -->
            </ul>
        </div> <!-- Đóng thẻ div cho song-list-overlay -->
        <button id="overview-btn">Toàn cảnh</button> <!-- Moved here -->
        <!-- Canvas and renderers will be appended here by Three.js -->
    </div>

    <audio id="background-music" loop></audio>

    <script>
        // --- Image & Planet Data ---
        const totalImages = 62;
        const allImageUrls = Array.from({length: totalImages}, (_, i) => `images/${i + 1}.png`);
        const usedImageUrls = new Set();
        const planets = [];
        // Speeds are calculated relative to Earth's orbital period for a more realistic simulation.
        // The base speed is adjusted for visual appeal.
        const planetData = [
            { name: 'Sao Thủy', distance: 20, size: 1, color: 0xaaaaaa, speed: 0.00167, realSpeed: 47.87 },   // Period: 0.24 Earth years
            { name: 'Sao Kim', distance: 35, size: 1.5, color: 0xe8ab6f, speed: 0.00065, realSpeed: 35.02 },    // Period: 0.62 Earth years
            { name: 'Trái Đất', distance: 50, size: 1.6, color: 0x6f94e8, speed: 0.0004, realSpeed: 29.78 },     // Period: 1.00 Earth years
            { name: 'Sao Hỏa', distance: 70, size: 1.2, color: 0xe86f6f, speed: 0.00021, realSpeed: 24.08 },    // Period: 1.88 Earth years
            { name: 'Sao Mộc', distance: 100, size: 4, color: 0xd8caa0, speed: 0.000034, realSpeed: 13.07 },   // Period: 11.86 Earth years
            { name: 'Sao Thổ', distance: 140, size: 3.5, color: 0xead5a8, speed: 0.000014, realSpeed: 9.69 },   // Period: 29.46 Earth years
            { name: 'Sao Thiên Vương', distance: 180, size: 2.5, color: 0xa8e0ea, speed: 0.0000048, realSpeed: 6.81 },// Period: 84.01 Earth years
            { name: 'Sao Hải Vương', distance: 220, size: 2.4, color: 0x5c84f5, speed: 0.0000024, realSpeed: 5.43 } // Period: 164.8 Earth years
        ];

        // --- Loading Manager ---
        const loadingManager = new THREE.LoadingManager();
        const textureLoader = new THREE.TextureLoader(loadingManager);
        const loaderOverlay = document.getElementById('loader-overlay');
        const progressCircle = document.querySelector('.progress-circle');
        const progressText = document.getElementById('progress-text');

        loadingManager.onProgress = function (url, itemsLoaded, itemsTotal) {
            const progress = (itemsLoaded / itemsTotal) * 100;
            const percentage = Math.round(progress);
            progressText.textContent = `${percentage}%`;
            progressCircle.style.background = `conic-gradient(#3498db ${progress}%, #1a1a1a 0%)`;
        };

        loadingManager.onLoad = function () {
            // Fade out loader
            loaderOverlay.style.opacity = '0';
            setTimeout(() => {
                loaderOverlay.style.display = 'none';
                // Show the main scene and start the animation
                document.getElementById('main-scene').style.display = 'block';
                // Nút "Toàn cảnh" giờ đã được đặt đúng vị trí và có CSS display: block, nên không cần setTimeout hay console.log nữa.
                // console.log('Main scene displayed. Overview button display:', document.getElementById('overview-btn').style.display); // Debugging (có thể xóa)
                animate();
            }, 500);
        };
        
        // --- Preload all images and cache them---
        const textureCache = {};
        allImageUrls.forEach(url => {
            textureCache[url] = textureLoader.load(url);
        });

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('main-scene').appendChild(renderer.domElement);
        
        // --- Starfield ---
        let stars;
        function addStarfield() {
            const starGeometry = new THREE.BufferGeometry();

            // Create a circular texture for the stars to make them round instead of square
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            context.beginPath();
            context.arc(16, 16, 16, 0, 2 * Math.PI); // Draw a circle
            context.fillStyle = 'white';
            context.fill();
            const starTexture = new THREE.CanvasTexture(canvas);

            const starMaterial = new THREE.PointsMaterial({
                map: starTexture,
                size: 1.5, // Slightly increased size for better visibility
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false // Prevents rendering issues with transparency
            });

            const starVertices = [];
            for (let i = 0; i < 15000; i++) {
                const x = (Math.random() - 0.5) * 2500;
                const y = (Math.random() - 0.5) * 2500;
                const z = (Math.random() - 0.5) * 2500;
                starVertices.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }
        addStarfield();

        // --- Label Renderer Setup ---
        const labelRenderer = new THREE.CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        document.getElementById('main-scene').appendChild(labelRenderer.domElement);

        // --- Music Player Scene & Renderer (Không gian nền) ---
        const musicPlayerScene = new THREE.Scene();
        const musicPlayerRenderer = new THREE.CSS2DRenderer();
        musicPlayerRenderer.setSize(window.innerWidth, window.innerHeight);
        musicPlayerRenderer.domElement.style.position = 'absolute';
        musicPlayerRenderer.domElement.style.top = '0px';
        document.getElementById('music-player-scene-container').appendChild(musicPlayerRenderer.domElement);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        // --- Controls ---
        const controls = new THREE.OrbitControls(camera, labelRenderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 10;
        controls.maxDistance = 1500;

        // --- Sun ---
        const sunGeometry = new THREE.SphereGeometry(10, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffdd00 });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.userData = { isSun: true, name: 'Mặt trời', size: 10 }; // Thêm tên và kích thước cho Mặt trời
        scene.add(sun);
        const sunLight = new THREE.PointLight(0xffffff, 1.5, 2000);
        sun.add(sunLight);

        // --- Create Planets and Orbits ---
        planetData.forEach(data => {
            const planetGeometry = new THREE.SphereGeometry(data.size, 32, 32);
            const planetMaterial = new THREE.MeshStandardMaterial({ color: data.color });
            const planet = new THREE.Mesh(planetGeometry, planetMaterial);
            
            const imageGroup = new THREE.Group();
            planet.add(imageGroup);
            sun.userData.imageGroup = new THREE.Group(); // Initialize imageGroup for sun

            // Create Label
            const planetDiv = document.createElement('div');
            planetDiv.className = 'planet-label';
            planetDiv.textContent = data.name;
            planetDiv.addEventListener('click', (event) => {
                event.stopPropagation();
                handlePlanetClick(planet); // Call handlePlanetClick directly
            });
            // Thêm lắng nghe sự kiện touchend cho nhãn để đảm bảo tương tác chạm trên di động
            planetDiv.addEventListener('touchend', (event) => {
                event.preventDefault(); // Ngăn chặn hành vi mặc định của trình duyệt (ví dụ: ghost click)
                event.stopPropagation(); // Ngăn chặn sự kiện lan truyền thêm (ví dụ: đến OrbitControls hoặc onInteraction)
                handlePlanetClick(planet); // Call handlePlanetClick directly
            });
            const planetLabel = new THREE.CSS2DObject(planetDiv);
            planetLabel.position.set(0, data.size + 2, 0);
            planet.add(planetLabel);

            // Tạo một hitbox hình cầu vô hình lớn hơn một chút so với hành tinh
            const hitboxGeometry = new THREE.SphereGeometry(data.size + 0.5, 32, 32); // Lớn hơn hành tinh 0.5 đơn vị
            const hitboxMaterial = new THREE.MeshBasicMaterial({
                transparent: true,
                opacity: 0, // Hoàn toàn vô hình
                depthWrite: false // Không ghi vào depth buffer để không ảnh hưởng đến các đối tượng khác
            });
            const hitboxSphere = new THREE.Mesh(hitboxGeometry, hitboxMaterial);
            hitboxSphere.userData = { isHitbox: true, parentPlanet: planet }; // Đánh dấu đây là hitbox và liên kết với hành tinh cha
            planet.add(hitboxSphere); // Thêm hitbox vào hành tinh để nó di chuyển cùng

            planet.userData = { 
                ...data, 
                isPlanet: true, 
                angle: Math.random() * Math.PI * 2, // Initial orbital angle
                interactionState: 0, // 0: default, 1: images shown & locked, 2: images shown & unlocked, 3: images hidden & unlocked
                imageGroup: imageGroup
            };
            
            const orbitGeometry = new THREE.TorusGeometry(data.distance, 0.1, 16, 128); // Use TorusGeometry for a 3D tube shape
            const orbitMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.6, transparent: true });
            const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
            orbit.rotation.x = -Math.PI / 2;
            scene.add(orbit);
            
            if (data.name === 'Sao Thổ') {
                const ringGeometry = new THREE.RingGeometry(data.size * 1.5, data.size * 2.5, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({ color: 0xead5a8, side: THREE.DoubleSide, opacity: 0.7, transparent: true });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI * 0.4;
                planet.add(ring);
            }

            scene.add(planet);
            planets.push(planet);
        });

        // --- Camera Position ---
        camera.position.set(0, 100, 250);
        camera.lookAt(scene.position);

        // --- Raycasting for Clicks ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let sunMessage = null; // To track the sun message label
        let sunMessageMesh = null;
        let sunMessageAnimation = { active: false };

        // --- Camera Lock Feature Variables ---
        let lockedPlanet = null; // Stores the planet object to follow
        let isViewLocked = false; // Flag to indicate if view is locked
        let lastTouchTimestamp = 0;
        // Variables for two-stage camera animation
        let isCameraAnimating = false;
        let cameraAnimationStartTime = 0;
        // 0: idle, 1: return to home view, 2: move to target planet
        let cameraAnimationPhase = 0;
        const returnToHomeDuration = 1000; // milliseconds for returning to initial view
        const moveToTargetDuration = 1500; // milliseconds for moving to target planet

        const startCameraPosition = new THREE.Vector3();
        const startControlsTarget = new THREE.Vector3();
        // Define the "home" view (initial camera position and target)
        const homeCameraPosition = new THREE.Vector3(0, 100, 250);
        const homeControlsTarget = new THREE.Vector3(0, 0, 0);
        const finalCameraPosition = new THREE.Vector3();       // Final camera position near planet

        const overviewControlsTarget = new THREE.Vector3(0, 0, 0);
        const finalControlsTarget = new THREE.Vector3();        // Final controls target (planet's world position)
        const TOUCH_DELAY = 300; // Milliseconds to prevent ghost clicks

        // Easing function for smoother animations
        function easeInOutSine(t) {
            return 0.5 - 0.5 * Math.cos(t * Math.PI);
        }

        // Định nghĩa chế độ xem "Toàn cảnh"
        const maxPlanetDistance = planetData[planetData.length - 1].distance; // Lấy khoảng cách của hành tinh ngoài cùng
        let overviewCameraPosition; // Khai báo là 'let' để có thể gán lại

        function calculateOverviewCameraPosition() {
            const isMobile = window.innerWidth <= 768;
            // Điều chỉnh padding theo đơn vị thế giới. Giá trị này sẽ ảnh hưởng đến mức độ zoom.
            // Giá trị lớn hơn sẽ zoom ra xa hơn, giá trị nhỏ hơn sẽ zoom gần hơn.
            // Đây là một giá trị heuristic để mô phỏng "cách lề 50px/10px". Để zoom to hơn, giảm giá trị này.
            const worldPadding = isMobile ? 15 : 40; // Giảm padding để zoom gần hơn: 15 cho mobile, 40 cho desktop

            // Kích thước mục tiêu (nửa chiều rộng/chiều cao) mà camera cần nhìn thấy
            const targetHalfWidth = maxPlanetDistance + worldPadding;
            const targetHalfHeight = maxPlanetDistance + worldPadding;

            // Tính toán FOV ngang dựa trên FOV dọc và tỷ lệ khung hình
            const vFovRad = THREE.MathUtils.degToRad(camera.fov);
            const hFovRad = 2 * Math.atan(Math.tan(vFovRad / 2) * camera.aspect);

            // Tính toán Z cần thiết để vừa với chiều ngang
            // Z = (chiều rộng mục tiêu / 2) / tan(hFov / 2)
            let zHorizontal = targetHalfWidth / Math.tan(hFovRad / 2);
            
            // Tính toán Z cần thiết để vừa với chiều dọc
            // Z = (chiều cao mục tiêu / 2) / tan(vFov / 2)
            let zVertical = targetHalfHeight / Math.tan(vFovRad / 2);

            // Lấy giá trị Z lớn hơn để đảm bảo cả hai chiều đều vừa
            let finalZ = Math.max(zHorizontal, zVertical);

            // Điều chỉnh Y để duy trì góc nhìn tương tự như vị trí ban đầu (0, 500, 1000)
            // Tỷ lệ ban đầu: Y/Z = 500/1000 = 0.5
            const finalY = finalZ * 0.5; // Giữ tỷ lệ Y/Z nhất quán

            return new THREE.Vector3(0, finalY, finalZ);
        }

        // Khởi tạo vị trí camera toàn cảnh ban đầu
        overviewCameraPosition = calculateOverviewCameraPosition();

        function onInteraction(event) {
            console.log('onInteraction called, event type:', event.type); // Debugging line

            // Prevent ghost clicks on mobile: if a click event happens very soon after a touchend, ignore it.
            if (event.type === 'touchend') {
                lastTouchTimestamp = Date.now();
            } else if (event.type === 'click') {
                if (Date.now() - lastTouchTimestamp < TOUCH_DELAY) {
                    return; // This click is likely a ghost click, already handled by touchend
                }
            }

            if (event.target.closest('.planet-label')) {
                console.log('Tapped on planet label, ignoring raycast.'); // Debugging line
                return;
            }

            // Determine the correct clientX and clientY for both mouse and touch events
            const rect = renderer.domElement.getBoundingClientRect();
            let clientX, clientY;
            if (event.changedTouches && event.changedTouches.length > 0) { // For touchend, use changedTouches
                clientX = event.changedTouches[0].clientX;
                clientY = event.changedTouches[0].clientY;
            } else if (event.touches && event.touches.length > 0) { // For other touch events (e.g., touchstart, touchmove)
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else { // For mouse events
                clientX = event.clientX;
                clientY = event.clientY;
            }

            if (typeof clientX === 'undefined' || typeof clientY === 'undefined') {
                // No valid coordinates found, exit
                console.log('No valid coordinates found, exiting onInteraction.'); // Debugging line
                return;
            }

            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                // Nếu một đối tượng được nhấn, ngăn chặn OrbitControls xử lý chạm này như một thao tác camera
                if (event.type === 'touchend') {
                    event.preventDefault();
                    event.stopPropagation();
                }
                console.log('Raycaster hit something!', intersects[0].object); // Debugging line
                let clickedObject = intersects[0].object;

                if (clickedObject.userData.isHitbox) {
                    handlePlanetClick(clickedObject.userData.parentPlanet); // Use new handler for direct planet clicks
                    return; // Process hitbox click, then exit
                }

                if (clickedObject.userData.isSun) {
                    showMessageOnSun();
                } else if (clickedObject.userData.isImagePlane) {
                    document.getElementById('fullscreen-image').src = clickedObject.userData.imageUrl;
                    document.getElementById('fullscreen-overlay').style.display = 'flex';
                    document.getElementById('download-btn').href = clickedObject.userData.imageUrl;
                    document.getElementById('select-planet-btn').style.display = 'none'; // Ẩn nút "Chọn hành tinh"
                    document.getElementById('download-btn').style.display = 'block'; // Hiển thị nút tải xuống
                    if (!isViewLocked) { // Only disable controls if view is NOT locked
                        controls.enabled = false;
                    }
                } else {
                    let parentPlanet = clickedObject;
                    while (parentPlanet.parent && !parentPlanet.userData.isPlanet) {
                        parentPlanet = parentPlanet.parent;
                    }
                    if (parentPlanet.userData.isPlanet) {
                        handlePlanetClick(parentPlanet); // Use new handler for direct planet clicks
                    }
                }
            } else {
                console.log('Raycaster hit nothing.'); // Debugging line
            }
        }

        // --- Planet Selection UI Logic ---
        const selectPlanetBtn = document.getElementById('select-planet-btn');
        const planetListOverlay = document.getElementById('planet-list-overlay');
        const planetSelectionList = document.getElementById('planet-selection-list');
        const closeDropmenuBtn = document.getElementById('close-dropmenu-btn');

        selectPlanetBtn.addEventListener('click', showPlanetList);
        closeDropmenuBtn.addEventListener('click', (event) => {
            event.stopPropagation(); // Ngăn chặn sự kiện lan truyền lên document
            hidePlanetList();
        });

        function showPlanetList() {
            planetListOverlay.style.display = 'flex';
            populatePlanetList();
            controls.enabled = false; // Disable controls when list is open
            // Thêm trình lắng nghe sự kiện toàn cục để đóng dropmenu khi click/touch bên ngoài
            document.addEventListener('click', handleOutsideInteraction);
            document.addEventListener('touchend', handleOutsideInteraction);
        }

        function hidePlanetList() {
            planetListOverlay.style.display = 'none';
            // Chỉ kích hoạt lại controls nếu không có hoạt ảnh camera nào đang diễn ra và chế độ xem không bị khóa
            if (!isCameraAnimating && !isViewLocked) {
                controls.enabled = true;
            }
            // Xóa trình lắng nghe sự kiện toàn cục
            document.removeEventListener('click', handleOutsideInteraction);
            document.removeEventListener('touchend', handleOutsideInteraction);
        }
        // Thêm trình lắng nghe sự kiện để đóng dropmenu khi nhấn phím ESC
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                if (planetListOverlay.style.display === 'flex') {
                    hidePlanetList();
                }
                if (isSongListOpen) {
                    hideSongList();
                }
            }
        });

        function handleOutsideInteraction(event) {
            // Kiểm tra xem sự kiện click/touch có nằm ngoài dropmenu và nút "Chọn hành tinh" hay không
            const isClickInsideOverlay = planetListOverlay.contains(event.target);
            const isClickOnSelectButton = selectPlanetBtn.contains(event.target);

            if (!isClickInsideOverlay && !isClickOnSelectButton) {
                hidePlanetList();
            }
        }

        function populatePlanetList() {
            planetSelectionList.innerHTML = ''; // Clear previous list

            // Thêm Mặt trời vào danh sách
            const sunListItem = document.createElement('li');
            sunListItem.className = 'planet-list-item';
            sunListItem.textContent = sun.userData.name;
            sunListItem.addEventListener('click', () => {
                handlePlanetClick(sun); // Use handlePlanetClick for sun
                event.stopPropagation(); // Ngăn chặn sự kiện lan truyền lên document
                hidePlanetList();
            });
            planetSelectionList.appendChild(sunListItem);

            // Thêm các hành tinh vào danh sách
            planets.forEach(planet => {
                const listItem = document.createElement('li');
                listItem.className = 'planet-list-item';
                listItem.textContent = planet.userData.name;
                listItem.addEventListener('click', () => {
                    handlePlanetClick(planet); // Use handlePlanetClick for planets
                    event.stopPropagation(); // Ngăn chặn sự kiện lan truyền lên document
                    hidePlanetList();
                });
                planetSelectionList.appendChild(listItem);
            });
        }
        
        // --- Music Player Logic ---
        // --- CẤU HÌNH NHẠC ---
        // 1. Đặt tên các file nhạc của bạn theo thứ tự: music1.mp3, music2.mp3, ... và đặt chúng vào thư mục 'music'.
        // 2. Cập nhật số `totalMusicFiles` dưới đây cho khớp với tổng số file nhạc bạn có.
        const totalMusicFiles = 3; // <-- Đã cập nhật lên 3

        // Tự động tạo danh sách bài hát. Sau này bạn có thể gán tên cụ thể cho từng bài.
        const songs = [];
        for (let i = 1; i <= totalMusicFiles; i++) {
            let songName;
            if (i === 1) {
                songName = "Đi Cùng Anh - buitruonglinh (ft. 52Hz)";
            } else if (i === 2) {
                songName = "BABY LAVIEM ( #BBLVE ) - BigWind x KA";
            } else if (i === 3) {
                songName = "Anh Chưa Từng Hết Yêu / buitruonglinh";
            } else {
                songName = `Bài hát ${i}`; // Tên mặc định cho các bài hát khác
            }
            songs.push({
                name: songName,
                file: `music/music${i}.mp3`
            });
        }

        const audioPlayer = document.getElementById('background-music');
        const selectSongBtn = document.getElementById('select-song-btn');
        const songListOverlay = document.getElementById('song-list-overlay');
        const songSelectionList = document.getElementById('song-selection-list');
        const closeSongMenuBtn = document.getElementById('close-song-menu-btn');
        let isSongListOpen = false;

        // Global variables for audio visualization
        let audioContext = null;
        let analyser = null;
        let dataArray = null;
        let bufferLength = null;
        let audioSource = null; // To hold the MediaElementSourceNode
        
        // References for the new 2D music controls
        const musicControls2D = document.getElementById('music-controls-2d');
        const prevBtn2D = document.getElementById('music-player-prev-2d');
        const playPauseBtn2D = document.getElementById('music-player-play-pause-2d');
        const nextBtn2D = document.getElementById('music-player-next-2d');
        const progressContainer2D = document.getElementById('music-player-progress-container-2d');
        const progressBar2D = document.getElementById('music-player-progress-bar-2d');
        const musicPlayerSongTitle2D = document.getElementById('music-player-song-title-2d'); // Tham chiếu đến tên bài hát 2D
        const progressHandle2D = document.getElementById('music-player-progress-handle-2d'); // Tham chiếu đến chấm kéo mới
        // New variables for the 3D music player
        let musicPlayerObject = null;
        let currentSongIndex = -1;        
        // References for the visualizer canvas within the 3D player
        let visualizerCanvas = null;
        let visualizerCtx = null;

        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 128; // Giảm FFT size để có ít thanh hơn, mỗi thanh rộng hơn và rõ ràng hơn
                bufferLength = analyser.frequencyBinCount; // Half of fftSize
                dataArray = new Uint8Array(bufferLength);

                audioSource = audioContext.createMediaElementSource(audioPlayer);
                audioSource.connect(analyser);
                analyser.connect(audioContext.destination);
            }
        }

        function playSong(file) {
            initAudioContext(); // Ensure context is initialized
            if (audioContext.state === 'suspended') {
                audioContext.resume(); // Resume if suspended
            }
            audioPlayer.src = file;
            audioPlayer.play().catch(error => {
                console.log("Phát nhạc bị chặn bởi trình duyệt. Cần người dùng tương tác để bắt đầu.", error);
                // Trình duyệt hiện đại thường chặn tự động phát âm thanh.
                // Âm thanh sẽ chỉ phát sau khi người dùng click vào một thứ gì đó trên trang.
            });
        }

        function populateSongList() {
            songSelectionList.innerHTML = ''; // Clear previous list
            songs.forEach(song => {
                const listItem = document.createElement('li');
                listItem.className = 'song-list-item';
                listItem.textContent = song.name;
                listItem.addEventListener('click', () => {
                    const songIndex = songs.findIndex(s => s.file === song.file);
                    audioPlayer.pause(); // Pause current song before showing new player
                    if (songIndex !== -1) {
                        showMusicPlayer(songIndex);
                    }
                    hideSongList(); // Close the selection menu
                });
                songSelectionList.appendChild(listItem);
            });
        }

        function showSongList() {
            songListOverlay.style.display = 'block';
            isSongListOpen = true;
            musicControls2D.style.display = 'none'; // Hide 2D controls when song list is open
            populateSongList();
            // Add global listener to close menu
            document.addEventListener('click', handleOutsideSongInteraction, true);
            document.addEventListener('touchend', handleOutsideSongInteraction, true);
        }

        function hideSongList() {
            songListOverlay.style.display = 'none';
            isSongListOpen = false;
            if (currentSongIndex !== -1) musicControls2D.style.display = 'flex'; // Show 2D controls if a song is selected
            // Remove global listener
            document.removeEventListener('click', handleOutsideSongInteraction, true);
            document.removeEventListener('touchend', handleOutsideSongInteraction, true);
        }

        function handleOutsideSongInteraction(event) {
            if (isSongListOpen && !songListOverlay.contains(event.target) && !selectSongBtn.contains(event.target)) {
                hideSongList();
            }
        }

        selectSongBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            isSongListOpen ? hideSongList() : showSongList();
        });

        closeSongMenuBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            hideSongList();
        });

        function show2DMusicControls() {
            musicControls2D.style.display = 'flex';

            playPauseBtn2D.onclick = () => { /* Existing code */
                if (audioPlayer.paused) {
                    audioPlayer.play();
                } else {
                    audioPlayer.pause();
                }
            };

            prevBtn2D.onclick = () => {
                const newIndex = (currentSongIndex - 1 + songs.length) % songs.length;
                showMusicPlayer(newIndex);
            };

            nextBtn2D.onclick = () => {
                const newIndex = (currentSongIndex + 1) % songs.length;
                showMusicPlayer(newIndex);
            };

            progressContainer2D.onclick = (e) => {
                const rect = progressContainer2D.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const percentage = clickX / rect.width;
                if (audioPlayer.duration) {
                    audioPlayer.currentTime = audioPlayer.duration * percentage;
                }
            };
            // Thêm lắng nghe sự kiện cho chấm kéo mới
            progressHandle2D.addEventListener('mousedown', startProgressDrag);
            progressHandle2D.addEventListener('touchstart', startProgressDrag, { passive: false });

            // Đảm bảo tên bài hát 2D ẩn khi trình phát nhạc 2D hiển thị lần đầu
            if (musicPlayerSongTitle2D) {
                musicPlayerSongTitle2D.style.display = 'none';
            } /* This line is now removed as the song title should be visible by default when controls are shown */
            updateMusicPlayerUI(); // Initial UI update for 2D controls
        }

        // --- Logic kéo thanh tiến trình ---
        let isDraggingProgress = false;

        function startProgressDrag(e) {
            e.preventDefault(); // Ngăn chặn hành vi mặc định của trình duyệt (ví dụ: chọn văn bản, cuộn)
            e.stopPropagation(); // Ngăn chặn sự kiện lan truyền lên container click/touch
            isDraggingProgress = true;
            controls.enabled = false; // Tắt OrbitControls khi đang kéo

            document.addEventListener('mousemove', doProgressDrag);
            document.addEventListener('mouseup', endProgressDrag);
            document.addEventListener('touchmove', doProgressDrag, { passive: false });
            document.addEventListener('touchend', endProgressDrag);
        }

        function doProgressDrag(e) {
            if (!isDraggingProgress) return;

            let clientX;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
            } else {
                clientX = e.clientX;
            }

            const rect = progressContainer2D.getBoundingClientRect();
            let newX = clientX - rect.left; // Vị trí tương đối so với container

            // Giới hạn newX trong phạm vi của container
            newX = Math.max(0, Math.min(newX, rect.width));

            const percentage = newX / rect.width;
            if (audioPlayer.duration) {
                audioPlayer.currentTime = audioPlayer.duration * percentage;
            }
            updateMusicPlayerUI(); // Cập nhật giao diện ngay lập tức trong khi kéo để có phản hồi trực quan
        }

        function endProgressDrag() {
            isDraggingProgress = false;
            controls.enabled = true; // Kích hoạt lại OrbitControls sau khi kéo
            document.removeEventListener('mousemove', doProgressDrag);
            document.removeEventListener('mouseup', endProgressDrag);
            document.removeEventListener('touchmove', doProgressDrag);
            document.removeEventListener('touchend', endProgressDrag);
        }
        function hide2DMusicControls() {
            musicControls2D.style.display = 'none';
        }

        // --- 3D Music Player Functions ---
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }

        function hideMusicPlayer() {
            if (musicPlayerObject) {
                musicPlayerScene.remove(musicPlayerObject);
                musicPlayerObject.element.remove(); // Clean up the DOM element
                musicPlayerObject = null;
            }
            hide2DMusicControls(); // Hide 2D controls when 3D player is hidden
            audioPlayer.pause();
            audioPlayer.src = '';
            currentSongIndex = -1;
        }

        function showMusicPlayer(songIndex) {
            if (musicPlayerObject) { // If a player is already shown, hide it first
                hideMusicPlayer();
            }

            currentSongIndex = songIndex;
            const song = songs[currentSongIndex];
            if (!song) return;

            // --- Create Player HTML Elements ---
            const playerContainer = document.createElement('div');
            playerContainer.className = 'music-player-container-3d';

            const titleDiv = document.createElement('div');
            titleDiv.className = 'music-player-title';
            titleDiv.title = song.name; // Tooltip for full name

            const scrollContainer = document.createElement('div');
            scrollContainer.className = 'music-player-title-scroll-container';

            const titleText = document.createElement('span');
            titleText.className = 'music-player-title-text';
            titleText.textContent = song.name;
            scrollContainer.appendChild(titleText);

            const timeDiv = document.createElement('div');
            timeDiv.className = 'music-player-time';
            const currentTimeSpan = document.createElement('span');
            currentTimeSpan.id = 'music-player-current-time';
            currentTimeSpan.textContent = '0:00';
            const totalTimeSpan = document.createElement('span');
            totalTimeSpan.id = 'music-player-total-time';
            totalTimeSpan.textContent = '0:00'; // Will be updated by loadedmetadata
            timeDiv.append(currentTimeSpan, totalTimeSpan); // Append time spans to the 3D player's time div

            // Create the visualizer canvas
            const visualizerCanvasElement = document.createElement('canvas');
            visualizerCanvasElement.className = 'music-player-visualizer';
            visualizerCanvasElement.width = 230; // Match player width minus padding
            visualizerCanvasElement.height = 50; // Height for the wave

            // Append elements in the desired order: close, title, visualizer, time
            titleDiv.appendChild(scrollContainer); // Add scroll container to title div
            playerContainer.append(titleDiv, visualizerCanvasElement, timeDiv); // Bỏ nút đóng


            // Store references for drawing
            visualizerCanvas = visualizerCanvasElement;
            visualizerCtx = visualizerCanvas.getContext('2d');

            // --- Create and Position 2D Object ---
            musicPlayerObject = new THREE.CSS2DObject(playerContainer);

            // Đặt trình phát nhạc ở một vị trí cố định trong không gian nền (background scene)
            // để nó không bao giờ tương tác hay che khuất hệ mặt trời.
            const playerPosition = new THREE.Vector3(0, 100, -15000);

            musicPlayerObject.position.copy(playerPosition);
            musicPlayerScene.add(musicPlayerObject); // Thêm trình phát nhạc 3D vào scene nền
            show2DMusicControls(); // Show the 2D controls
            playSong(song.file);
            // Call the function to handle scrolling after the player is in the DOM
            // and its width can be accurately determined. Increased delay for better compatibility on deployed environments.
            setTimeout(() => { applyScrollingToTitle(titleDiv, song.name); }, 200);
        }

        function updateMusicPlayerUI() {
            if (!audioPlayer.duration) return;

            // Update 2D controls
            if (playPauseBtn2D) playPauseBtn2D.innerHTML = audioPlayer.paused ? '▶' : '❚❚';
            if (progressBar2D) progressBar2D.style.width = `${(audioPlayer.currentTime / audioPlayer.duration) * 100}%`;

            const progressPercentage = (audioPlayer.currentTime / audioPlayer.duration);
            // Cập nhật vị trí của chấm kéo
            if (progressHandle2D) {
                const containerWidth = progressContainer2D.offsetWidth;
                const handleWidth = progressHandle2D.offsetWidth;
                progressHandle2D.style.left = `${(progressPercentage * containerWidth) - (handleWidth / 2)}px`; /* Existing code */
            }
            // Update 3D player's time display (if it exists)
            const currentTimeSpan = musicPlayerObject ? musicPlayerObject.element.querySelector('#music-player-current-time') : null;
            const totalTimeSpan = musicPlayerObject ? musicPlayerObject.element.querySelector('#music-player-total-time') : null;
            if (currentTimeSpan) currentTimeSpan.textContent = formatTime(audioPlayer.currentTime);
            if (totalTimeSpan) totalTimeSpan.textContent = formatTime(audioPlayer.duration);
        }

        function drawVisualizer() {
            if (!analyser || !visualizerCtx || !audioPlayer || audioPlayer.paused || audioPlayer.ended) {
                // Clear canvas if no audio is playing or analyser is not ready
                if (visualizerCtx) {
                    visualizerCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
                }
                return;
            }

            analyser.getByteFrequencyData(dataArray); // Get frequency data

            visualizerCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);

            // --- Kiểu sóng mới: Các thanh đối xứng từ trung tâm ra hai bên ---

            const canvasWidth = visualizerCanvas.width;
            const canvasHeight = visualizerCanvas.height;
            const centerY = canvasHeight / 2;

            // Chúng ta sẽ vẽ `bufferLength` thanh ở mỗi bên của trung tâm.
            // Do đó, chiều rộng của mỗi thanh sẽ được tính dựa trên một nửa chiều rộng canvas.
            const numBarsPerSide = bufferLength; // Số lượng thanh cho mỗi bên (trái hoặc phải)
            const barWidth = (canvasWidth / 2) / numBarsPerSide; // Chiều rộng thực của mỗi thanh

            // Tạo gradient màu sắc sống động cho các thanh
            const barGradient = visualizerCtx.createLinearGradient(0, 0, canvasWidth, 0);
            barGradient.addColorStop(0, '#00FFFF'); // Cyan
            barGradient.addColorStop(0.5, '#FF00FF'); // Magenta
            barGradient.addColorStop(1, '#FFFF00'); // Yellow
            
            visualizerCtx.fillStyle = barGradient;

            // Thêm hiệu ứng đổ bóng (glow) tinh tế
            visualizerCtx.shadowBlur = 8;
            visualizerCtx.shadowColor = 'rgba(0, 255, 255, 0.7)'; // Màu glow xanh lam

            for (let i = 0; i < numBarsPerSide; i++) {
                // Chuẩn hóa dữ liệu tần số về khoảng 0-1, sau đó áp dụng hàm mũ (power)
                // để làm nổi bật các âm thanh mạnh hơn và giảm bớt các âm thanh yếu,
                // tạo ra một cái nhìn động và chuyên nghiệp hơn.
                const v = Math.pow(dataArray[i] / 255.0, 2.0); // Tăng cường độ phản ứng cho các thanh nổi bật hơn
                const barHeight = v * (canvasHeight / 2) * 0.9; // Chiều cao tối đa là 90% của nửa chiều cao canvas

                // Tính toán vị trí x cho thanh ở bên phải của trung tâm
                const xRight = (canvasWidth / 2) + (i * barWidth);
                // Tính toán vị trí x cho thanh ở bên trái của trung tâm (vẽ từ phải sang trái)
                const xLeft = (canvasWidth / 2) - ((i + 1) * barWidth);

                // Vẽ thanh mở rộng lên trên và xuống dưới, đối xứng qua trục giữa
                visualizerCtx.fillRect(xRight, centerY - barHeight, barWidth - 1, barHeight);
                visualizerCtx.fillRect(xRight, centerY, barWidth - 1, barHeight);
                visualizerCtx.fillRect(xLeft, centerY - barHeight, barWidth - 1, barHeight);
                visualizerCtx.fillRect(xLeft, centerY, barWidth - 1, barHeight);
            }

            // Đặt lại các thuộc tính shadow để không ảnh hưởng đến các bản vẽ khác
            visualizerCtx.shadowBlur = 0;
            visualizerCtx.shadowColor = 'transparent';
        }
        audioPlayer.addEventListener('timeupdate', updateMusicPlayerUI);
        audioPlayer.addEventListener('loadedmetadata', updateMusicPlayerUI);
        audioPlayer.addEventListener('play', updateMusicPlayerUI);
        audioPlayer.addEventListener('pause', updateMusicPlayerUI);
        audioPlayer.addEventListener('ended', () => {
            const newIndex = (currentSongIndex + 1) % songs.length;
            showMusicPlayer(newIndex);
        });

        function applyScrollingToTitle(titleElement, songName) {
            const scrollContainer = titleElement.querySelector('.music-player-title-scroll-container');
            const titleText = titleElement.querySelector('.music-player-title-text');
            if (!scrollContainer || !titleText) return;

            // Clear any previous duplicate and animation
            let duplicateText = titleElement.querySelector('.music-player-title-text-duplicate');
            if (duplicateText) {
                duplicateText.remove();
            }
            titleElement.classList.remove('scrolling');
            titleElement.style.removeProperty('--scroll-distance');
            titleElement.style.removeProperty('--scroll-duration');
            titleText.textContent = songName; // Ensure original text is set

            // Measure the actual width of the text content
            // Temporarily set overflow to visible to get the true content width
            const originalOverflow = titleElement.style.overflow;
            titleElement.style.overflow = 'visible';
            const textWidth = titleText.offsetWidth;
            titleElement.style.overflow = originalOverflow; // Restore overflow

            const containerWidth = titleElement.offsetWidth; // This should be 230px (250 - 2*10 padding)

            if (textWidth > containerWidth) {
                // Add duplicate text for continuous scrolling
                duplicateText = document.createElement('span');
                duplicateText.className = 'music-player-title-text-duplicate';
                duplicateText.textContent = songName;
                scrollContainer.appendChild(duplicateText);

                // Calculate scroll distance: width of the original text + padding-right
                // The animation scrolls the entire scrollContainer.
                // The scroll-distance should be the width of the *first* titleText span,
                // including its padding-right (20px).
                const scrollDistance = titleText.offsetWidth;
                const scrollSpeedPxPerSec = 30; // Adjust scroll speed (pixels per second)
                const scrollDuration = (scrollDistance / scrollSpeedPxPerSec) * 1000; // in milliseconds

                titleElement.classList.add('scrolling');
                titleElement.style.setProperty('--scroll-distance', `-${scrollDistance}px`);
                titleElement.style.setProperty('--scroll-duration', `${scrollDuration}ms`);
            }
        }
        function restoreDefaultControls() {
            controls.enablePan = true;
            controls.minDistance = 10;
            controls.maxDistance = 1500;
            // Also ensure controls are enabled if not animating
            if (!isCameraAnimating) {
                controls.enabled = true;
            }
        }

        function animateCameraToPlanet(targetPlanet) { // Removed lockView parameter
            // Disable controls during animation
            controls.enabled = false;

            // The locking state should be managed by handlePlanetClick BEFORE calling this.

            // Store current camera and controls target as the starting point for the first phase
            startCameraPosition.copy(camera.position);
            startControlsTarget.copy(controls.target);

            // Calculate target position for controls (planet's world position)
            const planetWorldPosition = new THREE.Vector3();
            targetPlanet.getWorldPosition(planetWorldPosition);
            finalControlsTarget.copy(planetWorldPosition);

            // Calculate target position for camera (offset from planet)
            const offsetDistance = targetPlanet.userData.size * 8 + 10;
            finalCameraPosition.copy(planetWorldPosition).add(new THREE.Vector3(0, offsetDistance / 2, offsetDistance));

            isCameraAnimating = true;
            cameraAnimationPhase = 1; // Start with the "return to home view" phase
            cameraAnimationStartTime = Date.now();
        }
        
        // Hàm mới để hoạt ảnh camera đến chế độ xem toàn cảnh
        const overviewBtn = document.getElementById('overview-btn');
        overviewBtn.addEventListener('click', animateCameraToOverview);

        function animateCameraToOverview() {
            // Nếu một hành tinh hiện đang bị khóa, hãy mở khóa nó và ẩn hình ảnh của nó
            if (lockedPlanet) {
                if (lockedPlanet.userData.imageGroup.visible) {
                    removeImagesFromPlanet(lockedPlanet);
                }
                lockedPlanet.userData.interactionState = 0; // Đặt lại trạng thái của hành tinh đã khóa trước đó
            }
            isViewLocked = false;
            lockedPlanet = null;

            // Lưu vị trí camera và mục tiêu điều khiển hiện tại làm điểm bắt đầu
            startCameraPosition.copy(camera.position);
            startControlsTarget.copy(controls.target);

            // Đặt vị trí cuối cùng cho chế độ xem toàn cảnh
            finalCameraPosition.copy(overviewCameraPosition);
            finalControlsTarget.copy(overviewControlsTarget);

            isCameraAnimating = true;
            cameraAnimationPhase = 3; // Giai đoạn mới cho chế độ xem toàn cảnh
            cameraAnimationStartTime = Date.now();

            controls.enabled = false; // Tắt điều khiển trong quá trình hoạt ảnh

            // Ẩn tên bài hát 2D khi chuyển sang chế độ toàn cảnh
            if (musicPlayerSongTitle2D) {
                musicPlayerSongTitle2D.style.display = 'none';
            }
        }
        // New functions for managing planet images
        function addImagesToPlanet(planet) {
            if (planet.userData.isSun) { // Sun doesn't have images
                return;
            }

            if (planet.userData.imageGroup.children.length > 0) {
                // Images already exist, just make sure they are visible
                planet.userData.imageGroup.visible = true;
                return;
            }

            const availableUrls = allImageUrls.filter(url => !usedImageUrls.has(url));
            const imagesPerPlanet = 7;
            
            if (availableUrls.length < imagesPerPlanet) {
                console.warn("Not enough unique images available to display.");
                return;
            }

            const shuffled = availableUrls.sort(() => 0.5 - Math.random());
            let selectedUrls = shuffled.slice(0, imagesPerPlanet);

            selectedUrls.forEach(url => {
                usedImageUrls.add(url);

                const material = new THREE.MeshBasicMaterial({
                    map: textureCache[url],
                    side: THREE.DoubleSide,
                    transparent: true
                });
                const plane = new THREE.Mesh(new THREE.PlaneGeometry(4, 4), material);
                
                const baseRadius = planet.userData.size + 10;
                const radius = baseRadius + (Math.random() * 5);
                const phi = Math.acos(-1 + (2 * Math.random()));
                const theta = Math.random() * 2 * Math.PI;
                plane.position.setFromSphericalCoords(radius, phi, theta);
                
                plane.rotation.x = Math.random() * Math.PI * 2;
                plane.rotation.y = Math.random() * Math.PI * 2;
                plane.rotation.z = Math.random() * Math.PI * 2;
                
                plane.userData = { 
                    isImagePlane: true, imageUrl: url,
                    selfRotationSpeedX: (Math.random() - 0.5) * 0.005, selfRotationSpeedY: (Math.random() - 0.5) * 0.005, selfRotationSpeedZ: (Math.random() - 0.5) * 0.005,
                    orbitAxis: new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize(), orbitSpeed: (Math.random() + 0.2) * 0.004
                };
                planet.userData.imageGroup.add(plane);
            });
            planet.userData.imageGroup.visible = true; // Ensure the group is visible
        }

        function removeImagesFromPlanet(planet) {
            planet.userData.imageGroup.children.forEach(image => {
                if (image.userData.imageUrl) usedImageUrls.delete(image.userData.imageUrl);
                image.geometry.dispose(); if (image.material.map) image.material.map.dispose(); image.material.dispose();
            });
            planet.userData.imageGroup.clear();
            planet.userData.imageGroup.visible = false;
        }

        // New handler for planet clicks to manage state
        function handlePlanetClick(planet) {
            if (planet.userData.interactionState === undefined) {
                planet.userData.interactionState = 0;
            }

            // Vô hiệu hóa controls ngay lập tức để ngăn chặn xung đột với hoạt ảnh camera
            // và đảm bảo trạng thái được quản lý bởi logic của hàm này.
            controls.enabled = false;

            // If a different planet is currently locked, unlock it and hide its images
            if (lockedPlanet && lockedPlanet !== planet) {
                if (lockedPlanet.userData.imageGroup.visible) {
                    removeImagesFromPlanet(lockedPlanet);
                }
                lockedPlanet.userData.interactionState = 0; // Reset state of previously locked planet
                // No need to call restoreDefaultControls here, as the new planet's animation will override
            }

            // Logic chuyển trạng thái tùy chỉnh theo yêu cầu của người dùng
            let nextState;
            switch (planet.userData.interactionState) {
                case 0: // Trạng thái ban đầu: Ảnh ẩn, bỏ khóa
                    nextState = 1; // Lần 1: Hiện ảnh, khóa, zoom
                    break;
                case 1: // Sau lần 1: Hiện ảnh, khóa, zoom
                    nextState = 2; // Lần 2: Hiện ảnh, bỏ khóa
                    break;
                case 2: // Sau lần 2 hoặc lần 5: Hiện ảnh, bỏ khóa
                    nextState = 3; // Lần 3: Tắt ảnh, bỏ khóa
                    break;
                case 3: // Sau lần 3 hoặc lần 6: Tắt ảnh, bỏ khóa
                    nextState = 4; // Lần 4: Hiện ảnh, khóa lại
                    break;
                case 4: // Sau lần 4: Hiện ảnh, khóa lại
                    nextState = 2; // Lần 5: Hiện ảnh, bỏ khóa (quay lại trạng thái 2)
                    break;
                default: // Trường hợp mặc định, coi như trạng thái ban đầu
                    nextState = 1;
            }
            planet.userData.interactionState = nextState;

            switch (planet.userData.interactionState) {
                case 1: // State 1: Show images, Lock view, Animate camera
                    addImagesToPlanet(planet);
                    isViewLocked = true; // Set lock state here
                    lockedPlanet = planet; // Set locked planet here
                    animateCameraToPlanet(planet);
                    break;
                case 2: // State 2: Unlock view, Images remain
                    isViewLocked = false;
                    lockedPlanet = null;
                    restoreDefaultControls(); // Re-enable controls and reset distances
                    // Đảm bảo ảnh vẫn hiển thị nếu chúng đã được thêm vào từ trạng thái trước
                    if (!planet.userData.imageGroup.visible) {
                        addImagesToPlanet(planet);
                    }
                    break;
                case 3: // State 3: Hide images, Unlock view, Reset (Lần 3: tắt ảnh / Lần 6: tắt ảnh)
                    removeImagesFromPlanet(planet);
                    isViewLocked = false;
                    lockedPlanet = null;
                    restoreDefaultControls(); // Đảm bảo controls được đặt lại hoàn toàn và kích hoạt
                    break;
                case 4: // State 4: Lock view again, Images remain (Lần 4: theo dõi)
                    addImagesToPlanet(planet); // Đảm bảo ảnh hiển thị
                    isViewLocked = true;
                    lockedPlanet = planet; // Re-lock to this planet
                    // Không cần hoạt ảnh camera, chỉ cần đảm bảo controls theo dõi hành tinh
                    controls.minDistance = 10; // Giữ khoảng cách gần với hành tinh
                    controls.maxDistance = 100; // Cho phép zoom ra một chút
                    controls.enabled = true; // Kích hoạt controls để theo dõi
                    break;
            }
        }

        document.getElementById('close-btn').addEventListener('click', closeFullscreen);
        document.getElementById('close-btn').addEventListener('touchend', closeFullscreen);

        // If you intend to have an unlock view button, you would add it to your HTML and uncomment/implement its logic here.
        // Example:
        // const unlockViewBtn = document.getElementById('unlock-view-btn');
        // if (unlockViewBtn) unlockViewBtn.addEventListener('click', () => { isViewLocked = false; lockedPlanet = null; restoreDefaultControls(); unlockViewBtn.style.display = 'none'; });
        const downloadBtn = document.getElementById('download-btn');
        function closeFullscreen(event) {
            // Ẩn tên bài hát 2D khi đóng fullscreen overlay
            // (Giả định rằng việc đóng fullscreen overlay cũng có thể được coi là "quay góc view hiện lại")
            if (musicPlayerSongTitle2D) {
                musicPlayerSongTitle2D.style.display = 'none';
            }

            event.preventDefault(); // Prevent potential double-triggering on touch devices
            document.getElementById('fullscreen-overlay').style.display = 'none';
            if (!isViewLocked) { // Only re-enable controls if view was NOT locked
                controls.enabled = true;
            }
            document.getElementById('select-planet-btn').style.display = 'block'; // Hiển thị lại nút "Chọn hành tinh"
            downloadBtn.style.display = 'none'; // Ẩn nút tải xuống khi đóng overlay
        }

        // --- Core Functions ---
        function showMessageOnSun() {
            if (sunMessageMesh) return;

            // Get current time and create the dynamic message
            const now = new Date();
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');
            const currentTime = `${hours}:${minutes}`;
            let messageSuffix = '';

            // Logic để xác định câu chúc dựa trên giờ hiện tại
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes(); // Lấy phút để xử lý khung giờ 06:30

            if (currentHour >= 22 || currentHour < 5) { // Từ 22:00 đến 04:59 hôm sau
                messageSuffix = "ngủ đi bé ưi";
            } else if (currentHour === 5 || (currentHour === 6 && currentMinute < 30)) { // Từ 05:00 đến 06:29
                messageSuffix = "ăn sáng, xong đi học vui vẻ nhó";
            } else if (currentHour >= 11 && currentHour < 12) { // Từ 11:00 đến 11:59
                messageSuffix = "ăn cơm rùi nghỉ ngơi bé";
            } else if (currentHour >= 12 && currentHour < 13) { // Từ 12:00 đến 12:59
                messageSuffix = "bé ưi ngủ trưa đi";
            } else if (currentHour >= 13 && currentHour < 22) { // Từ 13:00 đến 21:59
                messageSuffix = "em có thấy đẹp ko";
            } else {
                // Mặc định cho các khung giờ còn lại (ví dụ: 06:30 - 10:59)
                messageSuffix = "chúc bạn một ngày tốt lành!";
            }

            const text = `Giờ là ${currentTime}, ${messageSuffix}`;

            // Create canvas texture for the text
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const fontSize = 90;
            
            context.font = `bold ${fontSize}px Arial, sans-serif`;
            const textMetrics = context.measureText(text);
            canvas.width = textMetrics.width + 40;
            canvas.height = fontSize * 1.5;

            // Redraw text with final settings
            context.font = `bold ${fontSize}px Arial, sans-serif`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillStyle = 'rgba(255, 255, 220, 1)';
            context.shadowColor = 'rgba(255, 255, 0, 0.7)';
            context.shadowBlur = 25;
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                opacity: 0
            });

            const planeHeight = 150;
            const planeWidth = planeHeight * (canvas.width / canvas.height);
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);

            sunMessageMesh = new THREE.Mesh(geometry, material);

            // Position the message directly in front of the camera, but much further away
            const distance = 1500; 
            const positionVector = new THREE.Vector3();
            camera.getWorldDirection(positionVector);
            positionVector.multiplyScalar(distance);
            positionVector.add(camera.position);
            sunMessageMesh.position.copy(positionVector);
            sunMessageMesh.position.y += planeHeight / 2 + 300; // Đẩy dòng chữ lên cao hơn nữa để tránh bị che khuất
            sunMessageMesh.quaternion.copy(camera.quaternion);

            scene.add(sunMessageMesh);

            sunMessageAnimation = {
                active: true,
                startTime: Date.now(),
                duration: 10000, // Message lasts for 10 seconds
                fadeIn: 1000,
                fadeOut: 1000
            };
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            if (sunMessageAnimation.active && sunMessageMesh) {
                const elapsedTime = Date.now() - sunMessageAnimation.startTime;
                if (elapsedTime >= sunMessageAnimation.duration) {
                    scene.remove(sunMessageMesh);
                    sunMessageMesh.geometry.dispose();
                    sunMessageMesh.material.map.dispose();
                    sunMessageMesh.material.dispose();
                    sunMessageMesh = null;
                    sunMessageAnimation.active = false;
                } else {
                    let opacity = 0;
                    if (elapsedTime < sunMessageAnimation.fadeIn) {
                        opacity = elapsedTime / sunMessageAnimation.fadeIn;
                    } else if (elapsedTime < sunMessageAnimation.duration - sunMessageAnimation.fadeOut) {
                        opacity = 1;
                    } else {
                        opacity = (sunMessageAnimation.duration - elapsedTime) / sunMessageAnimation.fadeOut;
                    }
                    sunMessageMesh.material.opacity = Math.max(0, opacity);
                }
            }

            // Two-stage Camera animation update
            if (isCameraAnimating) {
                const elapsedTime = Date.now() - cameraAnimationStartTime;
                
                if (cameraAnimationPhase === 1) { // Phase 1: Return to Home View
                    const progress = Math.min(elapsedTime / returnToHomeDuration, 1);
                    const easedProgress = easeInOutSine(progress); // Apply easing function

                    // Lerp camera position from current to home position
                    camera.position.lerpVectors(startCameraPosition, homeCameraPosition, easedProgress);
                    // Lerp controls target from current to home target (0,0,0)
                    controls.target.lerpVectors(startControlsTarget, homeControlsTarget, easedProgress);
                    
                    if (progress === 1) {
                        // Transition to the next phase
                        cameraAnimationPhase = 2;
                        cameraAnimationStartTime = Date.now(); // Reset timer for the next phase
                        // Update start positions for the next phase
                        // Đảm bảo vị trí cuối cùng chính xác trước khi bắt đầu giai đoạn tiếp theo
                        startCameraPosition.copy(homeCameraPosition); 
                        startControlsTarget.copy(homeControlsTarget);
                    }
                } else if (cameraAnimationPhase === 2) { // Phase 2: Move to Target Planet
                    const progress = Math.min(elapsedTime / moveToTargetDuration, 1);
                    const easedProgress = easeInOutSine(progress); // Apply easing function

                    // Lerp camera position from current (after zoom out) to final
                    camera.position.lerpVectors(startCameraPosition, finalCameraPosition, easedProgress);
                    // Lerp controls target from current (original target) to final (planet's world position)
                    controls.target.lerpVectors(startControlsTarget, finalControlsTarget, easedProgress);

                    if (progress === 1) {
                        isCameraAnimating = false;
                        cameraAnimationPhase = 0; // Animation finished
                        controls.enabled = true; // Re-enable controls after animation
                        // Ensure camera and controls target are exactly at their final positions
                        camera.position.copy(finalCameraPosition);
                        controls.target.copy(finalControlsTarget);
                    }
                } else if (cameraAnimationPhase === 3) { // Giai đoạn 3: Di chuyển đến chế độ xem toàn cảnh
                    const progress = Math.min(elapsedTime / moveToTargetDuration, 1); // Tái sử dụng moveToTargetDuration cho hoạt ảnh toàn cảnh
                    const easedProgress = easeInOutSine(progress);

                    camera.position.lerpVectors(startCameraPosition, finalCameraPosition, easedProgress);
                    controls.target.lerpVectors(startControlsTarget, finalControlsTarget, easedProgress);

                    if (progress === 1) {
                        isCameraAnimating = false;
                        cameraAnimationPhase = 0; // Hoạt ảnh kết thúc
                        controls.enabled = true; // Kích hoạt lại điều khiển sau hoạt ảnh
                        // Đảm bảo camera và mục tiêu điều khiển ở đúng vị trí cuối cùng
                        camera.position.copy(finalCameraPosition);
                        controls.target.copy(finalControlsTarget);
                        restoreDefaultControls(); // Đảm bảo min/max distance được đặt lại
                    }

                }
                camera.lookAt(controls.target); // Ensure camera always looks at the interpolated target
            }
            if (stars) {
                stars.rotation.y += 0.0001;
            }
            sun.rotation.y += 0.001;

            planets.forEach(planet => {
                const data = planet.userData;
                data.angle += data.speed;
                planet.position.x = Math.cos(data.angle) * data.distance;
                planet.position.z = Math.sin(data.angle) * data.distance;
                planet.rotation.y += 0.001;

                // Only update image movement if the image group is visible
                if (!planet.userData.imageGroup.visible) {
                    return; // Skip if images are hidden (correct way to exit forEach callback)
                }
                // Revert to individual, chaotic rotation for each image
                planet.userData.imageGroup.children.forEach(image => {
                    image.position.applyAxisAngle(image.userData.orbitAxis, image.userData.orbitSpeed);
                    image.rotation.x += image.userData.selfRotationSpeedX;
                    image.rotation.y += image.userData.selfRotationSpeedY;
                    image.rotation.z += image.userData.selfRotationSpeedZ;
                });
            });

            // --- Camera Lock Logic ---
            if (isViewLocked && lockedPlanet) {
                // Lấy vị trí thế giới của hành tinh đang bị khóa
                const targetWorldPosition = new THREE.Vector3();
                lockedPlanet.getWorldPosition(targetWorldPosition);

                // Cập nhật mục tiêu của controls để camera luôn hướng vào hành tinh
                controls.target.copy(targetWorldPosition);

                // Nếu không có animation camera đang diễn ra, đảm bảo camera duy trì vị trí tương đối
                // OrbitControls.update() sẽ tự xử lý việc di chuyển camera tương đối với mục tiêu mới
                // Không cần đặt camera.position một cách rõ ràng ở đây.
            }

            renderer.setClearColor(0x000000, 0); // Xóa nền của scene chính để scene nền có thể nhìn thấy

            controls.update();
            drawVisualizer(); // Call the visualizer drawing function
            musicPlayerRenderer.render(musicPlayerScene, camera); // Render scene nền (khung nhạc)
            renderer.render(scene, camera); // Render scene chính (hệ mặt trời)
            labelRenderer.render(scene, camera); // Render các nhãn của scene chính
        }

        // --- Event Listeners & Initial Calls ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }, false);
        
        labelRenderer.domElement.addEventListener('click', onInteraction, true); // Use capturing phase for click
        labelRenderer.domElement.addEventListener('touchend', onInteraction, true); // Use capturing phase for touchend

        // Tự động mở khóa chế độ xem nếu người dùng tương tác thủ công với controls
        controls.addEventListener('start', () => {
            if (isViewLocked && !isCameraAnimating) {
                const previouslyLockedPlanet = lockedPlanet; // Store before nulling
                // If user manually interacts, unlock view
                lockedPlanet = null;
                isViewLocked = false;
                restoreDefaultControls(); // Khôi phục cài đặt điều khiển mặc định
                console.log('Chế độ xem đã được mở khóa do người dùng tương tác.');
                // Nếu hành tinh đang ở trạng thái khóa (Trạng thái 1 hoặc Trạng thái 4),
                // chuyển nó sang trạng thái "hiện ảnh, bỏ khóa" (Trạng thái 2).
                if (previouslyLockedPlanet && (previouslyLockedPlanet.userData.interactionState === 1 || previouslyLockedPlanet.userData.interactionState === 4)) {
                    previouslyLockedPlanet.userData.interactionState = 2;
                }
            }
            // Hiển thị tên bài hát 2D khi bắt đầu tương tác với controls
            if (musicPlayerSongTitle2D && currentSongIndex !== -1 && songs[currentSongIndex]) {
                musicPlayerSongTitle2D.textContent = songs[currentSongIndex].name;
                musicPlayerSongTitle2D.style.display = 'block';
            }
        });

        
        // Note: The animate() call is now in loadingManager.onLoad
    </script>

</body>
</html>     sun.rotation.y += 0.001;

            planets.forEach(planet => {
                const data = planet.userData;
                data.angle += data.speed;
                planet.position.x = Math.cos(data.angle) * data.distance;
                planet.position.z = Math.sin(data.angle) * data.distance;
                planet.rotation.y += 0.001;

                // Only update image movement if the image group is visible
                if (!planet.userData.imageGroup.visible) {
                    return; // Skip if images are hidden (correct way to exit forEach callback)
                }
                // Revert to individual, chaotic rotation for each image
                planet.userData.imageGroup.children.forEach(image => {
                    image.position.applyAxisAngle(image.userData.orbitAxis, image.userData.orbitSpeed);
                    image.rotation.x += image.userData.selfRotationSpeedX;
                    image.rotation.y += image.userData.selfRotationSpeedY;
                    image.rotation.z += image.userData.selfRotationSpeedZ;
                });
            });

            // --- Camera Lock Logic ---
            if (isViewLocked && lockedPlanet) {
                // Lấy vị trí thế giới của hành tinh đang bị khóa
                const targetWorldPosition = new THREE.Vector3();
                lockedPlanet.getWorldPosition(targetWorldPosition);

                // Cập nhật mục tiêu của controls để camera luôn hướng vào hành tinh
                controls.target.copy(targetWorldPosition);

                // Nếu không có animation camera đang diễn ra, đảm bảo camera duy trì vị trí tương đối
                // OrbitControls.update() sẽ tự xử lý việc di chuyển camera tương đối với mục tiêu mới
                // Không cần đặt camera.position một cách rõ ràng ở đây.
            }

            renderer.setClearColor(0x000000, 0); // Xóa nền của scene chính để scene nền có thể nhìn thấy

            controls.update();
            drawVisualizer(); // Call the visualizer drawing function
            musicPlayerRenderer.render(musicPlayerScene, camera); // Render scene nền (khung nhạc)
            renderer.render(scene, camera); // Render scene chính (hệ mặt trời)
            labelRenderer.render(scene, camera); // Render các nhãn của scene chính
        }

        // --- Event Listeners & Initial Calls ---
        // Gộp listener resize vào đây để tránh trùng lặp
        window.addEventListener('resize', () => { 
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            // Recalculate overview position on resize
            overviewCameraPosition = calculateOverviewCameraPosition();
            // Nếu đang ở chế độ toàn cảnh, kích hoạt lại hoạt ảnh để cập nhật vị trí
            if (cameraAnimationPhase === 3) {
                animateCameraToOverview();
            }
        }, false);
        
        labelRenderer.domElement.addEventListener('click', onInteraction, true); // Use capturing phase for click