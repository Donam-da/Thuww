<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Solar System Image Gallery</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; }
        canvas { display: block; }
        #loader-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #000; display: flex; justify-content: center;
            align-items: center; z-index: 3000; transition: opacity 0.5s ease;
        }
        .loader-text { font-size: 28px; color: white; font-family: Arial, sans-serif; }
        #fullscreen-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.85); display: none; justify-content: center;
            align-items: center; z-index: 1000;
        }
        #fullscreen-image { max-width: 90%; max-height: 80%; }
        #close-btn {
            position: absolute; top: 20px; right: 30px; color: white;
            font-size: 30px; cursor: pointer; text-decoration: none; font-family: Arial, sans-serif;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div id="loader-overlay">
        <span class="loader-text">Initializing Solar System...</span>
    </div>
    <div id="fullscreen-overlay">
        <span id="close-btn">&times;</span>
        <img id="fullscreen-image" src="" alt="fullscreen-image" />
    </div>

    <script>
        // --- Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        // --- Controls ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 10;
        controls.maxDistance = 1000;

        // --- Image & Planet Data ---
        const totalImages = 62;
        const allImageUrls = Array.from({length: totalImages}, (_, i) => `images/${i + 1}.png`);
        const usedImageUrls = new Set();
        const planets = [];
        const planetData = [
            { name: 'Mercury', distance: 20, size: 1, color: 0xaaaaaa, speed: 0.005 },
            { name: 'Venus', distance: 35, size: 1.5, color: 0xe8ab6f, speed: 0.003 },
            { name: 'Earth', distance: 50, size: 1.6, color: 0x6f94e8, speed: 0.002 },
            { name: 'Mars', distance: 70, size: 1.2, color: 0xe86f6f, speed: 0.0015 },
            { name: 'Jupiter', distance: 100, size: 4, color: 0xd8caa0, speed: 0.0008 },
            { name: 'Saturn', distance: 140, size: 3.5, color: 0xead5a8, speed: 0.0006 },
            { name: 'Uranus', distance: 180, size: 2.5, color: 0xa8e0ea, speed: 0.0004 },
            { name: 'Neptune', distance: 220, size: 2.4, color: 0x5c84f5, speed: 0.0002 }
        ];

        // --- Sun ---
        const sunGeometry = new THREE.SphereGeometry(10, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffdd00, map: createSunTexture() });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);
        const sunLight = new THREE.PointLight(0xffffff, 1.5, 2000);
        sun.add(sunLight);

        // --- Create Planets and Orbits ---
        planetData.forEach(data => {
            const planetGeometry = new THREE.SphereGeometry(data.size, 32, 32);
            const planetMaterial = new THREE.MeshStandardMaterial({ color: data.color });
            const planet = new THREE.Mesh(planetGeometry, planetMaterial);
            
            const imageGroup = new THREE.Group();
            planet.add(imageGroup);

            planet.userData = { 
                ...data, 
                isPlanet: true, 
                angle: Math.random() * Math.PI * 2,
                imageGroup: imageGroup
            };
            
            const orbitGeometry = new THREE.RingGeometry(data.distance - 0.1, data.distance + 0.1, 128);
            const orbitMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, opacity: 0.2, transparent: true });
            const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
            orbit.rotation.x = -Math.PI / 2;
            scene.add(orbit);
            
            if (data.name === 'Saturn') {
                const ringGeometry = new THREE.RingGeometry(data.size * 1.5, data.size * 2.5, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({ color: 0xead5a8, side: THREE.DoubleSide, opacity: 0.7, transparent: true });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI * 0.4;
                planet.add(ring);
            }

            scene.add(planet);
            planets.push(planet);
        });

        // --- Camera Position ---
        camera.position.set(0, 100, 250);
        camera.lookAt(scene.position);

        // --- Raycasting for Clicks ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            // The 'true' argument makes the raycaster check all descendants of the planets
            const intersects = raycaster.intersectObjects(planets, true);

            if (intersects.length > 0) {
                let clickedObject = intersects[0].object;
                
                // If it's an image plane (identified by having an orbitAxis), open fullscreen
                if (clickedObject.userData.orbitAxis) {
                    document.getElementById('fullscreen-image').src = clickedObject.userData.imageUrl;
                    document.getElementById('fullscreen-overlay').style.display = 'flex';
                    controls.enabled = false;
                } 
                // Otherwise, it must be a planet (or saturn's ring). Find the parent planet.
                else {
                    let parentPlanet = clickedObject;
                    while (parentPlanet.parent && !parentPlanet.userData.isPlanet) {
                        parentPlanet = parentPlanet.parent;
                    }
                    if (parentPlanet.userData.isPlanet) {
                        showImagesForPlanet(parentPlanet);
                    }
                }
            }
        }
        
        document.getElementById('close-btn').addEventListener('click', () => {
            document.getElementById('fullscreen-overlay').style.display = 'none';
            controls.enabled = true;
        });

        // --- Core Functions ---
        function showImagesForPlanet(planet) {
            // If the planet already has an image cloud, do nothing.
            if (planet.userData.imageGroup.children.length > 0) {
                return;
            }

            const availableUrls = allImageUrls.filter(url => !usedImageUrls.has(url));
            const imagesPerPlanet = 7;
            
            // If there aren't enough free images, do nothing.
            if (availableUrls.length < imagesPerPlanet) {
                console.log("Not enough unique images available to create a new cloud.");
                return;
            }

            const shuffled = availableUrls.sort(() => 0.5 - Math.random());
            let selectedUrls = shuffled.slice(0, imagesPerPlanet);

            const textureLoader = new THREE.TextureLoader();
            selectedUrls.forEach(url => {
                usedImageUrls.add(url); // Mark image as used

                const material = new THREE.MeshStandardMaterial({
                    map: textureLoader.load(url),
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.9
                });
                const plane = new THREE.Mesh(new THREE.PlaneGeometry(4, 4), material);
                
                const radius = planet.userData.size + 7 + (Math.random() * 5);
                const phi = Math.acos(-1 + (2 * Math.random()));
                const theta = Math.random() * 2 * Math.PI;

                plane.position.setFromSphericalCoords(radius, phi, theta);
                
                plane.userData = { 
                    imageUrl: url,
                    orbitAxis: new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize(),
                    orbitSpeed: (Math.random() + 0.2) * 0.005
                };
                planet.userData.imageGroup.add(plane);
            });
        }

        function createSunTexture() {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
            gradient.addColorStop(0, 'rgba(255, 255, 180, 1)');
            gradient.addColorStop(0.4, 'rgba(255, 220, 0, 1)');
            gradient.addColorStop(1, 'rgba(255, 165, 0, 0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, size, size);
            return new THREE.CanvasTexture(canvas);
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            sun.rotation.y += 0.001;

            planets.forEach(planet => {
                // Animate planet's orbit and rotation
                const data = planet.userData;
                data.angle += data.speed;
                planet.position.x = Math.cos(data.angle) * data.distance;
                planet.position.z = Math.sin(data.angle) * data.distance;
                planet.rotation.y += 0.01;

                // Animate the image cloud if it exists for this planet
                planet.userData.imageGroup.children.forEach(image => {
                    image.position.applyAxisAngle(image.userData.orbitAxis, image.userData.orbitSpeed);
                    image.lookAt(new THREE.Vector3(0, 0, 0));
                });
            });

            controls.update();
            renderer.render(scene, camera);
        }

        // --- Event Listeners & Initial Calls ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }, false);
        window.addEventListener('click', onMouseClick, false);

        // Hide loader and start
        const loaderOverlay = document.getElementById('loader-overlay');
        loaderOverlay.style.opacity = '0';
        setTimeout(() => { loaderOverlay.style.display = 'none'; }, 500);

        animate();
    </script>
</body>
</html>