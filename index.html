<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Solar System Image Gallery</title>
    <style>
        /*
         * To use the "VN Time" font, you need to provide the font file (e.g., VNtime.ttf, VNtime.woff).
         * Place the font file in a 'fonts' directory (or adjust the path below).
         * If the font file is not found, the fallback font (Arial, sans-serif) will be used.
         */
        @font-face {
            font-family: 'VN Time';
            src: url('fonts/VNtime.ttf') format('truetype'); /* Adjust path and format as needed */
            font-weight: normal; /* Set to specific weights if your font file supports them (e.g., 100, 200, 300) */
            font-style: normal;
        }
        body { margin: 0; background-color: #000; overflow: hidden; }
        canvas { display: block; }
        #main-scene {
            position: relative; z-index: 2; /* Giữ thuộc tính này */
        }
        #main-scene { display: none; }
        #loader-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #000; display: flex; justify-content: center;
            align-items: center; z-index: 3000; transition: opacity 0.5s ease;
        }
        #image-loader-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 3001; /* Above main loader */
            transition: opacity 0.5s ease;
        }
        .loader-container { text-align: center; }
        .progress-circle {
            width: 120px; height: 120px; border-radius: 50%;
            background: conic-gradient(#3498db 0%, #1a1a1a 0%);
            display: flex; justify-content: center; align-items: center;
            margin: 0 auto 20px auto;
        }
        .progress-circle-inner {
            width: 100px; height: 100px; background-color: #000;
            border-radius: 50%; display: flex; justify-content: center;
            align-items: center;
        }
        .loader-text {
            font-size: 24px; color: white;
            font-family: 'VN Time', Arial, sans-serif; /* Apply VN Time font */
            font-weight: 100; /* Thinner font weight */
        }
        #fullscreen-overlay {
            font-family: 'VN Time', Arial, sans-serif; /* Apply VN Time font */
            font-weight: 100; /* Thinner font weight */
        }
        #close-btn {
            position: absolute; top: 20px; right: 30px; color: white;
            font-size: 30px; cursor: pointer; text-decoration: none;
            font-family: 'VN Time', Arial, sans-serif; /* Apply VN Time font */
            font-weight: 100; /* Thinner font weight */
        }
        #download-btn {
            position: absolute;
            bottom: 20px; /* Cách đáy 20px */
            right: 30px; /* Cách phải 30px */
            color: white;
            font-size: 16px;
            cursor: pointer;
            text-decoration: none;
            font-family: 'VN Time', Arial, sans-serif; /* Apply VN Time font */
            font-weight: 100; /* Thinner font weight */
            padding: 8px 15px; border: 1px solid white; border-radius: 5px;
            display: none; /* Ẩn theo mặc định */
        }
        /* Font Awesome for icons */
        .fas {
            font-family: "Font Awesome 5 Free"; /* Keep Font Awesome font */
            font-weight: 900; /* Ensure Font Awesome icons display correctly */
        }
        #fullscreen-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.85); display: none; justify-content: center;
            align-items: center; z-index: 1000;
        }
        #fullscreen-image { max-width: 90%; max-height: 80%; }
        #close-btn {
            position: absolute; top: 20px; right: 30px; color: white;
            font-size: 30px; cursor: pointer; text-decoration: none;
        }
        .planet-label {
            color: #FFF;
            font-family: 'VN Time', Arial, sans-serif; /* Apply VN Time font */
            font-weight: 100; /* Thinner font weight */
            padding: 2px 5px;
            background: transparent;
            font-size: 7px;
            white-space: nowrap;
            cursor: pointer;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.9);
        }
        .planet-label.hidden {
            display: none;
        }
        #select-planet-btn, #toggle-labels-btn, #select-song-btn, #toggle-images-btn {
            /* Vị trí được quản lý bởi #main-ui-controls */
            z-index: 1001;
            padding: 10px 15px;
            background-color: transparent; /* Nền trong suốt */
            color: white; /* Giữ màu chữ */
            border: none; /* Bỏ viền */
            border-radius: 5px;
            cursor: pointer;
            font-family: 'VN Time', Arial, sans-serif; /* Apply VN Time font */
            font-weight: 400; /* Thinner font weight */
            font-size: 16px;
        }
        /* Giảm font size cho nút "Ẩn tên" và "Tắt ảnh" */
        #toggle-labels-btn, #toggle-images-btn {
            font-size: 11px; /* Giảm 5px so với 16px */
            /* Đã loại bỏ định vị cố định */
            display: block; /* Đảm bảo nút luôn hiển thị */
        }
        #overview-btn { /* Kiểu dáng cho nút mới */
            z-index: 1001; /* z-index is still useful within the flex container */
            padding: 10px 15px;
            background-color: transparent;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;            
            font-family: 'VN Time', Arial, sans-serif; /* Apply VN Time font */
            font-weight: 400; /* Thinner font weight */
            display: block; /* Đảm bảo nút luôn hiển thị */
            font-size: 16px;
        }
        #more-options-btn { /* Nút 3 chấm mới */
            z-index: 1001;
            padding: 10px 15px;
            background-color: transparent;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px; /* Giữ kích thước icon nhất quán */
            display: block;
        }
        #bottom-left-controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 1001;
            display: flex;
            align-items: flex-end; /* Align to bottom */
            gap: 10px;
        }
        #bottom-right-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1001;
            display: flex;
            flex-direction: row-reverse; /* To keep overview button on the far right */
            align-items: flex-end;
            gap: 10px;
        }

        /* --- Settings Menu --- */
        #settings-overlay {
            position: fixed;
            bottom: 70px; /* Position above the 3-bar button */
            left: 20px;
            width: fit-content;
            min-width: 250px;
            background-color: transparent;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,255,255,0.5);
            z-index: 1002;
            display: none; /* Hidden by default */
            font-family: 'VN Time', Arial, sans-serif;
            font-weight: 100;
        }

        #close-settings-menu-btn {
            position: absolute;
            top: 5px;
            right: 10px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            z-index: 1003;
        }

        .settings-list-item {
            color: white;
            padding: 10px;
            margin-bottom: 10px;
            background-color: transparent;
            border-radius: 4px;
        }

        .settings-list-item label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .settings-list-item input[type="range"] {
            width: 100%;
            cursor: pointer;
            display: none; /* Ẩn thanh trượt theo mặc định */
            margin-top: 8px; /* Thêm khoảng cách với label */
            -webkit-appearance: none; /* Bỏ giao diện mặc định */
            appearance: none;
            background: transparent; /* Nền trong suốt */
            height: 20px; /* Chiều cao để chứa thumb và track */
        }

        /* Khi di chuột (hoặc chạm trên mobile) vào một mục, hiển thị thanh trượt của nó */
        .settings-list-item:hover input[type="range"] {
            display: block;
        }

        /* --- Tùy chỉnh màu sắc thanh trượt --- */
        /* Track (thanh chạy) cho Chrome, Safari, Edge */
        .settings-list-item input[type="range"]::-webkit-slider-runnable-track {
            height: 4px;
            background: rgba(0, 255, 255, 0.15);
            border: 1px solid rgba(0, 255, 255, 0.25);
            border-radius: 3px;
        }

        /* Thumb (nút kéo) cho Chrome, Safari, Edge */
        .settings-list-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            background: transparent;
            border-radius: 50%;
            border: 1px solid rgba(0, 255, 255, 0.5);
            margin-top: -7px; /* Căn giữa thumb trên track */
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.4);
        }

        /* Track cho Firefox */
        .settings-list-item input[type="range"]::-moz-range-track {
            height: 4px;
            background: rgba(0, 255, 255, 0.15);
            border: 1px solid rgba(0, 255, 255, 0.25);
            border-radius: 3px;
        }

        /* Thumb cho Firefox */
        .settings-list-item input[type="range"]::-moz-range-thumb {
            height: 16px;
            width: 16px;
            background: transparent;
            border-radius: 50%;
            border: 1px solid rgba(0, 255, 255, 0.5);
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.4);
        }
        /* Desktop styles for main-ui-controls */
        #planet-list-overlay {
            position: fixed;
            top: 110px; /* Định vị dưới nút "Chọn hành tinh" (top 20px + padding 10px + border 1px + khoảng cách) */
            left: 20px; /* Căn chỉnh với lề trái của nút */
            width: fit-content; /* Chiều rộng vừa với nội dung */
            min-width: 180px; /* Đảm bảo chiều rộng tối thiểu, có thể điều chỉnh */
            /* max-height và overflow-y bị loại bỏ để hiển thị tất cả và bỏ thanh cuộn */
            background-color: transparent; /* Nền của dropmenu */
            padding: 15px; /* Giảm khoảng đệm bên trong dropmenu */
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,255,255,0.5); /* Hiệu ứng đổ bóng cho dropmenu */
            z-index: 1002;
            display: none; /* Hidden by default */            
            font-family: 'VN Time', Arial, sans-serif; /* Apply VN Time font */
            font-weight: 100; /* Thinner font weight */
        }
        #close-dropmenu-btn {
            position: absolute;
            top: 5px; /* Khoảng cách từ trên xuống */
            right: 10px; /* Khoảng cách từ phải sang */
            color: white;
            font-size: 20px; /* Kích thước chữ X */
            cursor: pointer;
            z-index: 1003; /* Đảm bảo nó nằm trên các phần tử khác trong overlay */
        }
        .planet-list-item {
            color: white;
            padding: 10px;
            margin-bottom: 5px;
            background-color: transparent; /* Semi-transparent background */
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .planet-list-item:hover {
            background-color: rgba(255, 255, 255, 0.1); /* Darker on hover */
        }
        /* Làm đậm hành tinh đang được chọn trong danh sách */
        .planet-list-item.current-planet {
            color: rgba(0, 255, 255, 0.5); /* Cyan color */
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.5); /* Glowing effect */
        }
        /* --- Volume Control --- */
        #volume-control-container {
            position: relative; /* For slider positioning */
        }

        #volume-btn {
            /* Match other icon buttons */
            padding: 10px 15px;
            background-color: transparent;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        #volume-slider-container {
            position: absolute;
            left: calc(100% + 5px); /* Position to the right of the button */
            top: 50%;
            transform: translateY(-50%);
            background-color: transparent;
            padding: 10px 5px; /* Adjusted for horizontal layout */
            border-radius: 8px;
            /* box-shadow: 0 0 15px rgba(0,255,255,0.5); */ /* Đã xóa hiệu ứng đổ bóng để làm cho khung chứa trong suốt */
            z-index: 1002;
        }

        /* Horizontal Slider Styles */
        #volume-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 120px;
            height: 20px; /* Container height for track/thumb */
            background: transparent;
            cursor: pointer;
        }

        /* Track */
        #volume-slider::-webkit-slider-runnable-track {
            height: 4px;
            background: linear-gradient(to right, 
                rgba(0, 255, 255, 0.75) var(--volume-progress, 100%), 
                transparent var(--volume-progress, 100%) /* Làm cho nền của phần chưa điền trong suốt */
            );
            /* border: 1px solid rgba(0, 255, 255, 0.4); */ /* Đã xóa viền để trong suốt hoàn toàn */
            border-radius: 3px;
        }
        #volume-slider::-moz-range-track {
            height: 4px;
            background: linear-gradient(to right, 
                rgba(0, 255, 255, 0.75) var(--volume-progress, 100%), 
                transparent var(--volume-progress, 100%) /* Làm cho nền của phần chưa điền trong suốt */
            );
            /* border: 1px solid rgba(0, 255, 255, 0.4); */ /* Đã xóa viền để trong suốt hoàn toàn */
            border-radius: 3px;
        }

        /* Thumb */
        #volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            margin-top: -7px; /* Center on track */
            width: 16px;
            height: 16px;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.4) 0%, transparent 60%); /* Thêm hiệu ứng tâm phát sáng */
            border-radius: 50%;
            border: 2px solid rgba(0, 255, 255, 0.75);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
        }
        #volume-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.4) 0%, transparent 60%); /* Thêm hiệu ứng tâm phát sáng */
            border-radius: 50%;
            border: 2px solid rgba(0, 255, 255, 0.75);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
        }

        /* --- Zoom Control --- */
        #zoom-control-container {
            position: relative; /* For slider positioning */
        }

        #zoom-btn {
            /* Match other icon buttons */
            padding: 10px 15px;
            background-color: transparent;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        #zoom-slider-container {
            position: absolute;
            right: calc(100% + 5px); /* Position to the left of the button */
            top: 50%;
            transform: translateY(-50%);
            background-color: transparent;
            padding: 10px 5px;
            border-radius: 8px;
            z-index: 1002;
        }

        #zoom-level-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 120px;
            height: 20px;
            background: transparent;
            cursor: pointer;
        }

        #zoom-level-slider::-webkit-slider-runnable-track {
            height: 4px;
            background: linear-gradient(to left, 
                rgba(0, 255, 255, 0.75) var(--zoom-progress, 0%), 
                transparent var(--zoom-progress, 0%)
            );
            border-radius: 3px;
        }
        #zoom-level-slider::-moz-range-track {
            height: 4px;
            background: linear-gradient(to left, 
                rgba(0, 255, 255, 0.75) var(--zoom-progress, 0%), 
                transparent var(--zoom-progress, 0%)
            );
            border-radius: 3px;
        }

        #zoom-level-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            margin-top: -7px; /* Center on track */
            width: 16px;
            height: 16px;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.4) 0%, transparent 60%);
            border-radius: 50%;
            border: 2px solid rgba(0, 255, 255, 0.75);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
        }
        #zoom-level-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.4) 0%, transparent 60%);
            border-radius: 50%;
            border: 2px solid rgba(0, 255, 255, 0.75);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
        }

        /* Hide Scrollbar */
        #song-list-overlay, 
        #planet-list-overlay,
        #settings-overlay,
        #song-selection-list {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        #song-list-overlay::-webkit-scrollbar,
        #planet-list-overlay::-webkit-scrollbar,
        #settings-overlay::-webkit-scrollbar,
        #song-selection-list::-webkit-scrollbar
        {
            display: none; /* Chrome, Safari, Opera */
        }

        /* --- Search Input for Song List --- */
        #song-search-input {
            width: 100%;
            padding: 8px 10px;
            margin-bottom: 10px;
            background-color: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 255, 255, 0.25);
            border-radius: 4px;
            color: white;
            font-family: 'VN Time', Arial, sans-serif;
            font-weight: 100;
            font-size: 14px;
            box-sizing: border-box; /* Ensure padding doesn't affect width */
        }
        #song-search-input:focus {
            outline: none;
            border-color: rgba(0, 255, 255, 0.75);
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
        }
        #song-search-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        /* --- Music Player Styles --- */
        /* Style for #select-song-btn is now consolidated */
        #song-list-overlay {
            position: fixed;
            top: 110px;
            right: 20px; /* Căn chỉnh với nút */
            width: 250px; /* Đặt chiều rộng cố định để không thay đổi kích thước khi tìm kiếm */
            background-color: transparent;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,255,255,0.5);
            z-index: 1002;
            display: none; /* Hidden by default, will be set to 'flex' by JS */
            flex-direction: column; /* Stack search bar and list vertically */
            height: 320px; /* Đặt chiều cao cố định để không thay đổi kích thước */
            font-family: 'VN Time', Arial, sans-serif; /* Apply VN Time font */
            font-weight: 100; /* Thinner font weight */
        }
        #close-song-menu-btn {
            position: absolute;
            top: 5px;
            right: 10px;
            color: white;
            font-size: 20px;
            cursor: pointer;
            z-index: 1003;
        }
        .song-list-item {
            color: white;
            padding: 10px;
            margin-bottom: 5px;
            background-color: transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        #song-selection-list {
            flex-grow: 1; /* Take available vertical space */
            overflow-y: auto; /* Enable scrolling for the list only */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .song-list-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        /* Làm đậm bài hát đang phát trong danh sách */
        .song-list-item.current-song {
            color: rgba(0, 255, 255, 0.5);
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
        }
        /* Style for artist names in the song list */
        .song-list-item .artist-name {
            opacity: 0.7; /* Make it slightly faded */
        }
        .queue-badge {
            background-color: transparent;
            color: #00ffff;
            border: 1px solid #00ffff;
            border-radius: 50%;
            width: 12px;
            height: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 8px;
            margin-left: 10px;
            flex-shrink: 0;
            font-family: Arial, sans-serif;
            font-weight: bold;
        }
        #clear-queue-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: transparent;
            color: white;
            padding: 15px;
            border-radius: 8px;
            z-index: 2005;
            display: none;
            cursor: default;
            font-family: 'VN Time', Arial, sans-serif;
            font-size: 16px;
            text-align: center;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            width: 270px;
            height: 320px;
            box-sizing: border-box;
            flex-direction: column;
            align-items: center;
        }
        #clear-queue-box:hover {
            background-color: transparent;
        }
        /* --- 2D Music Controls Styles --- */
        #gif-tv-container {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            width: 220px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(0, 255, 255, 0.5);
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
            z-index: 1000;
            display: none;
            overflow: hidden;
            pointer-events: none;
            top: 120px; /* Desktop: Nằm dưới thanh điều khiển trên cùng */
        }
        #gif-tv-screen {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #music-controls-2d {
            position: fixed;
            /* Position handled by #main-ui-controls on desktop */ /* Removed fixed positioning here */
            /* display: flex; */ /* This will be set by JS when music is active */
            flex-direction: column; /* Xếp chồng các phần tử con theo chiều dọc */
            justify-content: center; /* Căn giữa các phần tử con theo chiều dọc */
            align-items: center; /* Căn giữa các phần tử con theo chiều ngang */
            gap: 5px; /* Khoảng cách giữa thanh tiến trình và hàng nút */
            background-color: rgba(0,0,0,0.5); /* Semi-transparent background */
            background-color: transparent; /* Làm nền trong suốt */
            padding: 5px 10px; /* Giữ padding */
            border-radius: 5px;
            border: none; /* Bỏ viền */
        }
        .music-player-buttons-row { /* Class mới cho hàng nút điều khiển */
            display: flex;
            gap: 10px; /* Khoảng cách giữa các nút */
            justify-content: center; /* Căn giữa các nút trong hàng */
            margin-top: -10px; /* Di chuyển các nút lên trên 15px */
            width: 300px; /* Đặt chiều rộng bằng thanh tiến trình trên desktop */
            transform: translateX(-5px); /* Dịch sang trái 5px */
            width: 200px; /* Giảm chiều rộng cho cân đối */
        }
        #playback-mode-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        #music-controls-2d button {
            background: none;
            border: none; /* Bỏ viền */
            color: white;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }
        .playback-mode-btn.active {
            border: 10px solid #3498db; /* Vòng tròn màu xanh, đậm hơn một chút */
            box-shadow: 0 0 8px rgba(52, 152, 219, 0.7); /* Hiệu ứng phát sáng nhẹ */
        }
        #music-controls-2d button:hover {
            background-color: rgba(0,0,0,0.7);
        }
        #music-player-scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none; /* Cho phép click xuyên qua để tương tác với scene chính */
        }
        #music-player-progress-container-2d {
            background-color: transparent;
            border-radius: 5px;
            height: 5px;
            cursor: pointer;
            width: 240px; /* Giảm chiều rộng đi 5px cho desktop */
            margin: 0 auto; /* Căn giữa theo chiều ngang trong container cha */
            margin: 0 auto 20px auto; /* Căn giữa theo chiều ngang trong container cha, thêm khoảng cách 20px ở dưới */
            position: relative; /* Cần thiết để định vị chấm kéo bên trong */
        }
        #music-player-progress-handle-2d {
            width: 24px; /* Tăng kích thước của chấm kéo lên gấp đôi */
            height: 24px;
            background-color: transparent; /* Make background transparent */
            border: 1px solid #ffffff; /* Add a white border */
            border-radius: 50%; /* Hình tròn */
            position: absolute;
            top: 50%; /* Căn giữa theo chiều dọc */
            transform: translateY(-50%); /* Dịch chuyển lên trên 50% chiều cao của chính nó */
            left: 0; /* Vị trí ban đầu, sẽ được JS cập nhật */
            cursor: grab; /* Con trỏ kéo */
        }
        #music-player-song-title-2d { /* Tên bài hát 2D mới */
            color: white;
            font-size: 12px;
            font-family: 'VN Time', Arial, sans-serif; /* Apply VN Time font */
            text-align: center; /* Căn giữa văn bản */
            pointer-events: none; /* Cho phép click xuyên qua để tương tác với thanh tiến trình */
            margin: 5px auto; /* Khoảng cách trên dưới và căn giữa ngang */
            background-color: transparent; /* Nền trong suốt */
            padding: 2px 5px;
            border-radius: 3px;
            /* New styles for scrolling container */
            position: relative; 
            overflow: hidden;
            white-space: nowrap;
            width: 200px; /* Explicit width */
            max-width: 200px;
            height: 15px; /* Fixed height */
            line-height: 15px;
        }
        .music-player-title-scroll-container-2d {
            display: inline-block;
            white-space: nowrap;
            position: absolute;
            left: 0;
            top: 0;
            background-color: transparent;
        }
        #music-player-song-title-2d.scrolling .music-player-title-scroll-container-2d {
            animation: scrollText var(--scroll-duration) linear infinite;
        }
        #music-player-progress-bar-2d {
            background-color: rgba(0, 255, 255, 0.5);
            height: 100%;
            width: 0%;
            border-radius: 5px;
        }
        /* --- 3D Music Player Styles --- */
        .music-player-container-3d {
            background-color: transparent; /* Nền hoàn toàn trong suốt */
            border: none; /* Bỏ viền */
            border-radius: 15px;
            padding: 15px;
            width: 375px;
            color: white;            
            font-family: 'VN Time', Arial, sans-serif; /* Apply VN Time font */
            font-weight: 100; /* Thinner font weight */
            box-shadow: none; /* Bỏ hiệu ứng đổ bóng */
            backdrop-filter: none; /* Bỏ hiệu ứng làm mờ nền */
            -webkit-backdrop-filter: none; /* Bỏ hiệu ứng làm mờ nền cho trình duyệt Webkit */
            position: relative;
            overflow: visible; /* Đảm bảo không cắt bớt các phần tử con tràn ra ngoài */
            pointer-events: auto; /* Allow interaction with the player */
        }
        .music-player-title {
            display: none;
            /* Existing styles */
            font-size: 21px;
            font-weight: bold;
            margin-bottom: 2px; /* Giảm khoảng cách dưới để sát vào chân chữ */
            background-color: transparent; /* Đảm bảo nền trong suốt */
            
            /* New styles for scrolling */
            white-space: nowrap; /* Ensure text stays on one line */
            overflow: hidden; /* Hide anything outside the container */
            text-overflow: ellipsis; /* Fallback for non-scrolling state */
            position: relative; /* Needed for positioning inner elements */
            z-index: 2; /* Đảm bảo nằm trên visualizer */
            width: 100%; /* Take full width of parent */
            height: 24px; /* Điều chỉnh chiều cao cho vừa khít */
            line-height: 24px; /* Căn chỉnh dòng */
        }
        .music-player-title-scroll-container {
            display: inline-block; /* Allows it to be wider than its parent */
            white-space: nowrap; /* Keeps content on one line */
            position: absolute; /* Position absolutely within .music-player-title */
            left: 0;
            top: 0;
            background-color: transparent;
        }
        .music-player-title-text,
        .music-player-title-text-duplicate {
            display: inline-block; /* Allows them to sit side-by-side */
            padding-right: 30px; /* Space between original and duplicate text */
        }
        @keyframes scrollText {
            0% { transform: translateX(var(--scroll-start)); }
            100% { transform: translateX(var(--scroll-end)); }
        }
        .music-player-title.scrolling .music-player-title-scroll-container {
            animation: scrollText var(--scroll-duration) linear infinite;
        }
        .music-player-time {
            display: flex;
            justify-content: space-between;
            font-size: 15px;
            margin-top: 190px; /* Tạo khoảng trống cho visualizer vì nó đã được đưa ra khỏi luồng (absolute) */
            line-height: 1; /* Thu gọn chiều cao sát vào số */
            align-items: center;
            position: relative;
            z-index: 2; /* Đảm bảo nằm trên visualizer */
        }
        .music-player-visualizer {
            position: absolute; /* Đưa ra khỏi luồng để không bị giới hạn bởi kích thước container */
            top: calc(50% - 5px);
            left: 50%;
            transform: translate(-50%, -50%); /* Căn giữa tuyệt đối */
            background-color: transparent; /* Nền trong suốt */
            border-radius: 4px;
            border: none; /* Bỏ viền */
            width: 150%; /* Rộng hơn container để tránh bị cắt */
            height: 760px; /* Cao hơn để hiển thị đầy đủ hiệu ứng */
            z-index: 1; /* Nằm dưới text */
            pointer-events: none; /* Cho phép click xuyên qua */
        }

        /* New container for main UI buttons */
        #main-ui-controls {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px; /* Extends across the top */
            z-index: 1001;
            display: flex;
            justify-content: space-between; /* Distribute items */
            align-items: flex-end;
            background-color: transparent; /* Làm nền trong suốt */
            border: none; /* Bỏ viền */
            pointer-events: none; /* Allow clicks to pass through to the scene by default */
        }

        #main-ui-controls > * {
            pointer-events: auto; /* Make children interactive */
        }

        /* Add a class for button groups */
        .ui-button-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
            width: 120px; /* Fixed width for desktop to prevent shifting */
        }
        /* Remove fixed positioning from individual buttons, let flexbox handle it */
        #select-planet-btn,
        #select-song-btn,
        #toggle-labels-btn,
        #toggle-images-btn {
            /* Các nút này giờ là con của #main-ui-controls, nên position: static là phù hợp */
            position: static;
            margin: 0;
        }

        /* Remove fixed positioning from 2D music controls */
        #music-controls-2d {
            position: static;
            margin-bottom: 27px;
        }

        /* Mobile Layout (max-width: 768px) */
        @media (max-width: 768px) {
            /* Main UI Controls Bar at the bottom */
            #main-ui-controls {
                top: auto; /* Remove top positioning */
                bottom: 10px; /* Position at the bottom */
                left: 10px;
                right: 10px;
                display: flex;
                flex-wrap: wrap; /* Allow items to wrap to the next line */
                justify-content: center; /* Center items when they wrap */
                align-items: center; /* Vertically align items within the bar */
                gap: 5px; /* Giảm khoảng cách giữa các nút và hàng khi wrap */ /* Nền hơi tối để dễ đọc */
                padding: 5px; /* Add some padding */
                background-color: transparent;
                border-radius: 8px;
                border: none; /* Bỏ viền */
            }

            #select-planet-btn,
            #select-song-btn {
                /* Áp dụng kiểu dáng cụ thể cho mobile */
                padding: 5px 8px; /* Giảm padding thêm */
                font-size: 11px; /* Giảm font size thêm */
                border: none; /* Bỏ viền */
            }
            .ui-button-group {
                width: 90px; /* Fixed width for mobile to prevent shifting */
            }
            /* Đảm bảo font size của nút "Ẩn tên" và "Tắt ảnh" cũng được áp dụng trên mobile */
            #toggle-labels-btn, #toggle-images-btn {
                font-size: 11px;
            }


            #music-controls-2d {
                padding: 2px 6px; /* Smaller padding */
                gap: 4px; /* Smaller gap */
                border: none; /* Bỏ viền */
            }

            #music-controls-2d button {
                /* Kích thước nút đã được giữ nguyên */
                width: 22px; /* Giảm kích thước thêm */
                height: 22px; /* Giảm kích thước thêm */
                font-size: 9px; /* Giảm kích thước chữ thêm */
            }

            #music-player-progress-container-2d {
                width: 100px; /* Giảm chiều rộng thêm */
            }
            .music-player-buttons-row {
                width: 100px; /* Giảm chiều rộng thêm */
                transform: translateX(0); /* Bỏ dịch chuyển để căn giữa tốt hơn */
            }
            #music-player-song-title-2d { /* Điều chỉnh chiều rộng cho mobile */
                max-width: 100px; /* Giảm chiều rộng thêm */
            }

            #bottom-right-controls {
                top: 20px;
                bottom: auto;
                right: 10px;
                left: auto;
                align-items: flex-start;
            }

            #overview-btn { /* Kiểu dáng mobile cho nút mới */
                padding: 8px 12px; /* Smaller padding */
                font-size: 14px; /* Smaller font size */
                border: none; /* Bỏ viền */
            }
            #zoom-btn {
                padding: 8px 12px;
                font-size: 14px;
            }
            #more-options-btn { /* Kiểu dáng mobile cho nút 3 chấm */
                padding: 8px 12px;
                font-size: 14px;
                border: none;
                background-color: transparent;
            }
            #bottom-left-controls {
                top: 20px;
                bottom: auto;
                left: 20px;
                right: auto;
                align-items: flex-start;
            }
            #volume-btn {
                padding: 8px 12px;
                font-size: 14px;
            }
            /* --- Mobile Settings Menu --- */
            #settings-overlay {
                top: 70px; /* Position below the 3-bar button */
                bottom: auto;
                left: 50%;
                transform: translateX(-50%);
                min-width: 200px;
                width: 90%;
                max-width: 250px;
            }

            /* Overlays for mobile (positioned above the bottom control bar) */
            #planet-list-overlay,
            #song-list-overlay {
                top: auto; /* Remove top positioning */
                bottom: 120px; /* Đặt vị trí cách lề dưới 110px (để tránh thanh điều khiển chính) */
                left: 50%; /* Center horizontally */
                transform: translateX(-50%); /* Center horizontally */
                width: 90%; /* Take up most of the width */
                max-width: 250px; /* Max width for larger phones */
                min-width: 180px; /* Đặt lại min-width để tránh quá nhỏ */
                padding: 8px; /* Adjust padding */
                background-color: transparent; /* Nền trong suốt */
                height: 220px; /* Đặt chiều cao cố định */
                overflow-y: auto; /* Cho phép cuộn nếu nội dung quá dài */
                -webkit-overflow-scrolling: touch; /* Giúp cuộn mượt mà trên iOS */
                box-shadow: 0 0 10px rgba(0,255,255,0.7); /* Slightly stronger shadow */
            }

            #song-list-overlay {
                overflow-y: hidden; /* Prevent the whole overlay from scrolling */
                display: none; /* Will be set to flex */
                flex-direction: column; /* Stack items vertically */
            }

            #close-dropmenu-btn,
            #close-song-menu-btn {
                top: 5px;
                right: 8px; /* Điều chỉnh vị trí nút đóng */
                font-size: 18px;
            }

            .planet-list-item,
            .song-list-item {
                padding: 6px; /* Smaller padding */
                font-size: 12px;
            }

            /* Fullscreen overlay adjustments */
            #close-btn {
                top: 10px;
                right: 10px;
                font-size: 24px;
            }

            #download-btn {
                bottom: 10px;
                right: 10px;
                padding: 5px 10px;
                font-size: 11px; /* Giảm kích thước thêm */
            }

            #clear-queue-box {
                top: auto;
                bottom: 120px;
                transform: translateX(-50%);
                height: 240px;
            }

            #gif-tv-container {
                top: auto;
                bottom: 140px; /* Mobile: Nằm trên thanh điều khiển dưới cùng */
                width: 180px;
                height: 120px;
            }

            /* 3D Music Player (internal styling) */
            .music-player-container-3d {
                width: 225px;
                padding: 9px;
            }
            .music-player-title {
                font-size: 14px; /* Smaller font size */
                height: 1.3em; /* Adjust height for new font size */
                line-height: 1.3em; /* Adjust line height */
            }
            .music-player-time {
                font-size: 11px;
                margin-top: 90px; /* Điều chỉnh khoảng cách cho mobile */
            }
            .music-player-visualizer {
                width: 150%; /* Rộng hơn container */
                height: 200px; /* Chiều cao cho mobile */
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
</head>
<body>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">

    <div id="loader-overlay">
        <div class="loader-container">
            <div class="progress-circle">
                <div class="progress-circle-inner">
                    <span id="progress-text" class="loader-text">0%</span>
                </div>
            </div>
            <span class="loader-text">Đang tải tài nguyên ...</span>
        </div>
    </div>
    <div id="fullscreen-overlay">
        <span id="close-btn">&times;</span>
        <img id="fullscreen-image" src="" alt="fullscreen-image" />
        <a id="download-btn" href="#" download style="display: none;">Tải xuống</a>
    </div>
    <div id="image-loader-overlay">
        <div class="loader-container">
            <div class="progress-circle">
                <div class="progress-circle-inner">
                    <span id="image-progress-text" class="loader-text">0%</span>
                </div>
            </div>
            
            <span class="loader-text">Loading Images...</span>
        </div>
    </div>

    <div id="main-scene">
        <!-- New container for UI buttons -->
        <div id="main-ui-controls">
            <div class="ui-button-group">
                <button id="select-planet-btn">Hành tinh</button>
                <button id="toggle-labels-btn">Hiện tên</button>
            </div>
            <!-- <button id="overview-btn">Toàn cảnh</button> Removed from here -->
            <div id="music-controls-2d" style="display: none;">
                <div id="music-player-progress-container-2d">
                    <div id="music-player-progress-bar-2d"></div>
                    <div id="music-player-progress-handle-2d"></div> <!-- Chấm kéo mới -->
                </div>
                <span id="music-player-song-title-2d"></span> <!-- Tên bài hát 2D mới -->
                <div class="music-player-buttons-row"> <!-- Hàng nút điều khiển mới -->
                    <button id="music-player-prev-2d">⏮</button>
                    <button id="music-player-play-pause-2d">▶</button>
                    <button id="music-player-next-2d">⏭</button>
                </div>
                <div id="playback-mode-controls">
                    <button id="repeat-one-btn" class="playback-mode-btn" title="Lặp lại một bài"><i class="fas fa-redo-alt"></i><span class="repeat-one-indicator">1</span></button>
                    <button id="sequential-btn" class="playback-mode-btn active" title="Phát tuần tự"><i class="fas fa-stream"></i></button>
                    <button id="shuffle-btn" class="playback-mode-btn" title="Phát ngẫu nhiên"><i class="fas fa-random"></i></button>
                </div>
            </div>
            <div class="ui-button-group">
                <button id="select-song-btn">Chọn nhạc</button>
                <button id="toggle-images-btn">Hiện ảnh</button>
            </div>
        </div>
        <!-- Existing overlays -->
        <div id="planet-list-overlay">
            <span id="close-dropmenu-btn">&times;</span>
            <ul id="planet-selection-list" style="list-style: none; padding: 0; margin: 0;">
                <!-- Planet items will be inserted here -->
            </ul>
        </div>
        <div id="song-list-overlay">
            <span id="close-song-menu-btn">&times;</span>
            <input type="text" id="song-search-input" placeholder="Tìm kiếm theo tên bài hát, ca sĩ...">
            <ul id="song-selection-list">
                <!-- Song items will be inserted here -->
            </ul>
        </div> <!-- Đóng thẻ div cho song-list-overlay -->
        <div id="clear-queue-box">Hủy danh sách riêng đó</div>
        <div id="gif-tv-container">
            <img id="gif-tv-screen" src="" alt="TV">
        </div>
        <!-- New Settings Overlay -->
        <div id="settings-overlay">
            <span id="close-settings-menu-btn">&times;</span>
            <ul id="settings-list" style="list-style: none; padding: 0; margin: 0;">
                <li class="settings-list-item" id="toggle-orbits-btn" style="cursor: pointer;">
                    <!-- The text inside the label will be controlled by JavaScript -->
                    <label style="pointer-events: none; margin-bottom: 0;">Ẩn Quỹ đạo</label>
                </li>
                <li class="settings-list-item" id="toggle-visualizer-btn" style="cursor: pointer;">
                    <!-- The text inside the label will be controlled by JavaScript -->
                    <label style="pointer-events: none; margin-bottom: 0;">Ẩn Sóng nhạc</label>
                </li>
                <li class="settings-list-item" id="change-visualizer-style-btn" style="cursor: pointer;">
                    <!-- The text inside the label will be controlled by JavaScript -->
                    <label style="pointer-events: none; margin-bottom: 0;">Đổi kiểu sóng nhạc</label>
                </li>
                <li class="settings-list-item" id="toggle-time-display-btn" style="cursor: pointer;">
                    <!-- The text inside the label will be controlled by JavaScript -->
                    <label style="pointer-events: none; margin-bottom: 0;">Ẩn Thời gian</label>
                </li>
                <li class="settings-list-item">
                    <label for="radius-slider">Mở rộng vũ trụ (<span id="radius-value">10.00</span>x)</label>
                    <input type="range" id="radius-slider" min="1" max="50" value="30" step="0.01">
                </li>
                <li class="settings-list-item">
                    <label for="density-slider">Số lượng sao (<span id="density-value">250,000</span>)</label>
                    <input type="range" id="density-slider" min="200000" max="3400000" step="1" value="200000">
                </li>
                <li class="settings-list-item">
                    <label for="zoom-slider">Giới hạn zoom (<span id="zoom-value">20,000x</span>)</label>
                    <input type="range" id="zoom-slider" min="50" max="100000" step="1" value="20000">
                </li>
                <li class="settings-list-item">
                    <label for="speed-slider">Tốc độ quỹ đạo (<span id="speed-value">5.00</span>x)</label>
                    <input type="range" id="speed-slider" min="1" max="100" value="5" step="0.01">
                </li>
            </ul>
        </div>
        <div id="bottom-left-controls">
            <button id="more-options-btn"><i class="fas fa-bars"></i></button>
            <div id="volume-control-container">
                <button id="volume-btn"><i class="fas fa-volume-up"></i></button>
                <div id="volume-slider-container" style="display: none;">
                    <input type="range" id="volume-slider" min="0" max="100" value="100">
                </div>
            </div>
        </div>
        <!-- Canvas and renderers will be appended here by Three.js -->
        <div id="bottom-right-controls">
            <button id="overview-btn">Toàn cảnh</button>
            <div id="zoom-control-container">
                <button id="zoom-btn"><i class="fas fa-eye"></i></button>
                <div id="zoom-slider-container" style="display: none;">
                    <input type="range" id="zoom-level-slider" min="10" max="120" value="75">
                </div>
            </div>
        </div>
    </div>

    <audio id="background-music"></audio>

    <script>
        // --- Image & Planet Data ---
        const totalImages = 62;
        const allImageUrls = Array.from({length: totalImages}, (_, i) => `images/${i + 1}.png`);
        const usedImageUrls = new Set();
        const planets = [];
        
        // --- Realistic Orbital Speeds ---
        // The base speed is for Earth and is adjusted for visual appeal in the simulation.
        // Other planets' speeds are calculated relative to Earth's real orbital period.
        // Speed = (Earth's Speed) * (Earth's Period / Planet's Period)
        const EARTH_ORBITAL_PERIOD_DAYS = 365.25;
        const EARTH_SIMULATION_SPEED = 0.0004;

        const planetData = [
            // Orbital Period: ~88 Earth days
            { name: 'Sao Thủy', distance: 20, size: 2.0, color: 0xcccccc, speed: EARTH_SIMULATION_SPEED * (EARTH_ORBITAL_PERIOD_DAYS / 88), realSpeed: 47.87 },
            // Orbital Period: ~225 Earth days
            { name: 'Sao Kim', distance: 35, size: 2.3, color: 0xffa500, speed: EARTH_SIMULATION_SPEED * (EARTH_ORBITAL_PERIOD_DAYS / 225), realSpeed: 35.02 },
            // Orbital Period: ~365 Earth days
            { name: 'Trái Đất', distance: 50, size: 2.4, color: 0x00bfff, speed: EARTH_SIMULATION_SPEED, realSpeed: 29.78 },
            // Orbital Period: ~687 Earth days
            { name: 'Sao Hỏa', distance: 70, size: 2.1, color: 0xff4500, speed: EARTH_SIMULATION_SPEED * (EARTH_ORBITAL_PERIOD_DAYS / 687), realSpeed: 24.08 },
            // Orbital Period: ~11.86 Earth years
            { name: 'Sao Mộc', distance: 100, size: 8, color: 0xffe0b2, speed: EARTH_SIMULATION_SPEED / 11.86, realSpeed: 13.07 },
            // Orbital Period: ~29.46 Earth years
            { name: 'Sao Thổ', distance: 140, size: 6.9, color: 0xffd700, speed: EARTH_SIMULATION_SPEED / 29.46, realSpeed: 9.69 },
            // Orbital Period: ~84.02 Earth years
            { name: 'Sao Thiên Vương', distance: 180, size: 4.1, color: 0x87ceeb, speed: EARTH_SIMULATION_SPEED / 84.02, realSpeed: 6.81 },
            // Orbital Period: ~164.79 Earth years
            { name: 'Sao Hải Vương', distance: 220, size: 4.0, color: 0x1e90ff, speed: EARTH_SIMULATION_SPEED / 164.79, realSpeed: 5.43 }
        ];

        // --- Loading Manager ---
        const loadingManager = new THREE.LoadingManager();
        const textureLoader = new THREE.TextureLoader(loadingManager);
        const loaderOverlay = document.getElementById('loader-overlay');
        const progressCircle = document.querySelector('.progress-circle');
        const progressText = document.getElementById('progress-text');

        loadingManager.onProgress = function (url, itemsLoaded, itemsTotal) {
            const progress = (itemsLoaded / itemsTotal) * 100;
            const percentage = Math.round(progress);
            progressText.textContent = `${percentage}%`;
            progressCircle.style.background = `conic-gradient(#3498db ${progress}%, #1a1a1a 0%)`;
        };

        loadingManager.onLoad = function () {
            // Fade out loader
            loaderOverlay.style.opacity = '0';
            setTimeout(() => {
                loaderOverlay.style.display = 'none';
                // Show the main scene and start the animation
                document.getElementById('main-scene').style.display = 'block';
                // Khởi tạo chế độ phát nhạc ngẫu nhiên theo yêu cầu
                playbackMode = 'random'; // Mặc định là phát ngẫu nhiên
                generateShuffledPlaylist(); // Tạo danh sách phát ngẫu nhiên ban đầu
                updatePlaybackModeUI(); // Set initial button state
                const randomIndex = Math.floor(Math.random() * songs.length);
                showMusicPlayer(randomIndex);
                // Nút "Toàn cảnh" giờ đã được đặt đúng vị trí và có CSS display: block, nên không cần setTimeout hay console.log nữa.
                // console.log('Main scene displayed. Overview button display:', document.getElementById('overview-btn').style.display); // Debugging (có thể xóa)
                animate();
            }, 500);
        };
        
        // --- Preload all images and cache them---
        const textureCache = {};
        allImageUrls.forEach(url => {
            textureCache[url] = textureLoader.load(url);
        });

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        const scene_bg = new THREE.Scene(); // Scene for background elements (stars, music player)
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 60000);
        
        // Foreground WebGL Renderer (Planets)
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // alpha:true for transparent background
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.top = '0px';
        renderer.domElement.style.zIndex = 2; // Above background CSS and WebGL
        document.getElementById('main-scene').appendChild(renderer.domElement);
        
        // Background WebGL Renderer (Stars)
        const renderer_bg = new THREE.WebGLRenderer({ antialias: true });
        renderer_bg.setSize(window.innerWidth, window.innerHeight);
        renderer_bg.domElement.style.position = 'absolute';
        renderer_bg.domElement.style.top = '0px';
        renderer_bg.domElement.style.zIndex = 0; // At the very back
        // Insert at the beginning of the container so it's naturally behind other elements added later
        document.getElementById('main-scene').insertBefore(renderer_bg.domElement, document.getElementById('main-scene').firstChild);

        // --- Starfield ---
        let stars;
        // Store data for animating each star individually
        const starAnimationData = [];
        let currentStarCount = 450000;
        let currentRadiusMultiplier = 10;
        const baseStarfieldRadius = 2500;

        // Create a single, reusable star texture
        const starTexture = (() => {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            context.beginPath();
            context.arc(16, 16, 16, 0, 2 * Math.PI);
            context.fillStyle = 'white';
            context.fill();
            return new THREE.CanvasTexture(canvas);
        })();

        function regenerateStarfield(numStars, radiusMultiplier) {
            // 1. Clean up old starfield if it exists
            if (stars) {
                scene_bg.remove(stars); // Remove from background scene
                stars.geometry.dispose();
                stars.material.dispose();
                stars = null;
            }
            starAnimationData.length = 0; // Clear animation data

            // 2. Generate new starfield
            const starGeometry = new THREE.BufferGeometry();
            const starVertices = [];
            const starColors = [];
            const starfieldRadius = baseStarfieldRadius * radiusMultiplier;
            const initialTime = performance.now();

            for (let i = 0; i < numStars; i++) {
                // Tạo các ngôi sao trong một hình cầu lớn để tránh các cạnh cứng
                const r = starfieldRadius * Math.cbrt(Math.random()); // Phân bố đồng đều trong hình cầu
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos((2 * Math.random()) - 1);
                
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);
                starVertices.push(x, y, z);

                // Tỷ lệ 80% sao tĩnh, 20% sao nhấp nháy
                if (Math.random() < 0.8) {
                    // This is a static star, always on
                    const brightness = 0.2 + Math.random() * 0.6; // Random brightness from 0.2 to 0.8
                    starColors.push(brightness, brightness, brightness);
                    starAnimationData.push({ isStatic: true });
                } else {
                    // This is a twinkling star
                    // Start twinkling stars as black
                    starColors.push(0, 0, 0);

                    // Store animation state for the twinkling star
                    starAnimationData.push({
                        isStatic: false, // Mark as not static
                        isTwinkling: false,
                        // Set a random time for the first twinkle to appear (from now up to 10s)
                        nextTwinkleTime: initialTime + Math.random() * 10000,
                        twinkleEndTime: 0,
                        color: new THREE.Color(),
                        twinkleDuration: 0
                    });
                }
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starColors, 3));

            const starMaterial = new THREE.PointsMaterial({
                map: starTexture,
                size: 1.5,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                vertexColors: true // IMPORTANT: Use vertex colors
            });

            stars = new THREE.Points(starGeometry, starMaterial);
            scene_bg.add(stars); // Add to background scene

            // Update current values
            currentStarCount = numStars;
            currentRadiusMultiplier = radiusMultiplier;
        }
        regenerateStarfield(currentStarCount, currentRadiusMultiplier);

        // --- Label Renderer Setup ---
        // Foreground CSS Renderer (Planet Labels)
        const labelRenderer_fg = new THREE.CSS2DRenderer();
        labelRenderer_fg.setSize(window.innerWidth, window.innerHeight);
        labelRenderer_fg.domElement.style.position = 'absolute';
        labelRenderer_fg.domElement.style.top = '0px';
        labelRenderer_fg.domElement.style.zIndex = 3; // On top of everything
        document.getElementById('main-scene').appendChild(labelRenderer_fg.domElement);

        // Background CSS Renderer (Music Player)
        const labelRenderer_bg = new THREE.CSS2DRenderer();
        labelRenderer_bg.setSize(window.innerWidth, window.innerHeight);
        labelRenderer_bg.domElement.style.position = 'absolute';
        labelRenderer_bg.domElement.style.top = '0px';
        labelRenderer_bg.domElement.style.zIndex = 1; // Above background stars, behind foreground planets
        labelRenderer_bg.domElement.style.pointerEvents = 'none'; // Allow clicks to pass through to the planet scene
        document.getElementById('main-scene').appendChild(labelRenderer_bg.domElement);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        // --- Controls ---
        const controls = new THREE.OrbitControls(camera, labelRenderer_fg.domElement); // Controls interact with the foreground
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 10;
        controls.maxDistance = 20000;

        // --- Sun ---
        const sunGeometry = new THREE.SphereGeometry(10, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffdd00 });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.userData = { isSun: true, name: 'Mặt trời', size: 10 }; // Thêm tên và kích thước cho Mặt trời
        scene.add(sun);
        const sunLight = new THREE.PointLight(0xffffff, 1.5, 2000);
        sun.add(sunLight);

        // --- Create Planets and Orbits ---
        planetData.forEach(data => {
            const planetGeometry = new THREE.SphereGeometry(data.size, 32, 32);
            const planetMaterial = new THREE.MeshStandardMaterial({ color: data.color });
            const planet = new THREE.Mesh(planetGeometry, planetMaterial);
            
            const imageGroup = new THREE.Group();
            planet.add(imageGroup);
            sun.userData.imageGroup = new THREE.Group(); // Initialize imageGroup for sun

            // Create Label
            const planetDiv = document.createElement('div');
            planetDiv.className = 'planet-label';
            planetDiv.classList.add('hidden'); // Ẩn tên hành tinh theo mặc định
            planetDiv.textContent = data.name;
            planetDiv.addEventListener('click', (event) => {
                event.stopPropagation();
                handlePlanetClick(planet); // Call handlePlanetClick directly
            });
            // Thêm lắng nghe sự kiện touchend cho nhãn để đảm bảo tương tác chạm trên di động
            planetDiv.addEventListener('touchend', (event) => {
                event.preventDefault(); // Ngăn chặn hành vi mặc định của trình duyệt (ví dụ: ghost click)
                event.stopPropagation(); // Ngăn chặn sự kiện lan truyền thêm (ví dụ: đến OrbitControls hoặc onInteraction)
                handlePlanetClick(planet); // Call handlePlanetClick directly
            });
            const planetLabel = new THREE.CSS2DObject(planetDiv);
            planetLabel.position.set(0, data.size + 2, 0);
            planet.add(planetLabel);

            // Tạo một hitbox hình cầu vô hình lớn hơn một chút so với hành tinh
            const hitboxGeometry = new THREE.SphereGeometry(data.size + 0.5, 32, 32); // Lớn hơn hành tinh 0.5 đơn vị
            const hitboxMaterial = new THREE.MeshBasicMaterial({
                transparent: true,
                opacity: 0, // Hoàn toàn vô hình
                depthWrite: false // Không ghi vào depth buffer để không ảnh hưởng đến các đối tượng khác
            });
            const hitboxSphere = new THREE.Mesh(hitboxGeometry, hitboxMaterial);
            hitboxSphere.userData = { isHitbox: true, parentPlanet: planet }; // Đánh dấu đây là hitbox và liên kết với hành tinh cha
            planet.add(hitboxSphere); // Thêm hitbox vào hành tinh để nó di chuyển cùng

            planet.userData = { 
                ...data, 
                isPlanet: true, 
                angle: Math.random() * Math.PI * 2, // Initial orbital angle
                interactionState: 0, // 0: default, 1: images shown & locked, 2: images shown & unlocked, 3: images hidden & unlocked
                imageGroup: imageGroup
            };
            
            const orbitGeometry = new THREE.TorusGeometry(data.distance, 0.2, 16, 128); // Use TorusGeometry for a 3D tube shape
            const orbitMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, opacity: 0.8, transparent: true }); // Brighter cyan, higher opacity
            const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
            orbit.rotation.x = -Math.PI / 2;
            orbit.userData.isOrbit = true; // Flag to identify orbits
                        scene.add(orbit);
                        
                        if (data.name === 'Sao Thổ') {
                const ringGeometry = new THREE.RingGeometry(data.size * 1.5, data.size * 2.5, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({ color: 0xead5a8, side: THREE.DoubleSide, opacity: 0.7, transparent: true });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI * 0.4;
                planet.add(ring);
            }

            scene.add(planet);
            planets.push(planet);
        });

        // --- Camera Position ---
        camera.position.set(0, 100, 250);
        camera.lookAt(scene.position);

        // --- Raycasting for Clicks ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let sunMessage = null; // To track the sun message label
        let sunMessageMesh = null;
        let sunMessageAnimation = { active: false };

        // --- Planet Speed Multiplier ---
        let planetSpeedMultiplier = 5.0;

        // --- Camera Lock Feature Variables ---
        let lockedPlanet = null; // Stores the planet object to follow
        let isViewLocked = false; // Flag to indicate if view is locked
        let lastTouchTimestamp = 0;
        // Variables for two-stage camera animation
        let isCameraAnimating = false;
        let cameraAnimationStartTime = 0;
        // 0: idle, 1: return to home view, 2: move to target planet
        let cameraAnimationPhase = 0;
        const returnToHomeDuration = 1000; // milliseconds for returning to initial view
        const moveToTargetDuration = 1500; // milliseconds for moving to target planet

        const startCameraPosition = new THREE.Vector3();
        const startControlsTarget = new THREE.Vector3();
        // Define the "home" view (initial camera position and target)
        const homeCameraPosition = new THREE.Vector3(0, 100, 250);
        const homeControlsTarget = new THREE.Vector3(0, 0, 0);
        const finalCameraPosition = new THREE.Vector3();       // Final camera position near planet

        const overviewControlsTarget = new THREE.Vector3(0, 0, 0);
        const finalControlsTarget = new THREE.Vector3();        // Final controls target (planet's world position)
        const TOUCH_DELAY = 300; // Milliseconds to prevent ghost clicks

        // Easing function for smoother animations
        function easeInOutSine(t) {
            return 0.5 - 0.5 * Math.cos(t * Math.PI);
        }

        // Định nghĩa chế độ xem "Toàn cảnh"
        const maxPlanetDistance = planetData[planetData.length - 1].distance; // Lấy khoảng cách của hành tinh ngoài cùng
        let overviewCameraPosition; // Khai báo là 'let' để có thể gán lại

        function calculateOverviewCameraPosition() {
            const isMobile = window.innerWidth <= 768;
            // Điều chỉnh padding theo đơn vị thế giới. Giá trị này sẽ ảnh hưởng đến mức độ zoom.
            // Giá trị lớn hơn sẽ zoom ra xa hơn, giá trị nhỏ hơn sẽ zoom gần hơn.
            // Đây là một giá trị heuristic để mô phỏng "cách lề 50px/10px". Để zoom to hơn, giảm giá trị này.
            const worldPadding = isMobile ? 25 : 50; // Tăng padding để zoom ra xa hơn

            // Kích thước mục tiêu (nửa chiều rộng/chiều cao) mà camera cần nhìn thấy
            const targetHalfWidth = maxPlanetDistance + worldPadding;
            const targetHalfHeight = maxPlanetDistance + worldPadding;

            // Tính toán FOV ngang dựa trên FOV dọc và tỷ lệ khung hình
            const vFovRad = THREE.MathUtils.degToRad(camera.fov);
            const hFovRad = 2 * Math.atan(Math.tan(vFovRad / 2) * camera.aspect);

            // Tính toán Z cần thiết để vừa với chiều ngang
            // Z = (chiều rộng mục tiêu / 2) / tan(hFov / 2)
            let zHorizontal = targetHalfWidth / Math.tan(hFovRad / 2);
            
            // Tính toán Z cần thiết để vừa với chiều dọc
            // Z = (chiều cao mục tiêu / 2) / tan(vFov / 2)
            let zVertical = targetHalfHeight / Math.tan(vFovRad / 2);

            // Lấy giá trị Z lớn hơn để đảm bảo cả hai chiều đều vừa
            let finalZ = Math.max(zHorizontal, zVertical);

            // Điều chỉnh Y để duy trì góc nhìn tương tự như vị trí ban đầu (0, 500, 1000)
            // Tỷ lệ ban đầu: Y/Z = 500/1000 = 0.5
            const finalY = finalZ * 0.5; // Giữ tỷ lệ Y/Z nhất quán

            return new THREE.Vector3(0, finalY, finalZ);
        }

        // Khởi tạo vị trí camera toàn cảnh ban đầu
        overviewCameraPosition = calculateOverviewCameraPosition();

        function onInteraction(event) {
            console.log('onInteraction called, event type:', event.type); // Debugging line

            // Prevent ghost clicks on mobile: if a click event happens very soon after a touchend, ignore it.
            if (event.type === 'touchend') {
                lastTouchTimestamp = Date.now();
            } else if (event.type === 'click') {
                if (Date.now() - lastTouchTimestamp < TOUCH_DELAY) {
                    return; // This click is likely a ghost click, already handled by touchend
                }
            }

            if (event.target.closest('.planet-label')) {
                console.log('Tapped on planet label, ignoring raycast.'); // Debugging line
                return;
            }

            // Determine the correct clientX and clientY for both mouse and touch events
            const rect = renderer.domElement.getBoundingClientRect();
            let clientX, clientY;
            if (event.changedTouches && event.changedTouches.length > 0) { // For touchend, use changedTouches
                clientX = event.changedTouches[0].clientX;
                clientY = event.changedTouches[0].clientY;
            } else if (event.touches && event.touches.length > 0) { // For other touch events (e.g., touchstart, touchmove)
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else { // For mouse events
                clientX = event.clientX;
                clientY = event.clientY;
            }

            if (typeof clientX === 'undefined' || typeof clientY === 'undefined') {
                // No valid coordinates found, exit
                console.log('No valid coordinates found, exiting onInteraction.'); // Debugging line
                return;
            }

            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                // Nếu một đối tượng được nhấn, ngăn chặn OrbitControls xử lý chạm này như một thao tác camera
                if (event.type === 'touchend') {
                    event.preventDefault();
                    event.stopPropagation();
                }
                console.log('Raycaster hit something!', intersects[0].object); // Debugging line
                let clickedObject = intersects[0].object;

                if (clickedObject.userData.isHitbox) {
                    handlePlanetClick(clickedObject.userData.parentPlanet); // Use new handler for direct planet clicks
                    return; // Process hitbox click, then exit
                }

                if (clickedObject.userData.isSun) {
                    showMessageOnSun();
                } else if (clickedObject.userData.isImagePlane) {
                    document.getElementById('fullscreen-image').src = clickedObject.userData.imageUrl;
                    document.getElementById('fullscreen-overlay').style.display = 'flex';
                    document.getElementById('download-btn').href = clickedObject.userData.imageUrl;
                    document.getElementById('select-planet-btn').style.display = 'none'; // Ẩn nút "Chọn hành tinh"
                    document.getElementById('download-btn').style.display = 'block'; // Hiển thị nút tải xuống
                    if (!isViewLocked) { // Only disable controls if view is NOT locked
                        controls.enabled = false;
                    }
                } else {
                    let parentPlanet = clickedObject;
                    while (parentPlanet.parent && !parentPlanet.userData.isPlanet) {
                        parentPlanet = parentPlanet.parent;
                    }
                    if (parentPlanet.userData.isPlanet) {
                        handlePlanetClick(parentPlanet); // Use new handler for direct planet clicks
                    }
                }
            } else {
                console.log('Raycaster hit nothing.'); // Debugging line
            }
        }

        // --- Planet Selection UI Logic ---
        const selectPlanetBtn = document.getElementById('select-planet-btn');
        const planetListOverlay = document.getElementById('planet-list-overlay');
        const planetSelectionList = document.getElementById('planet-selection-list');
        const closeDropmenuBtn = document.getElementById('close-dropmenu-btn');

        let selectedPlanetObject = null; // Biến toàn cục để theo dõi hành tinh đang được chọn
        let isSettingsMenuOpen = false; // Track if settings menu is open
        selectPlanetBtn.addEventListener('click', (event) => {
            event.stopPropagation(); // Ngăn chặn sự kiện lan truyền lên document
            if (isPlanetListOpen) {
                hidePlanetList();
            } else {
                if (isSongListOpen) { // Nếu danh sách nhạc đang mở, đóng nó lại
                    hideSongList();
                }
                if (isZoomSliderOpen) {
                    hideZoomSlider();
                }
                if (isVolumeSliderOpen) hideVolumeSlider();
                if (isSettingsMenuOpen) { // Nếu menu cài đặt đang mở, đóng nó lại
                    hideSettingsMenu();
                }
                showPlanetList();
            }
        });
        closeDropmenuBtn.addEventListener('click', (event) => {
            event.stopPropagation(); // Ngăn chặn sự kiện lan truyền lên document
            hidePlanetList();
        });

        function showPlanetList() {
            planetListOverlay.style.display = 'flex';
            isPlanetListOpen = true; // Set flag when planet list is open
            populatePlanetList();
            controls.enabled = false; // Disable controls when list is open
            // Thêm trình lắng nghe sự kiện toàn cục để đóng dropmenu khi click/touch bên ngoài
            document.addEventListener('click', handleOutsideInteraction);
            document.addEventListener('touchend', handleOutsideInteraction);
        }

        function hidePlanetList() {
            planetListOverlay.style.display = 'none';
            isPlanetListOpen = false; // Clear flag when planet list is closed
            // Chỉ kích hoạt lại controls nếu không có hoạt ảnh camera nào đang diễn ra và chế độ xem không bị khóa
            if (!isCameraAnimating && !isViewLocked) {
                controls.enabled = true;
            }
            // Xóa trình lắng nghe sự kiện toàn cục
            document.removeEventListener('click', handleOutsideInteraction);
            document.removeEventListener('touchend', handleOutsideInteraction);
        }
        // Thêm trình lắng nghe sự kiện để đóng dropmenu khi nhấn phím ESC
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                if (planetListOverlay.style.display === 'flex') {
                    hidePlanetList();
                }
                if (isSongListOpen) {
                    hideSongList();
                }
                if (isSettingsMenuOpen) {
                    hideSettingsMenu();
                }
                if (isZoomSliderOpen) {
                    hideZoomSlider();
                }
            }
        });

        function handleOutsideInteraction(event) {
            // Kiểm tra xem sự kiện click/touch có nằm ngoài dropmenu và nút "Chọn hành tinh" hay không
            const isClickInsideOverlay = planetListOverlay.contains(event.target);
            const isClickOnSelectButton = selectPlanetBtn.contains(event.target);

            if (!isClickInsideOverlay && !isClickOnSelectButton) {
                hidePlanetList();
            }
        }

        function populatePlanetList() {
            planetSelectionList.innerHTML = ''; // Clear previous list

            // Thêm Mặt trời vào danh sách
            const sunListItem = document.createElement('li');
            sunListItem.className = 'planet-list-item';
            sunListItem.textContent = sun.userData.name;
            if (selectedPlanetObject === sun) {
                sunListItem.classList.add('current-planet');
            }

            sunListItem.addEventListener('click', () => {
                handlePlanetClick(sun); // Use handlePlanetClick for sun
                event.stopPropagation(); // Ngăn chặn sự kiện lan truyền lên document
                hidePlanetList();
            });
            planetSelectionList.appendChild(sunListItem);

            // Thêm các hành tinh vào danh sách
            planets.forEach(planet => {
                const listItem = document.createElement('li');
                listItem.className = 'planet-list-item';
                if (selectedPlanetObject === planet) {
                    listItem.classList.add('current-planet');
                }

                listItem.textContent = planet.userData.name;
                listItem.addEventListener('click', () => {
                    handlePlanetClick(planet); // Use handlePlanetClick for planets
                    event.stopPropagation(); // Ngăn chặn sự kiện lan truyền lên document
                    hidePlanetList();
                });
                planetSelectionList.appendChild(listItem);
            });
        }

        // --- Settings Menu Logic ---
        const moreOptionsBtn = document.getElementById('more-options-btn');
        const settingsOverlay = document.getElementById('settings-overlay');
        const closeSettingsBtn = document.getElementById('close-settings-menu-btn');

        const radiusSlider = document.getElementById('radius-slider');
        const radiusValue = document.getElementById('radius-value');
        const densitySlider = document.getElementById('density-slider');
        const densityValue = document.getElementById('density-value');
        const zoomSlider = document.getElementById('zoom-slider');
        const zoomValue = document.getElementById('zoom-value');
        const speedSlider = document.getElementById('speed-slider');
        const speedValue = document.getElementById('speed-value');

        // New orbit toggle elements
        const toggleOrbitsBtn = document.getElementById('toggle-orbits-btn');
        const toggleOrbitsLabel = toggleOrbitsBtn.querySelector('label');
        let areOrbitsVisible = true; // Default state: orbits are visible

        // New visualizer toggle elements
        const toggleVisualizerBtn = document.getElementById('toggle-visualizer-btn');
        const toggleVisualizerLabel = toggleVisualizerBtn.querySelector('label');
        let isVisualizerVisible = true; // Default state: visualizer is visible
        
        // New visualizer style change elements
        const changeVisualizerStyleBtn = document.getElementById('change-visualizer-style-btn');
        const changeVisualizerStyleLabel = changeVisualizerStyleBtn.querySelector('label');
        const visualizerStyleNames = [
            "Tia Chớp",
            "Vòng Neon",
            "Gợn Sóng",
            "Mandala",
            "Thanh Tròn",
            "Ngọn Lửa"
        ];
        let currentVisualizerStyle = 4; // 0: Lightning, 1: Cyberpunk, 2: Circular, 3: Vertical, 4: Mirror, 5: Particles
        if (changeVisualizerStyleLabel) changeVisualizerStyleLabel.textContent = `Kiểu: ${visualizerStyleNames[currentVisualizerStyle]}`;

        // New time display toggle elements
        const toggleTimeDisplayBtn = document.getElementById('toggle-time-display-btn');
        const toggleTimeDisplayLabel = toggleTimeDisplayBtn.querySelector('label');
        let isTimeDisplayVisible = false; // Default state: time is hidden

        // New volume control elements
        const volumeBtn = document.getElementById('volume-btn');
        const volumeSliderContainer = document.getElementById('volume-slider-container');
        const volumeSlider = document.getElementById('volume-slider');
        const volumeIcon = volumeBtn.querySelector('i');
        let isVolumeSliderOpen = false;

        // New zoom control elements
        const zoomBtn = document.getElementById('zoom-btn');
        const zoomSliderContainer = document.getElementById('zoom-slider-container');
        const zoomLevelSlider = document.getElementById('zoom-level-slider');
        let isZoomSliderOpen = false;

        // --- Settings Persistence ---
        function saveSettings() {
            const settings = {
                // radius và density không được lưu trữ theo yêu cầu
                // radius: radiusSlider.value, 
                // density: densitySlider.value,
                zoom: zoomSlider.value,
                speed: speedSlider.value,
                orbitsVisible: areOrbitsVisible,
                visualizerVisible: isVisualizerVisible,
                visualizerStyle: currentVisualizerStyle,
                timeDisplayVisible: isTimeDisplayVisible,
                volume: volumeSlider.value,
                fov: camera.fov
            };
            localStorage.setItem('solarSystemSettings', JSON.stringify(settings));
        }

        function loadSettings() {
            const savedSettings = localStorage.getItem('solarSystemSettings');
            if (savedSettings) {
                const settings = JSON.parse(savedSettings);

                // Lấy giá trị từ cài đặt đã lưu hoặc giữ nguyên giá trị mặc định từ HTML
                const radius = settings.radius || radiusSlider.value;
                const density = settings.density || densitySlider.value;
                const zoom = settings.zoom || zoomSlider.value;
                const speed = settings.speed || speedSlider.value;
                // Load orbit visibility, defaulting to true if not found or not explicitly false
                const orbitsVisible = settings.orbitsVisible === false ? false : true;
                // Load visualizer visibility, defaulting to true if not found or not explicitly false
                const visualizerVisible = settings.visualizerVisible === false ? false : true;
                const timeDisplayVisible = false; // Luôn ẩn thời gian khi khởi động
                const savedVisualizerStyle = (settings.visualizerStyle !== undefined) ? settings.visualizerStyle : 4;
                // Load volume, defaulting to 100 if not found
                const volume = settings.volume || '100';
                const fov = settings.fov || 75; // Load FOV, default to 75

                // Cập nhật giá trị cho các thanh trượt
                radiusSlider.value = radius;
                densitySlider.value = density;
                zoomSlider.value = zoom;
                speedSlider.value = speed;

                // Cập nhật văn bản hiển thị giá trị
                radiusValue.textContent = parseFloat(radius).toFixed(2);
                densityValue.textContent = parseInt(density).toLocaleString('en-US');
                zoomValue.textContent = parseInt(zoom).toLocaleString('en-US') + 'x';
                speedValue.textContent = parseFloat(speed).toFixed(2);

                // Cập nhật các biến trạng thái của ứng dụng
                controls.maxDistance = parseInt(zoom);
                planetSpeedMultiplier = parseFloat(speed);

                // Apply orbit visibility
                areOrbitsVisible = orbitsVisible;
                scene.children.forEach(child => {
                    if (child.userData.isOrbit) {
                        child.visible = areOrbitsVisible;
                    }
                });
                toggleOrbitsLabel.textContent = areOrbitsVisible ? 'Ẩn Quỹ đạo' : 'Hiện Quỹ đạo';

                // Apply visualizer visibility state and update label
                isVisualizerVisible = visualizerVisible;
                if (toggleVisualizerLabel) {
                    toggleVisualizerLabel.textContent = isVisualizerVisible ? 'Ẩn Sóng nhạc' : 'Hiện Sóng nhạc';
                }

                // Apply time display visibility
                isTimeDisplayVisible = timeDisplayVisible;
                if (toggleTimeDisplayLabel) {
                    toggleTimeDisplayLabel.textContent = isTimeDisplayVisible ? 'Ẩn Thời gian' : 'Hiện Thời gian';
                }
                
                // Apply visualizer style
                currentVisualizerStyle = parseInt(savedVisualizerStyle);
                if (changeVisualizerStyleLabel) {
                    changeVisualizerStyleLabel.textContent = `Kiểu: ${visualizerStyleNames[currentVisualizerStyle]}`;
                }

                // Apply volume setting
                volumeSlider.value = volume;
                audioPlayer.volume = volume / 100;
                updateVolumeIcon(volume / 100);
                updateVolumeSliderVisual(volume);

                // Apply FOV setting
                camera.fov = fov;
                camera.updateProjectionMatrix();
                zoomLevelSlider.value = fov;
                updateZoomSliderVisual(fov);

                // Tái tạo lại các vì sao với giá trị mật độ và bán kính đã được tải
                regenerateStarfield(parseInt(density), parseFloat(radius));
            }
        }

        function showSettingsMenu() {
            settingsOverlay.style.display = 'block';
            isSettingsMenuOpen = true;
            // Close other menus if open
            if (isPlanetListOpen) hidePlanetList();
            if (isSongListOpen) hideSongList();
            if (isVolumeSliderOpen) hideVolumeSlider();
            if (isZoomSliderOpen) hideZoomSlider();
            controls.enabled = false;
            document.addEventListener('click', handleOutsideSettingsInteraction, true);
            document.addEventListener('touchend', handleOutsideSettingsInteraction, true);
        }

        function showVolumeSlider() {
            volumeSliderContainer.style.display = 'block';
            isVolumeSliderOpen = true;
            if (isSettingsMenuOpen) hideSettingsMenu();
            if (isSongListOpen) hideSongList();
            if (isZoomSliderOpen) hideZoomSlider();
            controls.enabled = false;
            document.addEventListener('click', handleOutsideVolumeInteraction, true);
            document.addEventListener('touchend', handleOutsideVolumeInteraction, true);
        }

        function hideSettingsMenu() {
            settingsOverlay.style.display = 'none';
            isSettingsMenuOpen = false;
            if (!isCameraAnimating && !isViewLocked) {
                controls.enabled = true;
            }
            document.removeEventListener('click', handleOutsideSettingsInteraction, true);
            document.removeEventListener('touchend', handleOutsideSettingsInteraction, true);
        }

        function hideVolumeSlider() {
            volumeSliderContainer.style.display = 'none';
            isVolumeSliderOpen = false;
            if (!isCameraAnimating && !isViewLocked) {
                controls.enabled = true;
            }
            document.removeEventListener('click', handleOutsideVolumeInteraction, true);
            document.removeEventListener('touchend', handleOutsideVolumeInteraction, true);
        }

        function handleOutsideSettingsInteraction(event) {
            if (isSettingsMenuOpen && !settingsOverlay.contains(event.target) && !moreOptionsBtn.contains(event.target)) {
                hideSettingsMenu();
            }
        }

        function handleOutsideVolumeInteraction(event) {
            if (isVolumeSliderOpen && !volumeSliderContainer.contains(event.target) && !volumeBtn.contains(event.target)) {
                hideVolumeSlider();
            }
        }

        // New functions for zoom slider
        function showZoomSlider() {
            zoomSliderContainer.style.display = 'block';
            isZoomSliderOpen = true;
            // Close other menus
            if (isSettingsMenuOpen) hideSettingsMenu();
            if (isSongListOpen) hideSongList();
            if (isPlanetListOpen) hidePlanetList();
            if (isVolumeSliderOpen) hideVolumeSlider();
            controls.enabled = false;
            document.addEventListener('click', handleOutsideZoomInteraction, true);
            document.addEventListener('touchend', handleOutsideZoomInteraction, true);
        }

        function hideZoomSlider() {
            zoomSliderContainer.style.display = 'none';
            isZoomSliderOpen = false;
            if (!isCameraAnimating && !isViewLocked) {
                controls.enabled = true;
            }
            document.removeEventListener('click', handleOutsideZoomInteraction, true);
            document.removeEventListener('touchend', handleOutsideZoomInteraction, true);
        }

        function handleOutsideZoomInteraction(event) {
            if (isZoomSliderOpen && !zoomSliderContainer.contains(event.target) && !zoomBtn.contains(event.target)) {
                hideZoomSlider();
            }
        }

        moreOptionsBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            isSettingsMenuOpen ? hideSettingsMenu() : showSettingsMenu();
        });

        closeSettingsBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            hideSettingsMenu();
        });

        // Add event listener for the new orbit toggle button
        toggleOrbitsBtn.addEventListener('click', () => {
            areOrbitsVisible = !areOrbitsVisible; // Toggle the state

            // Apply the new visibility to all orbits
            scene.children.forEach(child => {
                if (child.userData.isOrbit) {
                    child.visible = areOrbitsVisible;
                }
            });

            // Update the button text
            toggleOrbitsLabel.textContent = areOrbitsVisible ? 'Ẩn Quỹ đạo' : 'Hiện Quỹ đạo';

            // Save the new setting
            saveSettings();
        });

        // Add event listener for the new visualizer toggle button
        toggleVisualizerBtn.addEventListener('click', () => {
            isVisualizerVisible = !isVisualizerVisible; // Toggle the state

            // Apply the new visibility to the current visualizer if it exists
            if (musicPlayerObject) {
                if (visualizerCanvas) {
                    visualizerCanvas.style.display = isVisualizerVisible ? 'block' : 'none';
                }
            }

            // Update the button text
            toggleVisualizerLabel.textContent = isVisualizerVisible ? 'Ẩn Sóng nhạc' : 'Hiện Sóng nhạc';

            // Save the new setting
            saveSettings();
        });

        // Add event listener for the new time display toggle button
        toggleTimeDisplayBtn.addEventListener('click', () => {
            isTimeDisplayVisible = !isTimeDisplayVisible;

            if (musicPlayerObject) {
                const timeContainer = musicPlayerObject.element.querySelector('.music-player-time');
                if (timeContainer) {
                    timeContainer.style.display = isTimeDisplayVisible ? 'flex' : 'none';
                }
            }

            toggleTimeDisplayLabel.textContent = isTimeDisplayVisible ? 'Ẩn Thời gian' : 'Hiện Thời gian';
            saveSettings();
        });

        // Add event listener for changing visualizer style
        if (changeVisualizerStyleBtn) {
            changeVisualizerStyleBtn.addEventListener('click', () => {
                currentVisualizerStyle = (currentVisualizerStyle + 1) % 6; // Cycle through 6 styles
                if (changeVisualizerStyleLabel) {
                    changeVisualizerStyleLabel.textContent = `Kiểu: ${visualizerStyleNames[currentVisualizerStyle]}`;
                }
                saveSettings();
            });
        }

        // Volume slider logic
        volumeBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            isVolumeSliderOpen ? hideVolumeSlider() : showVolumeSlider();
        });

        volumeSlider.addEventListener('input', () => {
            const volume = volumeSlider.value / 100;
            audioPlayer.volume = volume;
            updateVolumeIcon(volume);
            updateVolumeSliderVisual(volumeSlider.value);
            saveSettings();
        });

        // Zoom slider logic
        zoomBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            isZoomSliderOpen ? hideZoomSlider() : showZoomSlider();
        });

        zoomLevelSlider.addEventListener('input', () => {
            const fov = parseFloat(zoomLevelSlider.value);
            camera.fov = fov;
            camera.updateProjectionMatrix();
            updateZoomSliderVisual(fov);
            saveSettings();
        });

        function updateVolumeIcon(volume) {
            if (volume === 0) {
                volumeIcon.className = 'fas fa-volume-mute';
            } else if (volume < 0.5) {
                volumeIcon.className = 'fas fa-volume-down';
            } else {
                volumeIcon.className = 'fas fa-volume-up';
            }
        }

        function updateVolumeSliderVisual(value) {
            if (volumeSlider) {
                // The value is expected to be between 0 and 100
                volumeSlider.style.setProperty('--volume-progress', `${value}%`);
            }
        }

        function updateZoomSliderVisual(fov) {
            if (zoomLevelSlider) {
                const minFov = parseFloat(zoomLevelSlider.min);
                const maxFov = parseFloat(zoomLevelSlider.max);
                const percentage = ((maxFov - fov) / (maxFov - minFov)) * 100;
                zoomLevelSlider.style.setProperty('--zoom-progress', `${percentage}%`);
            }
        }

        // Slider functionalities
        zoomSlider.addEventListener('input', () => {
            const newMaxDistance = parseInt(zoomSlider.value);
            controls.maxDistance = newMaxDistance;
            zoomValue.textContent = newMaxDistance.toLocaleString('en-US') + 'x';
            saveSettings();
        });

        radiusSlider.addEventListener('input', () => {
            const value = parseFloat(radiusSlider.value).toFixed(2);
            radiusValue.textContent = value;
        });
        radiusSlider.addEventListener('change', () => {
            regenerateStarfield(currentStarCount, parseFloat(radiusSlider.value));
            saveSettings();
        });

        densitySlider.addEventListener('input', () => {
            densityValue.textContent = parseInt(densitySlider.value).toLocaleString('en-US');
        });
        densitySlider.addEventListener('change', () => {
            regenerateStarfield(parseInt(densitySlider.value), currentRadiusMultiplier);
            saveSettings();
        });

        speedSlider.addEventListener('input', () => {
            const value = parseFloat(speedSlider.value);
            planetSpeedMultiplier = value;
            speedValue.textContent = value.toFixed(2);
            saveSettings();
        });

        // --- Toggle Images ---
        const toggleImagesBtn = document.getElementById('toggle-images-btn');
        let isGlobalToggleInHideMode = true; // Tracks the state of the global toggle
        const planetsHiddenByGlobalToggle = new Set(); // Stores planets whose images were hidden by the toggle
        let isFirstImageLoad = true; // New flag to track the very first image load

        toggleImagesBtn.addEventListener('click', () => {
            isGlobalToggleInHideMode = !isGlobalToggleInHideMode;

            if (isGlobalToggleInHideMode) {
                // HIDE mode: Find all planets with visible images, remember them, and hide their images.
                planetsHiddenByGlobalToggle.clear(); // Reset before hiding
                planets.forEach(planet => {
                    if (planet.userData.imageGroup && planet.userData.imageGroup.visible) {
                        planetsHiddenByGlobalToggle.add(planet); // Remember this planet was hidden by the global toggle
                        planet.userData.imageGroup.visible = false;
                    }
                });
                toggleImagesBtn.textContent = 'Hiện Ảnh';
            } else {
                if (isFirstImageLoad) {
                    // SHOW mode (FIRST TIME): Asynchronously create images with a loading screen
                    const planetsToShow = [];
                    planets.forEach(planet => {
                        if (planet.userData.interactionState !== 3) {
                            planetsToShow.push(planet);
                        }
                    });

                    if (planetsToShow.length === 0) {
                        planetsHiddenByGlobalToggle.clear();
                        toggleImagesBtn.textContent = 'Tắt Ảnh';
                        isFirstImageLoad = false; // Still mark as loaded even if there was nothing to show
                        return;
                    }

                    const imageLoaderOverlay = document.getElementById('image-loader-overlay');
                    const imageProgressText = document.getElementById('image-progress-text');
                    const imageProgressCircle = imageLoaderOverlay.querySelector('.progress-circle');
                    imageLoaderOverlay.style.display = 'flex';
                    controls.enabled = false;

                    let planetsProcessed = 0;
                    const totalPlanets = planetsToShow.length;

                    function processNextPlanet() {
                        if (planetsProcessed >= totalPlanets) {
                            imageLoaderOverlay.style.display = 'none';
                            if (!isCameraAnimating && !isViewLocked) {
                                controls.enabled = true;
                            }
                            planetsHiddenByGlobalToggle.clear();
                            toggleImagesBtn.textContent = 'Tắt Ảnh';
                            isFirstImageLoad = false; // Set flag to false after first load is complete
                            return;
                        }

                        const planet = planetsToShow[planetsProcessed];
                        addImagesToPlanet(planet);

                        planetsProcessed++;

                        const progress = (planetsProcessed / totalPlanets) * 100;
                        const percentage = Math.round(progress);
                        imageProgressText.textContent = `${percentage}%`;
                        imageProgressCircle.style.background = `conic-gradient(#3498db ${progress}%, #1a1a1a 0%)`;

                        setTimeout(processNextPlanet, 16);
                    }

                    imageProgressText.textContent = `0%`;
                    imageProgressCircle.style.background = `conic-gradient(#3498db 0%, #1a1a1a 0%)`;
                    setTimeout(processNextPlanet, 16);
                } else {
                    // SHOW mode (SUBSEQUENT TIMES): Instantly show existing images
                    planetsHiddenByGlobalToggle.forEach(planet => {
                        if (planet.userData.interactionState !== 3) {
                            addImagesToPlanet(planet); // This will just make the existing group visible
                        }
                    });
                    planetsHiddenByGlobalToggle.clear();
                    toggleImagesBtn.textContent = 'Tắt Ảnh';
                }
            }
        });

        // --- Toggle Planet Labels ---
        const toggleLabelsBtn = document.getElementById('toggle-labels-btn');
        toggleLabelsBtn.addEventListener('click', () => {
            const labels = document.querySelectorAll('.planet-label');
            // Check the state of the first label to determine the current state
            const isCurrentlyHidden = labels.length > 0 && labels[0].classList.contains('hidden');
            
            labels.forEach(label => {
                label.classList.toggle('hidden');
            });

            // Update button text based on the *previous* state
            toggleLabelsBtn.textContent = isCurrentlyHidden ? 'Ẩn tên' : 'Hiện tên';
        });
        
        // --- Music Player Logic ---
        // --- CẤU HÌNH NHẠC ---
        // 1. Đặt tên các file nhạc của bạn theo thứ tự: music1.mp3, music2.mp3, ... và đặt chúng vào thư mục 'music'.
        // 2. Cập nhật số `totalMusicFiles` dưới đây cho khớp với tổng số file nhạc bạn có. (Hiện tại là 93)
        const totalMusicFiles = 93; 

        // Tự động tạo danh sách bài hát. Sau này bạn có thể gán tên cụ thể cho từng bài.
        const songs = [];
        for (let i = 1; i <= totalMusicFiles; i++) {
            let songName;
            switch (i) {
                case 1: songName = "Đi Cùng Anh - buitruonglinh, 52Hz"; break;
                case 2: songName = "BABY LAVIEM - BigWind, KA"; break;
                case 3: songName = "Anh Chưa Từng Hết Yêu - buitruonglinh"; break;
                case 4: songName = "Giờ Thì - buitruonglinh"; break;
                case 5: songName = "Intro (Mong Em Hạnh Phúc Suốt Cuộc Đời Này) - buitruonglinh"; break;
                case 6: songName = "VƯỚNG VÂN - Côngg, Clow"; break;
                case 7: songName = "Khiêu Vũ - inari, Côngg"; break;
                case 8: songName = "ĐỢI - 52Hz"; break;
                case 9: songName = "ĐEN ĐÁ KHÔNG ĐƯỜNG - AMEE"; break;
                case 10: songName = "Ex's Hate Me (Part 2) - AMEE, B RAY"; break;
                case 11: songName = "MỘNG YU - AMEE, MCK"; break;
                case 12: songName = "Chờ Anh Về - (Không rõ nghệ sĩ)"; break;
                case 13: songName = "Nghe kể năm 90s - Ân ngờ, Suzie MK"; break;
                case 14: songName = "Hà Nội - Obito, VSTRA"; break;
                case 15: songName = "Sài Gòn ơi - Obito"; break;
                case 16: songName = "Wrong Times - Puppy, Dangrangto, FOWLEX Snowz"; break;
                case 17: songName = "Xích Thêm Chút (Remix) - RPT Groovie, tlinh, RPT MCK"; break;
                case 18: songName = "Vạn vật như muốn ta bên nhau - RIO"; break;
                case 19: songName = "50-50 (Interlude) - RPT MCK"; break;
                case 20: songName = "GIAYPHUT - kidsai, Niz"; break;
                case 21: songName = "NGÂY THER - kidsai, VSTRA"; break;
                case 22: songName = "1-2 - Dangrangto, BIG WIND, Lee À"; break;
                case 23: songName = "0.2 in the end - Lil Liem, KIDDI"; break;
                case 24: songName = "Chấp Niệm - ZAROS, Lil Liem"; break;
                case 25: songName = "Em đi đi - Lil Liem, BIG WIND"; break;
                case 26: songName = "id 072019 (3107) - W-n, 267"; break;
                case 27: songName = "Ayye - (Không rõ nghệ sĩ)"; break;
                case 28: songName = "Đóa Hoa - BigWind, TeuYungBoy"; break;
                case 29: songName = "Perfect - Shiki, Tyronee"; break;
                case 30: songName = "Night Time - Shiki"; break;
                case 31: songName = "Lặng - Shiki"; break;
                case 32: songName = "id 072019 (3107) - W-n, 267"; break;
                case 33: songName = "id THANG MÁY - W-n, 267"; break;
                case 34: songName = "0 AI NGHĨ - Wxrdie, Machiot"; break;
                case 35: songName = "Bước Za Đi Xa - Wxrdie"; break;
                case 36: songName = "ghệ iu dấu của em ơi - tlinh, 2pillz, wokeup"; break;
                case 37: songName = "GIẤC MƠ - MiQ"; break;
                case 38: songName = "Chăm Hoa - MONO"; break;
                case 39: songName = "Em Là - MONO"; break;
                case 40: songName = "Em Xinh - MONO"; break;
                case 41: songName = "Crush 2 - W-n, Tez, Tien"; break;
                case 42: songName = "Crush - W-n, An An, Vani"; break;
                case 43: songName = "3107 7 - W-n, titie, Duongg"; break;
                case 44: songName = "3107 3 - W-n, 267, Nâu, Duongg"; break;
                case 45: songName = "Hồng không gai - Winno, SpideyBoy"; break;
                case 46: songName = "Không Yêu Em Thì Yêu Ai - Vũ., Low G"; break;
                case 47: songName = "So Bad - VSTRA"; break;
                case 48: songName = "MỜI EM - Wxrdie, Mcee Blue"; break;
                case 49: songName = "LONELY STONIE - Wxrdie"; break;
                case 50: songName = "LỐI SỐNG - Wxrdie"; break;
                case 51: songName = "LÂU ĐÀI - Wxrdie, Flava Sati"; break;
                case 52: songName = "GIA TÀI - Wxrdie, BABY $MOKE"; break;
                case 53: songName = "ĐẾN THĂM ANH ĐI - Wxrdie"; break;
                case 54: songName = "CA KHÚC CUỐI - Wxrdie"; break;
                case 55: songName = "Có Đôi Điều - Shiki"; break;
                case 56: songName = "Anh Vẫn Đợi - Shiki"; break;
                case 57: songName = "1000 Ánh Mắt - Shiki, Obito"; break;
                case 58: songName = "iu bạn mình - Shayda"; break;
                case 59: songName = "Nắng có mang em về - Shartnuss, Tr.D, Phankeo"; break;
                case 60: songName = "Thôi Em Đừng Đi - RPT MCK, Trung Trần"; break;
                case 61: songName = "Thờ Er - RPT MCK"; break;
                case 62: songName = "PHONG - VSTRA, TGSN, Tyronee"; break;
                case 63: songName = "Thích Quá Rùi Nà - tlinh, Trung Trần"; break;
                case 64: songName = "PHÓNG ZÌN ZÌN - Low G, tlinh"; break;
                case 65: songName = "nếu lúc đó - tlinh, 2pillz"; break;
                case 66: songName = "GIAYPHUT - kidsai, Niz"; break;
                case 67: songName = "In another life, maybe it was you and me, where we loved each other - Lil Liem"; break;
                case 68: songName = "MƯA RƠI VÀO PHÒNG - Khởi My"; break;
                case 69: songName = "DỄ THƯƠNG - Khởi My"; break;
                case 70: songName = "Đã Lỡ Yêu Em Nhiều - JustaTee"; break;
                case 71: songName = "KHÔNG BUÔNG - Hngle, Ari"; break;
                case 72: songName = "23:40 - Hào"; break;
                case 73: songName = "vaicaunoicokhiennguoithaydoi - GREY D, tlinh"; break;
                case 74: songName = "VẾT THƯƠNG - fishy"; break;
                case 75: songName = "KHÔNG ĐAU NỮA RỒI - 52Hz, Pháp Kiều, Mỹ Mỹ, Châu Bùi, Orange"; break;
                case 76: songName = "BÊN ANH - EREN, Lil Liem"; break;
                case 77: songName = "SugarMommy - inari, Côngg"; break;
                case 78: songName = "Nói Dối - inari, Côngg"; break;
                case 79: songName = "Simp Gái 808 - Low G"; break;
                case 80: songName = "In Love - Low G, JustaTee"; break;
                case 81: songName = "uocgianhaynoiyeutoi - Lil Liem"; break;
                case 82: songName = "hãy cho con chịu đau khổ thay em - EREN, Lil Liem"; break;
                case 83: songName = "TẠI VÌ SAO - RPT MCK"; break;
                case 84: songName = "Show Me Love - RPT MCK"; break;
                case 85: songName = "Chìm Sâu - RPT MCK, Trung Trần"; break;
                case 86: songName = "Chỉ Một Đêm Nữa Thôi - RPT MCK, tlinh"; break;
                case 87: songName = "Anh Đã Ổn Hơn - RPT MCK"; break;
                case 88: songName = "GIẤC MƠ - MiQ"; break;
                case 89: songName = "Phép Màu - Mounter, MAYDAYs, Minh Tốc"; break;
                case 90: songName = "Và Thế Giới Đã Mất Đi Một Người Cô Đơn"; break;
                case 91: songName = "Vì Anh Đâu Có Biết - Madihu, Vũ."; break;
                case 92: songName = "Có em - Madihu, Low G"; break;
                case 93: songName = "An Thần - Low G, Thắng"; break;
                default: songName = `Bài hát ${i}`; // Fallback for any unexpected index
            }
            songs.push({
                id: i,
                name: songName,
                file: `music/music${i}.mp3`
            });
        }

        const audioPlayer = document.getElementById('background-music');
        const selectSongBtn = document.getElementById('select-song-btn');
        const songListOverlay = document.getElementById('song-list-overlay');
        const clearQueueBox = document.getElementById('clear-queue-box');
        const songSelectionList = document.getElementById('song-selection-list');
        const closeSongMenuBtn = document.getElementById('close-song-menu-btn');
        const songSearchInput = document.getElementById('song-search-input');
        let isSongListOpen = false;
        let songQueue = []; // Queue for songs
        let isPlanetListOpen = false; // New: Track if planet list is open
        // Global variables for audio visualization
        let audioContext = null;
        let analyser = null;
        let dataArray = null;
        let bufferLength = null;
        let audioSource = null; // To hold the MediaElementSourceNode
        
        // Global flags for autoplay handling
        let hasUserInteracted = false;
        let songToPlayAfterInteraction = null; // Stores the file path of the song to play

        // Function to attempt playing a queued song after user interaction
        function attemptPlayQueuedSong() {
            if (songToPlayAfterInteraction) { // Check if there's a song queued
                // Always try to resume AudioContext if it's not already running
                if (audioContext && audioContext.state !== 'running') {
                    audioContext.resume().then(() => {
                        console.log("AudioContext resumed by user interaction.");
                        // Now try to play the audio element
                        audioPlayer.play().catch(error => {
                            console.error("Failed to play queued song after AudioContext resume:", error);
                        });
                    }).catch(error => {
                        console.error("Failed to resume AudioContext:", error);
                    }).finally(() => {
                        songToPlayAfterInteraction = null; // Clear the queue regardless of play success
                    });
                } else {
                    // If AudioContext is already running or doesn't exist, just try to play the audio element
                    audioPlayer.play().catch(error => {
                        console.error("Failed to play queued song (AudioContext not suspended):", error);
                    }).finally(() => {
                        songToPlayAfterInteraction = null; // Clear the queue regardless of play success
                    });
                }
            }
        }
        
        // Setup a one-time global interaction listener
        const onFirstInteraction = () => {
            // Check if the audio player is currently paused and a song is queued.
            // This prevents trying to play if a song is already playing or no song is queued.
            // However, the `attemptPlayQueuedSong` already handles `songToPlayAfterInteraction`.
            // The main purpose of this listener is to trigger the `resume` and `play` attempts.
            // So, we should always call `attemptPlayQueuedSong` if `hasUserInteracted` is false.

            if (!hasUserInteracted) {
                hasUserInteracted = true;
                attemptPlayQueuedSong();
                document.removeEventListener('click', onFirstInteraction);
                document.removeEventListener('touchend', onFirstInteraction);
                console.log("First user interaction detected, attempting to play queued song.");
            }
        };
        document.addEventListener('click', onFirstInteraction);
        document.addEventListener('touchend', onFirstInteraction);

        // References for the new 2D music controls
        const musicControls2D = document.getElementById('music-controls-2d');
        const prevBtn2D = document.getElementById('music-player-prev-2d');
        const playPauseBtn2D = document.getElementById('music-player-play-pause-2d');
        const nextBtn2D = document.getElementById('music-player-next-2d');
        const progressContainer2D = document.getElementById('music-player-progress-container-2d');
        const progressBar2D = document.getElementById('music-player-progress-bar-2d');
        const musicPlayerSongTitle2D = document.getElementById('music-player-song-title-2d'); // Tham chiếu đến tên bài hát 2D
        const progressHandle2D = document.getElementById('music-player-progress-handle-2d'); // Tham chiếu đến chấm kéo mới
        // New variables for the 3D music player
        let musicPlayerObject = null;
        let currentSongIndex = -1;
        // Biến cho hiệu ứng trôi nổi của trình phát nhạc
        const musicPlayerFloatInfo = {
            enabled: true, // Cờ để bật/tắt hiệu ứng trôi nổi
            overviewPosition: new THREE.Vector3(0, 50, -800), // Vị trí cố định ở chế độ Toàn cảnh (X=0 để căn giữa)
            targetOffset: new THREE.Vector3(0, 0, 0), // Offset ngẫu nhiên so với vị trí camera-relative
            timeToNewTarget: 0, // Sẽ được đặt khi chạy lần đầu, buộc phải có mục tiêu mới ngay lập tức
            lerpAlpha: 0.02, // Tốc độ di chuyển đến mục tiêu. Cần cao hơn vì mục tiêu di chuyển mỗi khung hình.
            movementRadius: 150, // Bán kính của khu vực trôi nổi (tương đối so với camera)
            minTargetChangeTime: 5000, // Thời gian tối thiểu trước khi đổi mục tiêu (5 giây)
            maxTargetChangeTime: 10000 // Thời gian tối đa trước khi đổi mục tiêu (10 giây)
        };

        function setNewMusicPlayerTarget() {
            const radius = musicPlayerFloatInfo.movementRadius;
            // Tạo một điểm ngẫu nhiên trên một đĩa 2D để có hiệu ứng trôi nổi trên màn hình
            const r = radius * Math.sqrt(Math.random()); // Phân bố đồng đều trên đĩa
            const theta = Math.random() * 2 * Math.PI;
            
            const x = r * Math.cos(theta);
            const y = r * Math.sin(theta);
            const z = (Math.random() - 0.5) * 50; // Thêm một chút biến thiên độ sâu ngẫu nhiên

            musicPlayerFloatInfo.targetOffset.set(x, y, z);
            
            // Đặt thời gian cho lần thay đổi mục tiêu tiếp theo
            const timeRange = musicPlayerFloatInfo.maxTargetChangeTime - musicPlayerFloatInfo.minTargetChangeTime;
            musicPlayerFloatInfo.timeToNewTarget = Date.now() + musicPlayerFloatInfo.minTargetChangeTime + Math.random() * timeRange;
        }

        // Playback mode variables
        let playbackMode = 'sequential'; // 'repeat-one', 'sequential', 'random'
        let shuffledSongIndices = [];
        let currentShuffledIndex = -1;
        // References for the visualizer canvas within the 3D player
        let visualizerCanvas = null;
        let visualizerCtx = null;

        // Variables for visualizer color change speed
        let lastColorChangeTime = 0; // Thời điểm cuối cùng màu sắc được thay đổi
        const colorChangeIntervalMs = 2000; // Thời gian giữa các lần bắt đầu chuyển màu (2 giây)
        const colorTransitionDurationMs = 1000; // Thời gian để hoàn thành một quá trình chuyển màu (1 giây)

        let currentHueValue = 180; // Giá trị sắc độ (hue) hiện tại đang được hiển thị (0-359)
        let startTransitionHue = 180; // Giá trị sắc độ khi bắt đầu một quá trình chuyển đổi
        let targetTransitionHue = 180; // Giá trị sắc độ mục tiêu của quá trình chuyển đổi
        let transitionStartTime = 0; // Thời điểm bắt đầu quá trình chuyển đổi màu
        let transitionActive = false; // Cờ báo hiệu quá trình chuyển đổi đang diễn ra

        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 128; // Giảm FFT size để có ít thanh hơn, mỗi thanh rộng hơn và rõ ràng hơn
                analyser.smoothingTimeConstant = 0.8; // Giảm độ mượt một chút để sóng phản ứng nhanh và nảy hơn theo nhịp
                bufferLength = analyser.frequencyBinCount; // Half of fftSize
                dataArray = new Uint8Array(bufferLength);

                audioSource = audioContext.createMediaElementSource(audioPlayer);
                audioSource.connect(analyser);
                analyser.connect(audioContext.destination);
            }
        }

        function playSong(file) {
            initAudioContext(); // Ensure AudioContext is initialized

            audioPlayer.src = file;

            // Attempt to play. If it fails, queue it for later.
            audioPlayer.play().then(() => { // This .then() block is executed if autoplay is successful
                console.log("Autoplay successful.");
                songToPlayAfterInteraction = null; // Clear if successful
                // Ensure AudioContext is running if play was successful
                if (audioContext && audioContext.state !== 'running') {
                    audioContext.resume().catch(error => {
                        console.error("Failed to resume AudioContext after successful play:", error);
                    });
                }
            }).catch(error => {
                // This .catch() block is executed if autoplay is blocked or fails
                // This is where we queue the song for later interaction
                console.log("Autoplay blocked or failed. Queuing for first user interaction.", error);
                if (!hasUserInteracted) {
                    songToPlayAfterInteraction = file; // Only queue if no user interaction has happened yet
                } else {
                    // If play fails even after user interaction (e.g., from 'ended' event),
                    // it might be due to AudioContext being suspended again.
                    console.error(`[playSong] Play failed for ${file} even after user interaction. Attempting to resume AudioContext and retry.`, error);
                    if (audioContext && audioContext.state !== 'running') {
                        audioContext.resume().then(() => {
                            console.log("[playSong] AudioContext resumed, retrying play.");
                            audioPlayer.play().catch(retryError => console.error("[playSong] Retry play failed after AudioContext resume:", retryError));
                        }).catch(resumeError => console.error("[playSong] Failed to resume AudioContext during retry:", resumeError));
                    } else {
                        console.warn("[playSong] AudioContext not suspended, but play failed after user interaction. Browser might be blocking for other reasons.");
                    }
                }
            });
        }

        // --- Song List Overlay Logic ---
        const repeatOneBtn = document.getElementById('repeat-one-btn');
        const sequentialBtn = document.getElementById('sequential-btn');
        const shuffleBtn = document.getElementById('shuffle-btn');
        songSearchInput.addEventListener('input', populateSongList);

        function populateSongList() {
            const query = songSearchInput.value.toLowerCase().trim();
            songSelectionList.innerHTML = ''; // Clear previous list
            const currentPlayingSong = songs[currentSongIndex];

            songs.forEach(song => {
                // Filter logic: if query exists and song name doesn't include it, skip
                if (query && !song.name.toLowerCase().includes(query)) {
                    return;
                }

                const listItem = document.createElement('li');
                listItem.className = 'song-list-item';
                listItem.style.display = 'flex';
                listItem.style.alignItems = 'center';
                listItem.style.justifyContent = 'space-between';

                const textDiv = document.createElement('div');
                textDiv.style.pointerEvents = 'none'; // Allow clicks to pass through

                // Highlight the currently playing song by comparing objects or IDs
                if (currentPlayingSong && song.id === currentPlayingSong.id) {
                    listItem.classList.add('current-song');
                }

                // Split the song name into title and artist(s)
                const parts = song.name.split(' - ', 2);
                if (parts.length > 1) {
                    const songTitleSpan = document.createElement('span');
                    songTitleSpan.textContent = `${song.id}. ${parts[0]}`;
                    songTitleSpan.style.fontWeight = 'bold';
                    textDiv.appendChild(songTitleSpan);

                    const artistSpan = document.createElement('span');
                    artistSpan.textContent = ` - ${parts[1]}`;
                    artistSpan.classList.add('artist-name');
                    textDiv.appendChild(artistSpan);
                } else {
                    const songTitleSpan = document.createElement('span');
                    songTitleSpan.textContent = `${song.id}. ${song.name}`;
                    songTitleSpan.style.fontWeight = 'bold';
                    textDiv.appendChild(songTitleSpan);
                }
                listItem.appendChild(textDiv);

                // Queue Badge
                const songIndex = song.id - 1; // 0-based index
                const queuePos = songQueue.indexOf(songIndex);
                if (queuePos !== -1) {
                    const badge = document.createElement('span');
                    badge.className = 'queue-badge';
                    badge.textContent = queuePos + 1;
                    listItem.appendChild(badge);
                }

                // Interaction Logic
                let pressTimer;
                let isLongPress = false;

                const startPress = (e) => {
                    if (e.type === 'mousedown' && e.button !== 0) return;
                    isLongPress = false;
                    pressTimer = setTimeout(() => {
                        isLongPress = true;
                        toggleQueue(songIndex);
                        if (navigator.vibrate) navigator.vibrate(50);
                    }, 500);
                };

                const cancelPress = () => {
                    clearTimeout(pressTimer);
                };

                const handleClick = (e) => {
                    if (isLongPress) {
                        e.preventDefault();
                        e.stopPropagation();
                        return;
                    }
                    showMusicPlayer(songIndex);
                    hideSongList(); // Close the selection menu
                };

                listItem.addEventListener('mousedown', startPress);
                listItem.addEventListener('touchstart', startPress, { passive: true });
                listItem.addEventListener('mouseup', cancelPress);
                listItem.addEventListener('mouseleave', cancelPress);
                listItem.addEventListener('touchend', cancelPress);
                listItem.addEventListener('touchmove', cancelPress);
                listItem.addEventListener('click', handleClick);

                songSelectionList.appendChild(listItem);
            });
        }

        function toggleQueue(index) {
            const pos = songQueue.indexOf(index);
            if (pos === -1) {
                songQueue.push(index);
            } else {
                songQueue.splice(pos, 1);
            }
            populateSongList();
        }

        function showSongList() {
            songListOverlay.style.display = 'flex';
            isSongListOpen = true;
            if (isPlanetListOpen) { // Nếu danh sách hành tinh đang mở, đóng nó lại
                hidePlanetList();
            }
            if (isZoomSliderOpen) hideZoomSlider();
            if (isSettingsMenuOpen) hideSettingsMenu();
            if (isVolumeSliderOpen) hideVolumeSlider();
            
            if (clearQueueBox.style.display === 'flex') {
                clearQueueBox.style.display = 'none';
            }

            // musicControls2D.style.display = 'none'; // Removed: Keep 2D music controls visible when song list is open
            controls.enabled = false; // Tắt điều khiển 3D khi mở danh sách nhạc
            populateSongList();

            // Add global listener to close menu
            document.addEventListener('click', handleOutsideSongInteraction, true);
            document.addEventListener('touchend', handleOutsideSongInteraction, true);
            // songSearchInput.focus();

            // Scroll to the currently playing song after a short delay.
            // This ensures it happens after the DOM is updated and focus is set, preventing conflicts.
            setTimeout(() => {
                const currentSongItem = songSelectionList.querySelector('.current-song');
                if (currentSongItem) {
                    currentSongItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 0);
        }

        function hideSongList() {
            songListOverlay.style.display = 'none';
            isSongListOpen = false;
            if (currentSongIndex !== -1) musicControls2D.style.display = 'flex'; // Show 2D controls if a song is selected
            // Chỉ kích hoạt lại controls nếu không có hoạt ảnh camera nào đang diễn ra và chế độ xem không bị khóa
            if (!isCameraAnimating && !isViewLocked) {
                controls.enabled = true;
            }
            // Remove global listener
            document.removeEventListener('click', handleOutsideSongInteraction, true);
            document.removeEventListener('touchend', handleOutsideSongInteraction, true);
            songSearchInput.value = ''; // Clear search input
        }

        function handleOutsideSongInteraction(event) {
            if (isSongListOpen && !songListOverlay.contains(event.target) && !selectSongBtn.contains(event.target)) {
                hideSongList();
            }
        }

        // --- Logic nhấn giữ nút Chọn nhạc để hủy Queue ---
        let songBtnPressTimer;
        let isSongBtnLongPress = false;

        function renderQueueBox() {
            clearQueueBox.innerHTML = '';
            
            if (songQueue.length === 0) {
                clearQueueBox.style.justifyContent = 'center';
                clearQueueBox.innerHTML = '<span>Không có danh sách phát nào</span><br><button id="btn-close-queue-empty" style="margin-top: 15px; background: transparent; border: 1px solid white; color: white; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-family: inherit; font-size: 10px;">Thoát</button>';
                document.getElementById('btn-close-queue-empty').onclick = (e) => { e.stopPropagation(); clearQueueBox.style.display = 'none'; };
                clearQueueBox.style.cursor = 'default';
                return;
            }

            clearQueueBox.style.justifyContent = 'flex-start';
            
            const title = document.createElement('div');
            title.style.cssText = 'text-align: center; margin-bottom: 10px; font-weight: bold; font-size: 18px; flex-shrink: 0;';
            title.textContent = 'Danh sách phát riêng';
            clearQueueBox.appendChild(title);

            const listContainer = document.createElement('div');
            listContainer.style.cssText = 'flex-grow: 1; width: 100%; overflow-y: auto; text-align: left; margin-bottom: 15px; padding-right: 5px; font-size: 14px;';
            
            const queueItemsSelected = new Set();
            const actionBtn = document.createElement('button');
            
            const updateActionButton = () => {
                if (queueItemsSelected.size > 0) {
                    actionBtn.textContent = 'Xóa khỏi danh sách';
                    actionBtn.style.background = 'rgba(0, 255, 255, 0.3)';
                    actionBtn.style.borderColor = '#00ffff';
                    actionBtn.style.color = '#00ffff';
                } else {
                    actionBtn.textContent = 'Hủy danh sách';
                    actionBtn.style.background = 'rgba(255, 0, 0, 0.6)';
                    actionBtn.style.borderColor = '#ff4d4d';
                    actionBtn.style.color = 'white';
                }
            };

            songQueue.forEach((songIndex, i) => {
                const songName = songs[songIndex].name;
                const itemDiv = document.createElement('div');
                itemDiv.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 2px; transition: all 0.2s; cursor: pointer;';
                
                const textSpan = document.createElement('span');
                textSpan.style.cssText = 'white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-right: 5px;';
                textSpan.textContent = `${i + 1}. ${songName}`;
                itemDiv.appendChild(textSpan);

                const badge = document.createElement('span');
                badge.className = 'queue-badge';
                badge.textContent = songIndex + 1;
                itemDiv.appendChild(badge);
                
                let itemPressTimer;
                let isItemLongPress = false;

                const startItemPress = (e) => {
                    if (e.type === 'mousedown' && e.button !== 0) return;
                    isItemLongPress = false;
                    itemPressTimer = setTimeout(() => {
                        isItemLongPress = true;
                        if (queueItemsSelected.has(songIndex)) {
                            queueItemsSelected.delete(songIndex);
                            itemDiv.style.color = 'white';
                            itemDiv.style.borderBottomColor = 'rgba(255,255,255,0.1)';
                        } else {
                            queueItemsSelected.add(songIndex);
                            itemDiv.style.color = '#00ffff';
                            itemDiv.style.borderBottomColor = '#00ffff';
                        }
                        updateActionButton();
                        if (navigator.vibrate) navigator.vibrate(50);
                    }, 500);
                };

                const cancelItemPress = () => { clearTimeout(itemPressTimer); };

                itemDiv.addEventListener('mousedown', startItemPress);
                itemDiv.addEventListener('touchstart', startItemPress, { passive: true });
                itemDiv.addEventListener('mouseup', cancelItemPress);
                itemDiv.addEventListener('mouseleave', cancelItemPress);
                itemDiv.addEventListener('touchend', cancelItemPress);
                
                itemDiv.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (isItemLongPress) { isItemLongPress = false; return; }
                    if (queueItemsSelected.size > 0) {
                        if (queueItemsSelected.has(songIndex)) {
                            queueItemsSelected.delete(songIndex);
                            itemDiv.style.color = 'white';
                            itemDiv.style.borderBottomColor = 'rgba(255,255,255,0.1)';
                        } else {
                            queueItemsSelected.add(songIndex);
                            itemDiv.style.color = '#00ffff';
                            itemDiv.style.borderBottomColor = '#00ffff';
                        }
                        updateActionButton();
                    }
                });

                listContainer.appendChild(itemDiv);
            });
            clearQueueBox.appendChild(listContainer);

            const btnContainer = document.createElement('div');
            btnContainer.style.cssText = 'display: flex; justify-content: center; gap: 15px; flex-shrink: 0;';

            actionBtn.style.cssText = 'background: rgba(255, 0, 0, 0.6); border: 1px solid #ff4d4d; color: white; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-family: inherit; font-size: 10px;';
            actionBtn.textContent = 'Hủy danh sách';
            actionBtn.onclick = (e) => {
                e.stopPropagation();
                if (queueItemsSelected.size > 0) {
                    songQueue = songQueue.filter(idx => !queueItemsSelected.has(idx));
                    populateSongList();
                    renderQueueBox();
                } else {
                    songQueue = [];
                    populateSongList();
                    clearQueueBox.style.display = 'none';
                }
            };
            btnContainer.appendChild(actionBtn);

            const closeBtn = document.createElement('button');
            closeBtn.style.cssText = 'background: transparent; border: 1px solid white; color: white; padding: 2px 6px; border-radius: 3px; cursor: pointer; font-family: inherit; font-size: 10px;';
            closeBtn.textContent = 'Thoát';
            closeBtn.onclick = (e) => { e.stopPropagation(); clearQueueBox.style.display = 'none'; };
            btnContainer.appendChild(closeBtn);

            clearQueueBox.appendChild(btnContainer);
            clearQueueBox.style.cursor = 'default';
        }

        const startSongBtnPress = (e) => {
            if (e.type === 'mousedown' && e.button !== 0) return;
            isSongBtnLongPress = false;
            songBtnPressTimer = setTimeout(() => {
                isSongBtnLongPress = true;
                
                if (isSongListOpen) {
                    hideSongList();
                }

                renderQueueBox();

                clearQueueBox.style.display = 'flex'; // Hiện box hủy
                if (navigator.vibrate) navigator.vibrate(50);
            }, 500);
        };

        const cancelSongBtnPress = () => {
            clearTimeout(songBtnPressTimer);
        };

        selectSongBtn.addEventListener('mousedown', startSongBtnPress);
        selectSongBtn.addEventListener('touchstart', startSongBtnPress, { passive: true });
        selectSongBtn.addEventListener('mouseup', cancelSongBtnPress);
        selectSongBtn.addEventListener('mouseleave', cancelSongBtnPress);
        selectSongBtn.addEventListener('touchend', cancelSongBtnPress);

        selectSongBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            if (isSongBtnLongPress) { isSongBtnLongPress = false; return; } // Nếu là nhấn giữ thì không mở menu
            if (isSongListOpen) {
                hideSongList();
            } else {
                if (isPlanetListOpen) { // Nếu danh sách hành tinh đang mở, đóng nó lại
                    hidePlanetList();
                }
                if (isZoomSliderOpen) {
                    hideZoomSlider();
                }
                if (isVolumeSliderOpen) hideVolumeSlider();
                if (isSettingsMenuOpen) { // Nếu menu cài đặt đang mở, đóng nó lại
                    hideSettingsMenu();
                }
                showSongList();
            }
        });

        document.addEventListener('click', (e) => {
            if (clearQueueBox.style.display === 'flex' && !clearQueueBox.contains(e.target)) {
                clearQueueBox.style.display = 'none';
            }
        });

        closeSongMenuBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            hideSongList();
        });

        // --- 2D Music Controls Logic ---

        function applyScrollingToTitle2D(titleElement, songName) {
            // Ensure container is empty
            while (titleElement.firstChild) {
                titleElement.removeChild(titleElement.firstChild);
            }
        
            // Create new scrolling elements
            const scrollContainer = document.createElement('div');
            scrollContainer.className = 'music-player-title-scroll-container-2d';
            
            const titleText1 = document.createElement('span');
            titleText1.textContent = songName;
            titleText1.style.display = 'inline-block';
        
            scrollContainer.appendChild(titleText1);
            titleElement.appendChild(scrollContainer);
        
            // Xóa mọi trạng thái hoạt ảnh trước đó
            titleElement.classList.remove('scrolling');
            titleElement.style.removeProperty('--scroll-start');
            titleElement.style.removeProperty('--scroll-end');
            titleElement.style.removeProperty('--scroll-duration');
            
            // Cần đợi DOM cập nhật để có chiều rộng chính xác
            setTimeout(() => {
                const containerWidth = titleElement.offsetWidth; // Chiều rộng của container hiển thị
                const textWidth = titleText1.offsetWidth; // Chiều rộng thực tế của văn bản
            
                // Chỉ cuộn nếu văn bản tràn ra ngoài container
                if (textWidth > containerWidth) {
                    // Tạo và thêm văn bản trùng lặp để tạo vòng lặp liền mạch
                    const titleText2 = document.createElement('span');
                    titleText2.textContent = songName;
                    titleText2.style.display = 'inline-block';
                    titleText2.style.paddingLeft = '50px'; // Khoảng cách giữa các văn bản
                    scrollContainer.appendChild(titleText2);
                
                    // Tổng khoảng cách cuộn cho một chu kỳ đầy đủ (văn bản gốc + khoảng đệm)
                    const totalScrollDistance = textWidth + 50;
                
                    const scrollStart = 0; // Bắt đầu từ vị trí 0
                    const scrollEnd = -totalScrollDistance; // Cuộn sang trái bằng một chu kỳ đầy đủ
                
                    const scrollSpeedPxPerSec = 40; // Điều chỉnh tốc độ cuộn
                    const scrollDuration = (totalScrollDistance / scrollSpeedPxPerSec) * 1000; // Thời gian hoạt ảnh (ms)
                
                    titleElement.classList.add('scrolling');
                    titleElement.style.setProperty('--scroll-start', `${scrollStart}px`);
                    titleElement.style.setProperty('--scroll-end', `${scrollEnd}px`);
                    titleElement.style.setProperty('--scroll-duration', `${scrollDuration}ms`);
                }
            }, 50); // Độ trễ nhỏ
        }

        function updateSongTitle() {
            if (musicPlayerSongTitle2D && currentSongIndex !== -1 && songs[currentSongIndex]) {
                // Use a timeout to ensure the element is in the DOM and has dimensions for scrolling
                setTimeout(() => {
                    applyScrollingToTitle2D(musicPlayerSongTitle2D, songs[currentSongIndex].name);
                }, 100);
            }
        }

        // Function to show 2D music controls and set up event listeners
        function show2DMusicControls() {
            musicControls2D.style.display = 'flex';

            playPauseBtn2D.onclick = () => { /* Existing code */
                if (audioPlayer.paused) {
                    audioPlayer.play();
                } else {
                    audioPlayer.pause();
                }
            };

            prevBtn2D.onclick = () => {
                const newIndex = (currentSongIndex - 1 + songs.length) % songs.length;
                showMusicPlayer(newIndex);
            };

            nextBtn2D.onclick = () => {
                const newIndex = (currentSongIndex + 1) % songs.length;
                showMusicPlayer(newIndex);
            };

            progressContainer2D.onclick = (e) => {
                const rect = progressContainer2D.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const percentage = clickX / rect.width;
                if (audioPlayer.duration) {
                    audioPlayer.currentTime = audioPlayer.duration * percentage;
                }
            };
            // Thêm lắng nghe sự kiện cho chấm kéo mới
            if (progressHandle2D) {
                progressHandle2D.addEventListener('mousedown', startProgressDrag);
                progressHandle2D.addEventListener('touchstart', startProgressDrag, { passive: false });
            }

            // Ensure the 2D song title is visible and updated with scrolling text
            if (musicPlayerSongTitle2D) {
                musicPlayerSongTitle2D.style.display = 'block';
            }
            updateSongTitle();

            updateMusicPlayerUI(); // Initial UI update for 2D controls

            // Add event listeners for playback mode buttons
            if (repeatOneBtn) repeatOneBtn.onclick = () => togglePlaybackMode('repeat-one');
            if (sequentialBtn) sequentialBtn.onclick = () => togglePlaybackMode('sequential');
            if (shuffleBtn) shuffleBtn.onclick = () => togglePlaybackMode('random');
            updatePlaybackModeUI(); // Update button states
        }

        function hide2DMusicControls() {
            musicControls2D.style.display = 'none';
        }

        // --- Playback Mode Functions ---
        function generateShuffledPlaylist() {
            shuffledSongIndices = Array.from({ length: songs.length }, (_, i) => i); // [0, 1, 2, ...]
            // Fisher-Yates (Knuth) shuffle algorithm
            for (let i = shuffledSongIndices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffledSongIndices[i], shuffledSongIndices[j]] = [shuffledSongIndices[j], shuffledSongIndices[i]];
            }
            // Optional: Ensure the current song isn't the very next one if possible
            if (currentSongIndex !== -1 && shuffledSongIndices[0] === currentSongIndex && songs.length > 1) {
                // Find a different index to swap with
                let swapIndex = 1;
                if (shuffledSongIndices.length > 2 && shuffledSongIndices[1] === currentSongIndex) { // Avoid swapping with itself if only 2 songs
                    swapIndex = 2;
                }
                [shuffledSongIndices[0], shuffledSongIndices[swapIndex]] = [shuffledSongIndices[swapIndex], shuffledSongIndices[0]];
            }
        }

        function updatePlaybackModeUI() {
            if (repeatOneBtn) repeatOneBtn.classList.toggle('active', playbackMode === 'repeat-one');
            if (sequentialBtn) sequentialBtn.classList.toggle('active', playbackMode === 'sequential');
            if (shuffleBtn) shuffleBtn.classList.toggle('active', playbackMode === 'random');
        }

        function togglePlaybackMode(mode) {
            playbackMode = mode;
            updatePlaybackModeUI();
            if (playbackMode === 'random') {
                generateShuffledPlaylist();
                currentShuffledIndex = -1; // Reset to pick the first from shuffled list on next song end
            }
            /* The line `musicPlayerSongTitle2D.style.display = 'none';` was removed from here as it was causing unintended hiding of the song title. */
            updateMusicPlayerUI(); // Initial UI update for 2D controls
        }

        // --- Logic kéo thanh tiến trình ---
        let isDraggingProgress = false;

        function startProgressDrag(e) {
            e.preventDefault(); // Ngăn chặn hành vi mặc định của trình duyệt (ví dụ: chọn văn bản, cuộn)
            e.stopPropagation(); // Ngăn chặn sự kiện lan truyền lên container click/touch
            isDraggingProgress = true;
            controls.enabled = false; // Tắt OrbitControls khi đang kéo

            document.addEventListener('mousemove', doProgressDrag);
            document.addEventListener('mouseup', endProgressDrag);
            document.addEventListener('touchmove', doProgressDrag, { passive: false });
            document.addEventListener('touchend', endProgressDrag);
        }

        function doProgressDrag(e) {
            if (!isDraggingProgress) return;

            let clientX;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
            } else {
                clientX = e.clientX;
            }

            const rect = progressContainer2D.getBoundingClientRect();
            let newX = clientX - rect.left; // Vị trí tương đối so với container

            // Giới hạn newX trong phạm vi của container
            newX = Math.max(0, Math.min(newX, rect.width));

            const percentage = newX / rect.width;
            if (audioPlayer.duration) {
                audioPlayer.currentTime = audioPlayer.duration * percentage;
            }
            updateMusicPlayerUI(); // Cập nhật giao diện ngay lập tức trong khi kéo để có phản hồi trực quan
        }

        function endProgressDrag() {
            isDraggingProgress = false;
            controls.enabled = true; // Kích hoạt lại OrbitControls sau khi kéo
            document.removeEventListener('mousemove', doProgressDrag);
            document.removeEventListener('mouseup', endProgressDrag);
            document.removeEventListener('touchmove', doProgressDrag);
            document.removeEventListener('touchend', endProgressDrag);
        }

        // --- 3D Music Player Functions ---
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }

        function hideMusicPlayer() {
            if (musicPlayerObject) {
                scene_bg.remove(musicPlayerObject); // Xóa khỏi scene nền
                musicPlayerObject.element.remove(); // Clean up the DOM element
                musicPlayerObject = null;
            }
            hide2DMusicControls(); // Hide 2D controls when 3D player is hidden
            audioPlayer.pause();
            audioPlayer.src = '';
            currentSongIndex = -1;
        }

        function showMusicPlayer(songIndex) {
            const oldPosition = musicPlayerObject ? musicPlayerObject.position.clone() : null;
            const wasInOverview = !musicPlayerFloatInfo.enabled; // Ghi lại trạng thái toàn cảnh khi bắt đầu

            if (musicPlayerObject) { // If a player is already shown, hide it first
                hideMusicPlayer();
            }

            // Chỉ đặt lại giao diện người dùng về trạng thái mặc định nếu KHÔNG ở chế độ toàn cảnh.
            if (!wasInOverview) {
                musicPlayerFloatInfo.enabled = true;
                document.getElementById('music-controls-2d').style.transform = '';
            }

            // If playbackMode is random, ensure shuffledSongIndices is set up
            // and currentShuffledIndex points to the current song within it.
            if (playbackMode === 'random') {
                if (shuffledSongIndices.length === 0 || !shuffledSongIndices.includes(songIndex)) {
                    generateShuffledPlaylist();
                    currentShuffledIndex = shuffledSongIndices.indexOf(songIndex);
                    if (currentShuffledIndex === -1) { // Fallback if for some reason it's not found (shouldn't happen)
                        currentShuffledIndex = 0;
                        songIndex = shuffledSongIndices[0]; // Use the first song in the new shuffled list
                    }
                } else {
                    // If the current song is already in the shuffled list, just update currentShuffledIndex
                    currentShuffledIndex = shuffledSongIndices.indexOf(songIndex);
                }
            }

            // Set the current song index based on the (potentially adjusted) songIndex
            currentSongIndex = songIndex;
            const song = songs[currentSongIndex];
            if (!song) return;

            // --- Create Player HTML Elements ---
            const playerContainer = document.createElement('div');
            playerContainer.className = 'music-player-container-3d';

            // Nếu đang ở chế độ toàn cảnh, hãy áp dụng lại các kiểu dáng cho trình phát nhạc mới
            if (wasInOverview) {
                playerContainer.style.transform = 'scale(0.7) translateY(-200px)';
            }


            const titleDiv = document.createElement('div');
            titleDiv.className = 'music-player-title';
            titleDiv.title = song.name; // Tooltip for full name

            const scrollContainer = document.createElement('div');
            scrollContainer.className = 'music-player-title-scroll-container';

            const titleText = document.createElement('span');
            titleText.className = 'music-player-title-text';
            titleText.textContent = song.name;
            scrollContainer.appendChild(titleText);

            const timeDiv = document.createElement('div');
            timeDiv.className = 'music-player-time';
            const currentTimeSpan = document.createElement('span');
            currentTimeSpan.id = 'music-player-current-time';
            currentTimeSpan.textContent = '0:00';
            const totalTimeSpan = document.createElement('span');
            totalTimeSpan.id = 'music-player-total-time';
            totalTimeSpan.textContent = '0:00'; // Will be updated by loadedmetadata
            timeDiv.append(currentTimeSpan, totalTimeSpan); // Append time spans to the 3D player's time div

            // Create the visualizer canvas
            const visualizerCanvasElement = document.createElement('canvas');
            visualizerCanvasElement.className = 'music-player-visualizer';
            // Dynamically set canvas width and height attributes based on screen size
            const isMobile = window.innerWidth <= 768;
            // Tăng độ phân giải canvas để vẽ sắc nét hơn và rộng hơn
            visualizerCanvasElement.width = isMobile ? 400 : 600;
            visualizerCanvasElement.height = isMobile ? 300 : 450;

            // Set initial visibility based on the global setting
            visualizerCanvasElement.style.display = isVisualizerVisible ? 'block' : 'none';
            timeDiv.style.display = isTimeDisplayVisible ? 'flex' : 'none';

            // Append elements in the desired order: close, title, visualizer, time
            titleDiv.appendChild(scrollContainer); // Add scroll container to title div
            playerContainer.append(titleDiv, visualizerCanvasElement, timeDiv); // Bỏ nút đóng


            // Store references for drawing
            visualizerCanvas = visualizerCanvasElement;
            visualizerCtx = visualizerCanvas.getContext('2d');

            // --- Create and Position 2D Object ---
            musicPlayerObject = new THREE.CSS2DObject(playerContainer);

            // Nếu có vị trí cũ, hãy áp dụng nó ngay lập tức để tránh hiệu ứng "bắn ra"
            if (oldPosition) {
                musicPlayerObject.position.copy(oldPosition);
            }

            // Vị trí của trình phát nhạc sẽ được cập nhật liên tục trong vòng lặp animate.
            // Thêm nó vào scene nền để nó di chuyển trong không gian 3D phía sau hệ mặt trời.
            scene_bg.add(musicPlayerObject); // Thêm vào scene nền
            show2DMusicControls(); // Show the 2D controls
            playSong(song.file);
            // Call the function to handle scrolling after the player is in the DOM
            // and its width can be accurately determined. Increased delay for better compatibility on deployed environments.
            setTimeout(() => { applyScrollingToTitle(titleDiv, song.name); }, 200);
        }

        function updateMusicPlayerUI() {
            if (!audioPlayer.duration) return;

            // Update 2D controls
            if (playPauseBtn2D) playPauseBtn2D.innerHTML = audioPlayer.paused ? '▶' : '❚❚';
            if (progressBar2D) progressBar2D.style.width = `${(audioPlayer.currentTime / audioPlayer.duration) * 100}%`;

            const progressPercentage = (audioPlayer.currentTime / audioPlayer.duration);
            // Cập nhật vị trí của chấm kéo
            if (progressHandle2D) {
                const containerWidth = progressContainer2D.offsetWidth;
                const handleWidth = progressHandle2D.offsetWidth;
                progressHandle2D.style.left = `${(progressPercentage * containerWidth) - (handleWidth / 2)}px`; /* Existing code */
            }
            // Update 3D player's time display (if it exists)
            const currentTimeSpan = musicPlayerObject ? musicPlayerObject.element.querySelector('#music-player-current-time') : null;
            const totalTimeSpan = musicPlayerObject ? musicPlayerObject.element.querySelector('#music-player-total-time') : null;
            if (currentTimeSpan) currentTimeSpan.textContent = formatTime(audioPlayer.currentTime);
            if (totalTimeSpan) totalTimeSpan.textContent = formatTime(audioPlayer.duration);
        }

        // --- Visualizer Helper Variables ---
        let ripples = [];
        let particles = [];
        let neonParticles = [];
        let fireParticles = [];
        let mandalaAngle = 0;
        let flowPhase = 0;
        let mandalaColorPhase = 0;

        function drawVisualizer() {
            if (!isVisualizerVisible || !analyser || !visualizerCtx || !audioPlayer || audioPlayer.paused || audioPlayer.ended) {
                // Clear canvas if no audio is playing or analyser is not ready
                if (visualizerCtx) {
                    visualizerCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
                }
                return;
            }

            analyser.getByteFrequencyData(dataArray); // Get frequency data

            visualizerCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);

            switch (currentVisualizerStyle) {
                case 0:
                    drawLightningVisualizer();
                    break;
                case 1:
                    drawCyberpunkNeonRing();
                    break;
                case 2:
                    drawMinimalistRipples();
                    break;
                case 3:
                    drawParticleMandala();
                    break;
                case 4:
                    drawRadialBars();
                    break;
                case 5:
                    drawFireVisualizer();
                    break;
                default:
                    drawLightningVisualizer();
            }
        }

        function drawLightningVisualizer() {
            // --- Style 0: Single-sided Electric Lightning (Original) ---
            const width = visualizerCanvas.width;
            const height = visualizerCanvas.height;

            // Xác định vùng an toàn (bằng chiều rộng thanh thời gian, khoảng 60% canvas)
            const safeZone = width * 0.6;
            const startX = (width - safeZone) / 2;
            const endX = startX + safeZone;
            const centerY = height / 2 + 50; // Điều chỉnh vị trí đáy sóng cho canvas lớn

            // Kiểm tra xem đã đến lúc bắt đầu một quá trình chuyển màu mới chưa
            const now = Date.now();
            if (now - lastColorChangeTime > colorChangeIntervalMs) {
                lastColorChangeTime = now;
                startTransitionHue = currentHueValue; // Lấy sắc độ hiện tại làm điểm bắt đầu
                targetTransitionHue = Math.floor(Math.random() * 360); // Chọn một sắc độ ngẫu nhiên mới làm mục tiêu
                transitionStartTime = now; // Ghi lại thời điểm bắt đầu chuyển đổi
                transitionActive = true; // Kích hoạt cờ chuyển đổi
            }

            // Tính toán sắc độ hiện tại dựa trên tiến độ chuyển đổi
            if (transitionActive) {
                const transitionElapsedTime = now - transitionStartTime;
                if (transitionElapsedTime < colorTransitionDurationMs) {
                    const progress = transitionElapsedTime / colorTransitionDurationMs;

                    // Nội suy sắc độ, xử lý trường hợp vòng quanh bánh xe màu (ví dụ từ 350 độ đến 10 độ)
                    let diff = targetTransitionHue - startTransitionHue;
                    if (diff > 180) diff -= 360; // Đi theo chiều ngắn hơn trên bánh xe màu
                    if (diff < -180) diff += 360; // Đi theo chiều ngắn hơn trên bánh xe màu
                    currentHueValue = (startTransitionHue + diff * progress + 360) % 360; // Đảm bảo giá trị hue luôn dương
                } else {
                    // Quá trình chuyển đổi đã hoàn tất
                    currentHueValue = targetTransitionHue;
                    transitionActive = false;
                }
            }

            const waveColor = `hsl(${currentHueValue}, 100%, 50%)`; // Tạo chuỗi màu HSL
            visualizerCtx.lineWidth = 1.5; // Tăng độ đậm nét của sóng nhạc
            visualizerCtx.strokeStyle = waveColor; // Sử dụng màu sắc động
            visualizerCtx.shadowBlur = 15; // Hiệu ứng phát sáng mạnh
            visualizerCtx.shadowColor = waveColor; // Sử dụng màu sắc động
            visualizerCtx.lineJoin = 'round';
            visualizerCtx.lineCap = 'round';

            // Tính toán âm lượng trung bình để điều chỉnh độ rung
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i];
            }
            const average = sum / bufferLength;
            const noiseFactor = Math.min(1.2, Math.max(0.2, average / 50));

            const step = 3; // Tăng mật độ: Giảm khoảng cách giữa các điểm (từ 10 xuống 3)

            visualizerCtx.beginPath();
            visualizerCtx.moveTo(startX, centerY); // Bắt đầu từ mép trái của vùng an toàn

            for (let x = startX; x <= endX; x += step) {
                // Calculate distance from center (0.0 at center, 1.0 at edges of safe zone)
                const distFromCenter = Math.abs(x - width / 2) / (safeZone / 2);
                // Map x position to frequency data index (Center = Low Freq, Edges = High Freq)
                const dataIndex = Math.floor(distFromCenter * (bufferLength - 1));
                const value = dataArray[dataIndex];

                // Biên độ sóng
                // Dùng hàm mũ (Math.pow) để làm đỉnh sóng nhọn hơn và tách biệt rõ ràng hơn
                const amplitude = Math.pow(value / 255, 3) * height * 0.5; // Giảm biên độ xuống một nửa

                // Tạo nhiễu ngẫu nhiên (-1 đến 1)
                const noise = (Math.random() - 0.5) * 2;
                
                // Độ lệch Y (chỉ lấy giá trị dương để vẽ lên trên)
                let deltaY = Math.abs(noise * amplitude * noiseFactor);
                
                // Giới hạn chiều cao sóng để đỉnh cao nhất luôn cách lề trên (tên bài hát) ít nhất 10px
                const maxWaveHeight = centerY - 20; // Giới hạn chiều cao tối đa của sóng (cách lề trên 20px)
                if (deltaY > maxWaveHeight) {
                    deltaY = maxWaveHeight;
                }

                visualizerCtx.lineTo(x, centerY - deltaY);
            }
            visualizerCtx.stroke();
        }

        function drawCyberpunkNeonRing() {
            // --- Style 1: Cyberpunk Neon Ring (Enhanced) ---
            const width = visualizerCanvas.width;
            const height = visualizerCanvas.height;
            const centerX = width / 2;
            const centerY = height / 2; // Căn giữa theo chiều dọc vì canvas giờ đã lớn và căn giữa tuyệt đối
            
            // Sử dụng vùng an toàn (60% chiều rộng) làm kích thước tham chiếu để không vượt quá thanh thời gian
            const refDim = width * 0.3; // Giảm kích thước đi một nửa (0.6 -> 0.3)
            
            // 1. Analyze Audio Data
            // Bass (Low freqs)
            let bassSum = 0;
            const bassBins = 10; // Use first 10 bins for bass
            for(let i = 0; i < bassBins; i++) bassSum += dataArray[i];
            const bassAvg = bassSum / bassBins;
            const bassLevel = bassAvg / 255; // 0.0 to 1.0
            
            // Treble (High Frequencies) - Thêm phân tích âm cao
            let trebleSum = 0;
            const trebleStart = Math.floor(bufferLength * 0.6);
            for(let i = trebleStart; i < bufferLength; i++) trebleSum += dataArray[i];
            const trebleAvg = trebleSum / (bufferLength - trebleStart);
            const trebleLevel = trebleAvg / 255;

            // Overall Energy
            let totalSum = 0;
            for(let i = 0; i < bufferLength; i++) totalSum += dataArray[i];
            const energy = totalSum / bufferLength / 255; // 0.0 to 1.0

            // --- Dynamic Color Change based on Energy ---
            // Tốc độ đổi màu phụ thuộc vào năng lượng (đại diện cho tốc độ/cường độ nhạc)
            const hueSpeed = 0.5 + (energy * 4.0); // Tốc độ cơ bản + tăng tốc khi nhạc mạnh
            currentHueValue = (currentHueValue + hueSpeed) % 360;

            // Pulse effect: Điều chỉnh kích thước dựa trên Bass (Trầm), Treble (Cao) và Energy (Năng lượng/Tốc độ)
            // Công thức tổng hợp để quả cầu phản ứng với mọi yếu tố của âm thanh: Trầm, Cao, Nhanh/Chậm (Năng lượng)
            const pulse = 0.8 + (bassLevel * 0.6) + (energy * 0.4) + (trebleLevel * 0.3); 
            const baseRadius = refDim * 0.2 * pulse; // Kích thước dựa trên vùng an toàn

            // 2. Draw Inner Core (Bass Glow)
            // A soft glow in the center that reacts purely to bass
            const coreGradient = visualizerCtx.createRadialGradient(centerX, centerY, 0, centerX, centerY, baseRadius * 1.5);
            coreGradient.addColorStop(0, `hsla(${currentHueValue}, 100%, 70%, ${bassLevel * 0.8})`); // Bright center
            coreGradient.addColorStop(0.6, `hsla(${currentHueValue}, 100%, 50%, ${bassLevel * 0.4})`); // Mid
            coreGradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Transparent edge
            
            visualizerCtx.fillStyle = coreGradient;
            visualizerCtx.beginPath();
            visualizerCtx.arc(centerX, centerY, baseRadius * 2, 0, Math.PI * 2);
            visualizerCtx.fill();

            // --- Sparkling Particles in Core ---
            // Spawn particles
            if (neonParticles.length < 20) {
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * baseRadius * 1.5; // Inside core area
                neonParticles.push({
                    x: centerX + Math.cos(angle) * r,
                    y: centerY + Math.sin(angle) * r,
                    vx: (Math.random() - 0.5) * 1.0, // Tăng tốc độ cơ bản
                    vy: (Math.random() - 0.5) * 1.0,
                    life: Math.random() * 0.5 + 0.5,
                    size: Math.random() * 1.5 + 0.5
                });
            }
            // Update and Draw
            visualizerCtx.fillStyle = '#ffffff';
            for (let i = neonParticles.length - 1; i >= 0; i--) {
                const p = neonParticles[i];
                // Hạt di chuyển nhanh hơn khi nhạc mạnh
                p.x += p.vx * (1 + energy * 3);
                p.y += p.vy * (1 + energy * 3);
                p.life -= 0.01;
                
                // Keep particles somewhat contained or just let them fade
                const dist = Math.sqrt((p.x - centerX)**2 + (p.y - centerY)**2);
                if (dist > baseRadius * 2) p.life -= 0.05; // Fade faster if outside

                if (p.life <= 0) {
                    neonParticles.splice(i, 1);
                    continue;
                }
                
                visualizerCtx.globalAlpha = p.life * (0.5 + Math.sin(Date.now() * 0.01 + i) * 0.5); // Twinkle
                visualizerCtx.beginPath();
                visualizerCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                visualizerCtx.fill();
            }
            visualizerCtx.globalAlpha = 1.0;

            // 3. Draw Static/Slow Background Rings (Context)
            visualizerCtx.lineWidth = 1;
            // Outer ring
            visualizerCtx.strokeStyle = `hsla(${currentHueValue}, 100%, 50%, ${0.1 + energy * 0.2})`; 
            visualizerCtx.beginPath();
            visualizerCtx.arc(centerX, centerY, baseRadius * 1.1, 0, Math.PI * 2);
            visualizerCtx.stroke();
            // Inner ring
            visualizerCtx.strokeStyle = `hsla(${(currentHueValue + 30) % 360}, 100%, 50%, ${0.1 + energy * 0.2})`; 
            visualizerCtx.beginPath();
            visualizerCtx.arc(centerX, centerY, baseRadius * 0.9, 0, Math.PI * 2);
            visualizerCtx.stroke();

            // 4. Draw Main Reactive Dashes (Frequency Spectrum)
            // Setup Glow
            visualizerCtx.shadowBlur = 5 + bassLevel * 15; // Glow intensifies with bass
            visualizerCtx.shadowColor = `hsl(${currentHueValue}, 100%, 50%)`; 
            
            const numDashes = 64; 
            const angleStep = (Math.PI * 2) / numDashes;
            // Rotate the whole ring slowly, faster with high energy
            const rotation = Date.now() * (0.0002 + energy * 0.0005);
            
            for (let i = 0; i < numDashes; i++) {
                // Map dash index to frequency data
                const dataIndex = Math.floor((i / numDashes) * (bufferLength * 0.8));
                const value = dataArray[dataIndex];
                const level = value / 255;

                // Calculate Dash Length
                // Use power function to suppress noise and exaggerate loud sounds
                // Chiều dài phụ thuộc vào âm lượng tần số (level) và tổng năng lượng (energy - đại diện cho tốc độ/cường độ)
                const speedFactor = 1 + energy * 2.0; // Hệ số tăng cường độ dài khi nhạc mạnh/nhanh
                let dashLen = (Math.pow(level, 2.5) * (refDim * 0.25) * speedFactor); 
                dashLen = Math.max(2, dashLen); // Minimum length
                
                const angle = i * angleStep + rotation;
                
                visualizerCtx.save();
                visualizerCtx.translate(centerX, centerY);
                visualizerCtx.rotate(angle);
                
                // Dynamic Color based on intensity
                // Base hue -> Brighter/Whiter
                const lightness = 50 + level * 50; // 50% to 100%
                const hue = currentHueValue;
                
                visualizerCtx.strokeStyle = `hsl(${hue}, 100%, ${lightness}%)`;
                visualizerCtx.lineWidth = 1.5 + level * 2.5; // Thicker when louder
                visualizerCtx.lineCap = 'round';
                
                visualizerCtx.beginPath();
                visualizerCtx.moveTo(baseRadius, 0);
                visualizerCtx.lineTo(baseRadius + dashLen, 0);
                visualizerCtx.stroke();

                // Add a "peak" dot for strong signals
                if (level > 0.6) {
                    visualizerCtx.fillStyle = `rgba(255, 255, 255, ${level})`;
                    visualizerCtx.beginPath();
                    // Position the dot slightly past the end of the dash
                    visualizerCtx.arc(baseRadius + dashLen + 3, 0, 1 + level * 1.5, 0, Math.PI * 2);
                    visualizerCtx.fill();
                }
                
                visualizerCtx.restore();
            }
            visualizerCtx.shadowBlur = 0; // Reset shadow
        }

        function drawMinimalistRipples() {
            // --- Style 2: Minimalist Concentric Ripples (Pro Version - Enhanced) ---
            const width = visualizerCanvas.width;
            const height = visualizerCanvas.height;
            const centerX = width / 2;
            const centerY = height / 2; // Căn giữa theo chiều dọc
            
            const maxRadius = ((width * 0.6) / 2) * 0.7; // Giảm kích thước tối đa xuống 70%

            // 1. Analyze Audio
            // Bass (Low Frequencies) - Đại diện cho âm trầm/thấp
            let bassSum = 0;
            for(let i=0; i<10; i++) bassSum += dataArray[i];
            const bassAvg = bassSum / 10;
            const bassLevel = bassAvg / 255; // 0.0 - 1.0

            // Treble (High Frequencies) - Đại diện cho âm cao
            let trebleSum = 0;
            const trebleStart = Math.floor(bufferLength * 0.6); // Lấy 40% dải tần cao
            for(let i = trebleStart; i < bufferLength; i++) trebleSum += dataArray[i];
            const trebleAvg = trebleSum / (bufferLength - trebleStart);
            const trebleLevel = trebleAvg / 255;

            // Energy (Overall) - Đại diện cho mạnh/yếu và nhanh/chậm
            let totalSum = 0;
            for(let i = 0; i < bufferLength; i++) totalSum += dataArray[i];
            const energy = totalSum / bufferLength / 255;

            // Độ dày cố định theo yêu cầu, không phụ thuộc vào âm thanh
            // Giữ nguyên biến dynamicWidth để tương thích với code bên dưới, nhưng gán giá trị tĩnh
            const dynamicWidth = 0.8; 

            // 2. Dynamic Color Update
            const hueSpeed = 0.5 + (energy * 4.0);
            currentHueValue = (currentHueValue + hueSpeed) % 360;

            // 3. Ripple Spawning Logic
            // Spawn faint background ripples regularly to keep it alive
            if (!ripples.length || ripples[ripples.length-1].age > 10) { 
                 ripples.push({ 
                     r: 10 * 0.7, // Scale initial radius
                     age: 0, 
                     // Tốc độ phụ thuộc vào năng lượng (nhanh/chậm, mạnh/nhẹ) và treble (cao)
                     speed: (1 + energy * 2 + trebleLevel * 1.5) * 0.7, 
                     width: dynamicWidth * 0.2, // Sóng nền mỏng hơn sóng chính
                     hue: currentHueValue,
                     maxR: maxRadius,
                     isBeat: false,
                     opacityFactor: 0.3 + energy * 0.4 // Base opacity
                 });
            }

            // Spawn strong beat ripples
            // Lower threshold to 80 to catch more beats
            if (bassAvg > 80 && (!ripples.length || ripples[ripples.length-1].age > 5)) {
                 // Avoid clustering strong ripples too close
                 const lastWasBeat = ripples.length > 0 && ripples[ripples.length-1].isBeat;
                 if (!lastWasBeat || ripples[ripples.length-1].age > 8) {
                     ripples.push({ 
                         r: 10 * 0.7, // Scale initial radius
                         age: 0, 
                         // Tốc độ beat phụ thuộc vào Bass (trầm) và năng lượng tổng thể
                         speed: (3 + (bassLevel * 5) + (energy * 2)) * 0.7, 
                         width: dynamicWidth, // Sử dụng độ dày động đã tính toán
                         hue: currentHueValue,
                         maxR: maxRadius,
                         isBeat: true,
                         opacityFactor: 1.0
                     });
                 }
            }

            // 4. Draw Central Core (Pulse) - Always visible
            visualizerCtx.shadowBlur = (20 * bassLevel + 10) * 0.7; // Scale shadow
            visualizerCtx.shadowColor = `hsl(${currentHueValue}, 100%, 50%)`;
            
            // Outer glow of core
            visualizerCtx.beginPath();
            visualizerCtx.arc(centerX, centerY, ((10 + bassLevel * 30) * 0.7) / 3, 0, Math.PI * 2); // Scale radius reduced by 3x
            visualizerCtx.fillStyle = `hsla(${currentHueValue}, 100%, 60%, ${0.6 + bassLevel * 0.4})`;
            visualizerCtx.fill();
            
            // Inner bright core
            visualizerCtx.beginPath();
            visualizerCtx.arc(centerX, centerY, ((5 + bassLevel * 15) * 0.7) / 3, 0, Math.PI * 2); // Scale radius reduced by 3x
            visualizerCtx.fillStyle = '#ffffff';
            visualizerCtx.fill();
            
            visualizerCtx.shadowBlur = 0; // Reset shadow for ripples

            // 5. Draw Ripples
            for (let i = ripples.length - 1; i >= 0; i--) {
                const r = ripples[i];
                r.r += r.speed;
                r.age++;
                
                const progress = r.r / r.maxR;
                // Fade out as it expands
                let opacity = (1 - Math.pow(progress, 1.5)) * r.opacityFactor;
                
                if (opacity <= 0.01) {
                    ripples.splice(i, 1);
                    continue;
                }

                visualizerCtx.beginPath();
                // Beat ripples are brighter/thicker
                visualizerCtx.strokeStyle = `hsla(${r.hue}, 100%, ${r.isBeat ? '80%' : '50%'}, ${opacity})`;
                visualizerCtx.lineWidth = r.width * (1 - progress * 0.2); 
                
                visualizerCtx.arc(centerX, centerY, r.r, 0, Math.PI * 2);
                visualizerCtx.stroke();

                // Echo effect for beat ripples (double ring)
                if (r.isBeat && r.width > 3 * 0.7) { // Scale threshold
                    visualizerCtx.beginPath();
                    visualizerCtx.strokeStyle = `hsla(${r.hue}, 100%, 50%, ${opacity * 0.4})`;
                    visualizerCtx.lineWidth = 1 * 0.7; // Scale line width
                    visualizerCtx.arc(centerX, centerY, r.r * 0.85, 0, Math.PI * 2);
                    visualizerCtx.stroke();
                }
            }
        }

        function drawParticleMandala() {
            // --- Style 3: Particle Burst Mandala ---
            const width = visualizerCanvas.width;
            const height = visualizerCanvas.height;
            const centerX = width / 2;
            const centerY = height / 2; // Căn giữa theo chiều dọc
            
            const maxRadius = (width * 0.6) / 4; // Giới hạn vùng nổ (Giảm kích thước tổng thể 2 lần)

            // Analyze Audio
            let bassSum = 0;
            for(let i=0; i<10; i++) bassSum += dataArray[i];
            const bassAvg = bassSum / 10;
            const bassLevel = bassAvg / 255; // 0.0 - 1.0

            // Calculate Energy (Overall) for color speed
            let totalSum = 0;
            for(let i = 0; i < bufferLength; i++) totalSum += dataArray[i];
            const energy = totalSum / bufferLength / 255;

            visualizerCtx.globalCompositeOperation = 'lighter';
            
            // Draw Mandala (8 rays with bursting particles)
            mandalaAngle += 0.01;
            // Tốc độ đổi màu của thanh dựa vào năng lượng nhạc (nhanh/chậm)
            mandalaColorPhase += 0.02 + (energy * 0.2);
            
            // Tính toán màu giữa Cyan (0, 255, 255) và Trắng (255, 255, 255)
            const colorMix = (Math.sin(mandalaColorPhase) + 1) / 2; // 0.0 -> 1.0
            const redChannel = Math.floor(colorMix * 255);

            const numRays = 8;
            
            // Draw Center/Rays (Visual Structure)
            visualizerCtx.strokeStyle = `rgba(${redChannel}, 255, 255, 0.5)`; // Màu thay đổi giữa Cyan và Trắng
            visualizerCtx.lineWidth = 2;
            visualizerCtx.beginPath();
            for(let i=0; i<numRays; i++) {
                const angle = mandalaAngle + (i * Math.PI * 2) / numRays;
                const rayLen = 15 + (bassLevel * 25); // Base length + pulse (Giảm 2 lần)
                const x = centerX + Math.cos(angle) * rayLen;
                const y = centerY + Math.sin(angle) * rayLen;
                visualizerCtx.moveTo(centerX, centerY);
                visualizerCtx.lineTo(x, y);
            }
            visualizerCtx.stroke();

            // Spawn Particles Logic
            // Spawn symmetrically on all 8 rays
            // Probability increases with bass
            if (Math.random() < bassLevel * 1.5) { 
                for(let i=0; i<numRays; i++) {
                    const angle = mandalaAngle + (i * Math.PI * 2) / numRays;
                    
                    // Speed depends on bass
                    const speed = 1.5 + Math.random() * 1 + (bassLevel * 4); // Giảm tốc độ 2 lần
                    
                    particles.push({
                        x: centerX, 
                        y: centerY,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1.0,
                        decay: 0.01 + Math.random() * 0.02,
                        color: i % 2 === 0 ? '#00ffff' : '#ffffff', // Cyan or White
                        size: (2 + Math.random() * 2) / 5 // Giảm kích thước hạt 5 lần
                    });
                }
            }

            // Update and Draw Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= p.decay;

                // Distance check to fade out if too far
                const dist = Math.sqrt((p.x - centerX)**2 + (p.y - centerY)**2);
                if (dist > maxRadius) p.life -= 0.05;

                if (p.life <= 0) {
                    particles.splice(i, 1);
                    continue;
                }

                visualizerCtx.globalAlpha = p.life;
                visualizerCtx.fillStyle = p.color;
                visualizerCtx.beginPath();
                visualizerCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                visualizerCtx.fill();
            }
            visualizerCtx.globalAlpha = 1.0;
            visualizerCtx.globalCompositeOperation = 'source-over';
        }

        function drawRadialBars() {
            // --- Style 4: Radial Bar Equalizer ---
            const width = visualizerCanvas.width;
            const height = visualizerCanvas.height;
            const centerX = width / 2;
            const centerY = height / 2; // Căn giữa theo chiều dọc
            
            const maxRadius = (width * 0.6) / 2;
            const radius = maxRadius * 0.3; // Bán kính vòng tròn trong
            const bars = 180; // Tăng mật độ số lượng thanh lên gấp 3 lần
            const step = (Math.PI * 2) / bars;

            // Logic đổi màu ngẫu nhiên mượt mà
            const now = Date.now();
            if (now - lastColorChangeTime > colorChangeIntervalMs) {
                lastColorChangeTime = now;
                startTransitionHue = currentHueValue;
                targetTransitionHue = Math.floor(Math.random() * 360);
                transitionStartTime = now;
                transitionActive = true;
            }

            if (transitionActive) {
                const transitionElapsedTime = now - transitionStartTime;
                if (transitionElapsedTime < colorTransitionDurationMs) {
                    const progress = transitionElapsedTime / colorTransitionDurationMs;
                    let diff = targetTransitionHue - startTransitionHue;
                    if (diff > 180) diff -= 360;
                    if (diff < -180) diff += 360;
                    currentHueValue = (startTransitionHue + diff * progress + 360) % 360;
                } else {
                    currentHueValue = targetTransitionHue;
                    transitionActive = false;
                }
            }

            for (let i = 0; i < bars; i++) {
                // Map to frequency data (mirrored)
                let dataIndex = i;
                if (i >= bars / 2) {
                    dataIndex = bars - i;
                }
                // Scale index to buffer length
                dataIndex = Math.floor(dataIndex * (bufferLength / (bars/2)));
                
                const value = dataArray[dataIndex];
                const barLen = (value / 255) * (maxRadius * 0.6); // Chiều dài thanh tự động điều chỉnh theo vùng an toàn
                const angle = i * step - Math.PI / 2;

                visualizerCtx.save();
                visualizerCtx.translate(centerX, centerY);
                visualizerCtx.rotate(angle);

                // Màu sắc thẩm mỹ: Hue chính + biến thiên nhẹ (60 độ) + độ sáng theo âm lượng
                const hue = (currentHueValue + (i / bars) * 60) % 360;
                const lightness = 50 + (value / 255) * 30;
                visualizerCtx.fillStyle = `hsl(${hue}, 100%, ${lightness}%)`;
                
                // Vẽ thanh mảnh hơn (1/3 kích thước cũ: 4 -> 1.4)
                visualizerCtx.fillRect(radius, -0.7, barLen, 1.4);

                visualizerCtx.restore();
            }

            // Draw Current Time in Center (Digital Segment Style)
            const date = new Date();
            const hours = date.getHours();
            const minutes = date.getMinutes();
            
            const h1 = Math.floor(hours / 10);
            const h2 = hours % 10;
            const m1 = Math.floor(minutes / 10);
            const m2 = minutes % 10;
            
            visualizerCtx.save();
            
            // Settings for digital clock
            const digitHeight = radius * 0.45; // Height of the digit (Reduced to 90%)
            const digitWidth = digitHeight * 0.6; // Width of the digit
            const segmentThickness = digitWidth * 0.2; // Thickness of the bars (x2)
            const spacing = digitWidth * 0.3; // Space between digits
            const colonWidth = digitWidth * 0.8; // Width allocated for colon (Increased spacing)
            
            // Total width: 4 digits + 3 spacings (between digits) + 1 colon space (middle)
            const totalWidth = (digitWidth * 4) + (spacing * 2) + colonWidth;
            
            let startX = centerX - totalWidth / 2;
            const startY = centerY - digitHeight / 2;
            
            visualizerCtx.fillStyle = 'white';
            visualizerCtx.shadowBlur = 15;
            visualizerCtx.shadowColor = `hsl(${currentHueValue}, 100%, 50%)`;

            // Helper to draw a single digit (7-segment)
            function drawSegmentDigit(x, y, w, h, val) {
                const t = segmentThickness;
                const segs = [
                    [1, 1, 1, 1, 1, 1, 0], // 0
                    [0, 1, 1, 0, 0, 0, 0], // 1
                    [1, 1, 0, 1, 1, 0, 1], // 2
                    [1, 1, 1, 1, 0, 0, 1], // 3
                    [0, 1, 1, 0, 0, 1, 1], // 4
                    [1, 0, 1, 1, 0, 1, 1], // 5
                    [1, 0, 1, 1, 1, 1, 1], // 6
                    [1, 1, 1, 0, 0, 0, 0], // 7
                    [1, 1, 1, 1, 1, 1, 1], // 8
                    [1, 1, 1, 1, 0, 1, 1]  // 9
                ];
                const active = segs[val];
                
                if(active[0]) visualizerCtx.fillRect(x + t, y, w - 2*t, t); // Top
                if(active[1]) visualizerCtx.fillRect(x + w - t, y + t, t, h/2 - 1.5*t); // Top Right
                if(active[2]) visualizerCtx.fillRect(x + w - t, y + h/2 + 0.5*t, t, h/2 - 1.5*t); // Bottom Right
                if(active[3]) visualizerCtx.fillRect(x + t, y + h - t, w - 2*t, t); // Bottom
                if(active[4]) visualizerCtx.fillRect(x, y + h/2 + 0.5*t, t, h/2 - 1.5*t); // Bottom Left
                if(active[5]) visualizerCtx.fillRect(x, y + t, t, h/2 - 1.5*t); // Top Left
                if(active[6]) visualizerCtx.fillRect(x + t, y + h/2 - t/2, w - 2*t, t); // Middle
            }

            drawSegmentDigit(startX, startY, digitWidth, digitHeight, h1); startX += digitWidth + spacing;
            drawSegmentDigit(startX, startY, digitWidth, digitHeight, h2); startX += digitWidth + colonWidth;
            
            if (date.getSeconds() % 2 === 0) { // Blink colon
                const colonX = startX - colonWidth/2 - segmentThickness/2;
                visualizerCtx.fillRect(colonX, startY + digitHeight * 0.3, segmentThickness, segmentThickness);
                visualizerCtx.fillRect(colonX, startY + digitHeight * 0.7, segmentThickness, segmentThickness);
            }
            
            drawSegmentDigit(startX, startY, digitWidth, digitHeight, m1); startX += digitWidth + spacing;
            drawSegmentDigit(startX, startY, digitWidth, digitHeight, m2);

            visualizerCtx.restore();
        }

        function drawFireVisualizer() {
            // --- Style 5: Fire (Ngọn Đuốc Tập Trung Thẳng Đứng) ---
            const width = visualizerCanvas.width;
            const height = visualizerCanvas.height;
            const centerX = width / 2;
            const flameBaseY = height / 2 + 70; // Dịch chuyển gốc ngọn lửa lên 20px

            // 1. Thiết lập vùng lửa và màu sắc
            const initialSpawnJitter = (width * 0.2) * 0.05; // Giảm vùng sinh hạt đi 1 nửa
            const colors = {
                // Màu lạnh (tần số thấp)
                violet: '#9370DB', // Tím
                indigo: '#4B0082', // Chàm
                blue: '#1E90FF', // Xanh Dương
                greenBlue: '#00CED1', // Xanh Lá (thiên xanh dương)
                // Nhóm trung tính
                greenYellow: '#ADFF2F', // Xanh Lá (thiên vàng)
                magenta: '#FF00FF', // Tím Đỏ
                blue: '#1E90FF',
                yellow: '#FFD700',
                orange: '#FFA500',
                red: '#FF4500'
            };

            // 2. Sinh ra các hạt dựa trên dải tần âm thanh
            for (let i = 0; i < bufferLength; i++) {
                const value = dataArray[i];
                if (value < 15) continue; // Bỏ qua nếu âm lượng tần số quá nhỏ
                
                // Giảm mật độ hạt đi 5 lần để cải thiện hiệu suất
                if (Math.random() > (value / 255) * 0.009) continue; // 0.6 / 5 = 0.12

                const t = i / (bufferLength - 1); // Vị trí chuẩn hóa trong dải tần (0.0 -> 1.0)
                // Xác định màu sắc dựa trên vị trí dải tần
                let particleColor;
                if (t < 0.111)      particleColor = colors.violet;
                else if (t < 0.222) particleColor = colors.indigo;
                else if (t < 0.333) particleColor = colors.blue;
                else if (t < 0.444) particleColor = colors.greenBlue;
                else if (t < 0.555) particleColor = colors.greenYellow;
                else if (t < 0.666) particleColor = colors.magenta;
                else if (t < 0.777) particleColor = colors.yellow;
                else if (t < 0.888) particleColor = colors.orange;
                else                particleColor = colors.red;
                const energy = value / 255;
                const life = 0.8 + Math.random() * 0.5;
                
                fireParticles.push({
                    x: centerX + (Math.random() - 0.5) * initialSpawnJitter, // Tất cả hạt sinh ra từ trung tâm
                    y: flameBaseY,
                    // Vận tốc ngang: giảm đi 1 nửa
                    vx: (Math.random() - 0.5) * 0.25,
                    // Vận tốc dọc phụ thuộc vào năng lượng của dải tần đó
                    vy: (energy * 1.5) + 0.5 + Math.random() * 0.5, // Giảm vận tốc dọc đi 1 nửa
                    life: life,
                    maxLife: life, // Lưu lại để tính alpha
                    decay: 0.015 + Math.random() * 0.01,
                    color: particleColor,
                    // Kích thước phụ thuộc vào năng lượng, giảm đi 1 nửa
                    size: (energy * 5) + Math.random() * 2 + 0.5
                });
            }
            // 3. Cập nhật và vẽ tất cả các hạt
            visualizerCtx.globalCompositeOperation = 'lighter';
            for (let i = fireParticles.length - 1; i >= 0; i--) {
                const p = fireParticles[i];
                // Cập nhật vật lý
                p.y -= p.vy;
                p.x += p.vx;
                // Loại bỏ hiệu ứng "lắc lư" để các hạt bay thẳng lên
                p.life -= p.decay;
                p.size *= 0.97; // Thu nhỏ dần
                if (p.life <= 0 || p.size < 0.5) {
                    fireParticles.splice(i, 1);
                    continue;
                }
                // Vẽ hạt
                visualizerCtx.beginPath();
                visualizerCtx.globalAlpha = (p.life / p.maxLife) * 0.9; // Làm mờ dần
                visualizerCtx.shadowBlur = p.size * 1.5;
                visualizerCtx.shadowColor = p.color;
                visualizerCtx.fillStyle = p.color;
                visualizerCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                visualizerCtx.fill();
            }
            // Đặt lại trạng thái canvas
            visualizerCtx.globalAlpha = 1.0;
            visualizerCtx.globalCompositeOperation = 'source-over';
            visualizerCtx.shadowBlur = 0;
        }

        audioPlayer.addEventListener('timeupdate', updateMusicPlayerUI);
        audioPlayer.addEventListener('loadedmetadata', updateMusicPlayerUI);
        audioPlayer.addEventListener('play', () => {
            updateMusicPlayerUI();
            updateSongTitle(); // Recalculate scrolling
        });
        audioPlayer.addEventListener('pause', updateMusicPlayerUI);        
        audioPlayer.addEventListener('ended', () => {
            if (songQueue.length > 0) {
                const nextIndex = songQueue.shift();
                
                // Nếu bài tiếp theo trong hàng đợi trùng với bài đang phát, chỉ cần phát lại
                if (nextIndex === currentSongIndex) {
                    audioPlayer.currentTime = 0;
                    audioPlayer.play();
                } else {
                    showMusicPlayer(nextIndex);
                }

                if (isSongListOpen) populateSongList();
                if (clearQueueBox.style.display === 'flex') renderQueueBox();
                return;
            }
            let newIndex;
            if (playbackMode === 'repeat-one') {
                audioPlayer.currentTime = 0;
                audioPlayer.play();
                return; // Don't proceed to showMusicPlayer
            } else if (playbackMode === 'sequential') {
                newIndex = (currentSongIndex + 1) % songs.length;
            } else if (playbackMode === 'random') {
                // If shuffled list is empty or we've played all shuffled songs, regenerate
                if (shuffledSongIndices.length === 0 || currentShuffledIndex >= shuffledSongIndices.length - 1) {
                    generateShuffledPlaylist();
                    currentShuffledIndex = 0; // Start from the beginning of the new shuffled list
                } else {
                    currentShuffledIndex++;
                }
                newIndex = shuffledSongIndices[currentShuffledIndex];
            }
            // Ensure newIndex is valid before calling showMusicPlayer
            if (newIndex !== undefined && newIndex >= 0 && newIndex < songs.length) {
                showMusicPlayer(newIndex);
            }
        });

        // --- GIF TV Player Logic ---
        // Danh sách các file hiển thị trên TV (hỗ trợ cả .gif và .jpg, .png)
        const tvPlaylist = [];
        
        // Thêm file gif
        tvPlaylist.push('gifs/gif1.gif');
        
        // Thêm các file jpg (gif1.jpg đến gif3.jpg)
        for (let i = 1; i <= 3; i++) {
            tvPlaylist.push(`gifs/gif${i}.jpg`);
        }

        const gifTvContainer = document.getElementById('gif-tv-container');
        const gifTvScreen = document.getElementById('gif-tv-screen');
        let gifInterval;

        function startTvPlayer() {
            gifTvContainer.style.display = 'block';
            playRandomTvContent();
            // Đổi GIF mỗi 5 giây
            gifInterval = setInterval(playRandomTvContent, 5000);
        }

        function stopTvPlayer() {
            gifTvContainer.style.display = 'none';
            clearInterval(gifInterval);
            gifTvScreen.src = ''; 
        }

        function playRandomTvContent() {
            if (tvPlaylist.length === 0) return;
            const randomIndex = Math.floor(Math.random() * tvPlaylist.length);
            const selectedSrc = tvPlaylist[randomIndex];
            
            // Xử lý xóa nền trắng cho ảnh (Lưu ý: Với file GIF, cách này sẽ chỉ lấy frame đầu tiên)
            processImageForTv(selectedSrc, (processedDataUrl) => {
                gifTvScreen.src = processedDataUrl;
            });
        }

        function processImageForTv(src, callback) {
            const img = new Image();
            img.crossOrigin = "Anonymous"; // Cố gắng tránh lỗi CORS
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);

                try {
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data;
                    
                    // Ngưỡng xác định màu tối (đường nét, mắt, mũi...)
                    // Các màu đen, nâu, xám đậm sẽ có độ sáng thấp.
                    const darkThreshold = 50; 

                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        
                        // Tính độ sáng (Luminance)
                        const brightness = 0.299 * r + 0.587 * g + 0.114 * b;

                        if (brightness < darkThreshold) {
                            // Giữ lại các nét tối và chuyển sang màu Cyan (#00ffff)
                            data[i] = 0;     // R
                            data[i + 1] = 255; // G
                            data[i + 2] = 255; // B
                            data[i + 3] = 255; // Alpha (Hiện rõ)
                        } else {
                            // Xóa các vùng sáng (nền, da trắng, áo trắng...)
                            data[i + 3] = 0;
                        }
                    }

                    ctx.putImageData(imageData, 0, 0);
                    callback(canvas.toDataURL());
                } catch (e) {
                    console.warn("Không thể xử lý xóa nền (lỗi CORS hoặc file local):", e);
                    callback(src); // Fallback về ảnh gốc nếu gặp lỗi
                }
            };
            img.onerror = () => callback(src);
            img.src = src;
        }

        function applyScrollingToTitle(titleElement, songName) {
            const scrollContainer = titleElement.querySelector('.music-player-title-scroll-container');
            const titleText = titleElement.querySelector('.music-player-title-text');
            if (!scrollContainer || !titleText) return;

            // Clear any previous duplicate and animation
            let duplicateText = titleElement.querySelector('.music-player-title-text-duplicate');
            if (duplicateText) {
                duplicateText.remove();
            }
            titleElement.classList.remove('scrolling');
            titleElement.style.removeProperty('--scroll-start');
            titleElement.style.removeProperty('--scroll-end');
            titleElement.style.removeProperty('--scroll-duration');
            titleText.textContent = songName; // Ensure original text is set

            const containerWidth = titleElement.offsetWidth;
            const textWidth = titleText.offsetWidth;

            // Start from the right edge of the container
            const startPos = containerWidth;
            // End when the text has completely moved out to the left
            const endPos = -textWidth;

            const scrollDistance = startPos - endPos;
            const scrollSpeedPxPerSec = 60; // Tăng tốc độ một chút cho mượt
            const scrollDuration = (scrollDistance / scrollSpeedPxPerSec) * 1000; // in milliseconds

            titleElement.classList.add('scrolling');
            titleElement.style.setProperty('--scroll-start', `${startPos}px`);
            titleElement.style.setProperty('--scroll-end', `${endPos}px`);
            titleElement.style.setProperty('--scroll-duration', `${scrollDuration}ms`);
        }
        function restoreDefaultControls() {
            controls.enablePan = true;
            controls.minDistance = 10;
            controls.maxDistance = parseInt(zoomSlider.value); // Use current slider value
            // Also ensure controls are enabled if not animating
            if (!isCameraAnimating) {
                controls.enabled = true;
            }
        }

        function animateCameraToPlanet(targetPlanet) { // Removed lockView parameter
            // Disable controls during animation
            controls.enabled = false;

            // The locking state should be managed by handlePlanetClick BEFORE calling this.

            // Store current camera and controls target as the starting point for the first phase
            startCameraPosition.copy(camera.position);
            startControlsTarget.copy(controls.target);

            // Calculate target position for controls (planet's world position)
            const planetWorldPosition = new THREE.Vector3();
            targetPlanet.getWorldPosition(planetWorldPosition);
            finalControlsTarget.copy(planetWorldPosition);

            // Calculate target position for camera (offset from planet)
            const offsetDistance = targetPlanet.userData.size * 8 + 10;
            finalCameraPosition.copy(planetWorldPosition).add(new THREE.Vector3(0, offsetDistance / 2, offsetDistance));

            isCameraAnimating = true;
            cameraAnimationPhase = 1; // Start with the "return to home view" phase
            cameraAnimationStartTime = Date.now();
        }
        
        // Hàm mới để hoạt ảnh camera đến chế độ xem toàn cảnh
        const overviewBtn = document.getElementById('overview-btn');
        overviewBtn.addEventListener('click', animateCameraToOverview);

        function animateCameraToOverview() {
            // Nếu một hành tinh hiện đang bị khóa, hãy mở khóa nó và ẩn hình ảnh của nó
            if (lockedPlanet) {
                if (lockedPlanet.userData.imageGroup.visible) {
                    removeImagesFromPlanet(lockedPlanet);
                }
                lockedPlanet.userData.interactionState = 0; // Đặt lại trạng thái của hành tinh đã khóa trước đó
            }
            selectedPlanetObject = null; // Xóa lựa chọn hành tinh khi chuyển sang chế độ toàn cảnh
            isViewLocked = false;
            lockedPlanet = null;

            // Tắt hiệu ứng trôi nổi và chuẩn bị di chuyển sóng nhạc vào vị trí trung tâm
            musicPlayerFloatInfo.enabled = false;

            // Thay đổi kích thước và vị trí của trình phát nhạc 3D theo yêu cầu
            if (musicPlayerObject && musicPlayerObject.element) {
                musicPlayerObject.element.style.transition = 'transform 0.5s ease-out';
                musicPlayerObject.element.style.transform = 'scale(0.7) translateY(-200px)';
            }

            // Di chuyển trình phát nhạc xuống
            document.getElementById('music-controls-2d').style.transform = 'translateY(20px)';
            
            // Bắt đầu phát TV GIF
            startTvPlayer();

            // Đặt lại FOV (zoom) về mặc định và tính toán lại vị trí toàn cảnh
            camera.fov = 75; // Đặt lại về FOV mặc định
            camera.updateProjectionMatrix();
            zoomLevelSlider.value = 75; // Cập nhật giao diện thanh trượt
            updateZoomSliderVisual(75); // Cập nhật hình ảnh thanh trượt
            saveSettings(); // Lưu lại cài đặt FOV đã đặt lại

            const newOverviewPosition = calculateOverviewCameraPosition(); // Tính toán lại vị trí với FOV mặc định

            // Lưu vị trí camera và mục tiêu điều khiển hiện tại làm điểm bắt đầu
            startCameraPosition.copy(camera.position);
            startControlsTarget.copy(controls.target);

            // Đặt vị trí cuối cùng cho chế độ xem toàn cảnh
            finalCameraPosition.copy(newOverviewPosition); // Sử dụng vị trí đã được tính toán lại
            finalControlsTarget.copy(overviewControlsTarget);

            isCameraAnimating = true;
            cameraAnimationPhase = 3; // Giai đoạn mới cho chế độ xem toàn cảnh
            cameraAnimationStartTime = Date.now();

            controls.enabled = false; // Tắt điều khiển trong quá trình hoạt ảnh
        }
        // New functions for managing planet images
        function addImagesToPlanet(planet) {
            if (planet.userData.isSun) { // Sun doesn't have images
                return;
            }

            if (planet.userData.imageGroup.children.length > 0) {
                // Images already exist, just make sure they are visible
                planet.userData.imageGroup.visible = true;
                return;
            }

            const availableUrls = allImageUrls.filter(url => !usedImageUrls.has(url));
            const imagesPerPlanet = 7;
            
            if (availableUrls.length < imagesPerPlanet) {
                console.warn("Not enough unique images available to display.");
                return;
            }

            const shuffled = availableUrls.sort(() => 0.5 - Math.random());
            let selectedUrls = shuffled.slice(0, imagesPerPlanet);

            selectedUrls.forEach(url => {
                usedImageUrls.add(url);

                const material = new THREE.MeshBasicMaterial({
                    map: textureCache[url],
                    side: THREE.DoubleSide,
                    transparent: true
                });
                const plane = new THREE.Mesh(new THREE.PlaneGeometry(4, 4), material);
                
                const baseRadius = planet.userData.size + 10;
                const radius = baseRadius + (Math.random() * 5);
                const phi = Math.acos(-1 + (2 * Math.random()));
                const theta = Math.random() * 2 * Math.PI;
                plane.position.setFromSphericalCoords(radius, phi, theta);
                
                plane.rotation.x = Math.random() * Math.PI * 2;
                plane.rotation.y = Math.random() * Math.PI * 2;
                plane.rotation.z = Math.random() * Math.PI * 2;
                
                plane.userData = { 
                    isImagePlane: true, imageUrl: url,
                    selfRotationSpeedX: (Math.random() - 0.5) * 0.005, selfRotationSpeedY: (Math.random() - 0.5) * 0.005, selfRotationSpeedZ: (Math.random() - 0.5) * 0.005,
                    orbitAxis: new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize(), orbitSpeed: (Math.random() + 0.2) * 0.004
                };
                planet.userData.imageGroup.add(plane);
            });
            planet.userData.imageGroup.visible = true; // Ensure the group is visible
        }

        function removeImagesFromPlanet(planet) {
            planet.userData.imageGroup.children.forEach(image => {
                if (image.userData.imageUrl) usedImageUrls.delete(image.userData.imageUrl);
                image.geometry.dispose(); if (image.material.map) image.material.map.dispose(); image.material.dispose();
            });
            planet.userData.imageGroup.clear();
            planet.userData.imageGroup.visible = false;
        }

        // New handler for planet clicks to manage state
        function handlePlanetClick(planet) {
            // Kích hoạt lại hiệu ứng trôi nổi khi chọn một hành tinh.
            // Điều này đảm bảo sóng nhạc sẽ bắt đầu di chuyển trở lại nếu trước đó đang ở chế độ "Toàn cảnh".
            musicPlayerFloatInfo.enabled = true;
            stopTvPlayer(); // Tắt TV khi chọn hành tinh (thoát chế độ toàn cảnh)
            selectedPlanetObject = planet; // Cập nhật hành tinh đang được chọn
            document.getElementById('music-controls-2d').style.transform = '';
            // Đặt lại kích thước và vị trí của trình phát nhạc 3D
            if (musicPlayerObject && musicPlayerObject.element) {
                musicPlayerObject.element.style.transform = 'scale(1) translateY(0)';
            }


            if (planet.userData.interactionState === undefined) {
                planet.userData.interactionState = 0;
            }

            // Vô hiệu hóa controls ngay lập tức để ngăn chặn xung đột với hoạt ảnh camera
            // và đảm bảo trạng thái được quản lý bởi logic của hàm này.
            controls.enabled = false;

            // If a different planet is currently locked, unlock it and hide its images
            if (lockedPlanet && lockedPlanet !== planet) {
                if (lockedPlanet.userData.imageGroup.visible) {
                    removeImagesFromPlanet(lockedPlanet);
                }
                lockedPlanet.userData.interactionState = 0; // Reset state of previously locked planet
                // No need to call restoreDefaultControls here, as the new planet's animation will override
            }

            // Logic chuyển trạng thái tùy chỉnh theo yêu cầu của người dùng
            let nextState;
            switch (planet.userData.interactionState) {
                case 0: // Trạng thái ban đầu: Ảnh ẩn, bỏ khóa
                    nextState = 1; // Lần 1: Hiện ảnh, khóa, zoom
                    break;
                case 1: // Sau lần 1: Hiện ảnh, khóa, zoom
                    nextState = 2; // Lần 2: Hiện ảnh, bỏ khóa
                    break;
                case 2: // Sau lần 2 hoặc lần 5: Hiện ảnh, bỏ khóa
                    nextState = 3; // Lần 3: Tắt ảnh, bỏ khóa
                    break;
                case 3: // Sau lần 3 hoặc lần 6: Tắt ảnh, bỏ khóa
                    nextState = 4; // Lần 4: Hiện ảnh, khóa lại
                    break;
                case 4: // Sau lần 4: Hiện ảnh, khóa lại
                    nextState = 2; // Lần 5: Hiện ảnh, bỏ khóa (quay lại trạng thái 2)
                    break;
                default: // Trường hợp mặc định, coi như trạng thái ban đầu
                    nextState = 1;
            }
            planet.userData.interactionState = nextState;

            switch (planet.userData.interactionState) {
                case 1: // State 1: Show images, Lock view, Animate camera
                    addImagesToPlanet(planet);
                    isViewLocked = true; // Set lock state here
                    lockedPlanet = planet; // Set locked planet here
                    animateCameraToPlanet(planet);
                    break;
                case 2: // State 2: Unlock view, Images remain
                    isViewLocked = false;
                    lockedPlanet = null;
                    restoreDefaultControls(); // Re-enable controls and reset distances
                    // Đảm bảo ảnh vẫn hiển thị nếu chúng đã được thêm vào từ trạng thái trước
                    if (!planet.userData.imageGroup.visible) {
                        addImagesToPlanet(planet);
                    }
                    break;
                case 3: // State 3: Hide images, Unlock view, Reset (Lần 3: tắt ảnh / Lần 6: tắt ảnh)
                    removeImagesFromPlanet(planet);
                    isViewLocked = false;
                    lockedPlanet = null;
                    restoreDefaultControls(); // Đảm bảo controls được đặt lại hoàn toàn và kích hoạt
                    break;
                case 4: // State 4: Lock view again, Images remain (Lần 4: theo dõi)
                    addImagesToPlanet(planet); // Đảm bảo ảnh hiển thị
                    isViewLocked = true;
                    lockedPlanet = planet; // Re-lock to this planet
                    // Không cần hoạt ảnh camera, chỉ cần đảm bảo controls theo dõi hành tinh
                    controls.minDistance = 10; // Giữ khoảng cách gần với hành tinh
                    controls.maxDistance = 100; // Cho phép zoom ra một chút
                    controls.enabled = true; // Kích hoạt controls để theo dõi
                    break;
            }
        }

        document.getElementById('close-btn').addEventListener('click', closeFullscreen);
        document.getElementById('close-btn').addEventListener('touchend', closeFullscreen);

        // If you intend to have an unlock view button, you would add it to your HTML and uncomment/implement its logic here.
        // Example:
        // const unlockViewBtn = document.getElementById('unlock-view-btn');
        // if (unlockViewBtn) unlockViewBtn.addEventListener('click', () => { isViewLocked = false; lockedPlanet = null; restoreDefaultControls(); unlockViewBtn.style.display = 'none'; });
        const downloadBtn = document.getElementById('download-btn');
        function closeFullscreen(event) {
            event.preventDefault(); // Prevent potential double-triggering on touch devices
            document.getElementById('fullscreen-overlay').style.display = 'none';
            if (!isViewLocked) { // Only re-enable controls if view was NOT locked
                controls.enabled = true;
            }
            document.getElementById('select-planet-btn').style.display = 'block'; // Hiển thị lại nút "Chọn hành tinh"
            downloadBtn.style.display = 'none'; // Ẩn nút tải xuống khi đóng overlay
        }

        // --- Core Functions ---
        function showMessageOnSun() {
            if (sunMessageMesh) return;

            // Get current time and create the dynamic message
            const now = new Date();
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');
            const currentTime = `${hours}:${minutes}`;
            let messageSuffix = '';

            // Logic để xác định câu chúc dựa trên giờ hiện tại
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes(); // Lấy phút để xử lý khung giờ 06:30

            if (currentHour >= 22 || currentHour < 5) { // Từ 22:00 đến 04:59 hôm sau
                messageSuffix = "ngủ đi bé ưi";
            } else if (currentHour === 5 || (currentHour === 6 && currentMinute < 30)) { // Từ 05:00 đến 06:29
                messageSuffix = "ăn sáng, xong đi học vui vẻ nhó";
            } else if (currentHour >= 11 && currentHour < 12) { // Từ 11:00 đến 11:59
                messageSuffix = "ăn cơm rùi nghỉ ngơi bé";
            } else if (currentHour >= 12 && currentHour < 13) { // Từ 12:00 đến 12:59
                messageSuffix = "bé ưi ngủ trưa đi";
            } else if (currentHour >= 13 && currentHour < 22) { // Từ 13:00 đến 21:59
                messageSuffix = "em có thấy đẹp ko";
            } else {
                // Mặc định cho các khung giờ còn lại (ví dụ: 06:30 - 10:59)
                messageSuffix = "chúc bạn một ngày tốt lành!";
            }

            const text = `Giờ là ${currentTime}, ${messageSuffix}`;

            // Create canvas texture for the text
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const fontSize = 90;
            
            context.font = `bold ${fontSize}px Arial, sans-serif`;
            const textMetrics = context.measureText(text);
            canvas.width = textMetrics.width + 40;
            canvas.height = fontSize * 1.5;

            // Redraw text with final settings
            context.font = `bold ${fontSize}px Arial, sans-serif`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillStyle = 'rgba(255, 255, 220, 1)';
            context.shadowColor = 'rgba(255, 255, 0, 0.7)';
            context.shadowBlur = 25;
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                opacity: 0
            });

            const planeHeight = 150;
            const planeWidth = planeHeight * (canvas.width / canvas.height);
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);

            sunMessageMesh = new THREE.Mesh(geometry, material);

            // Position the message directly in front of the camera, but much further away
            const distance = 1500; 
            const positionVector = new THREE.Vector3();
            camera.getWorldDirection(positionVector);
            positionVector.multiplyScalar(distance);
            positionVector.add(camera.position);
            sunMessageMesh.position.copy(positionVector);
            sunMessageMesh.position.y += planeHeight / 2 + 300; // Đẩy dòng chữ lên cao hơn nữa để tránh bị che khuất
            sunMessageMesh.quaternion.copy(camera.quaternion);

            scene.add(sunMessageMesh);

            sunMessageAnimation = {
                active: true,
                startTime: Date.now(),
                duration: 10000, // Message lasts for 10 seconds
                fadeIn: 1000,
                fadeOut: 1000
            };
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            // Hiệu ứng trôi nổi ngẫu nhiên, lộn xộn cho trình phát nhạc
            if (musicPlayerObject) {
                if (musicPlayerFloatInfo.enabled) {
                    const time = Date.now();
                    // Nếu đã đến lúc, hãy đặt một mục tiêu offset mới
                    if (time > musicPlayerFloatInfo.timeToNewTarget) {
                        setNewMusicPlayerTarget();
                    }

                    // Tạo một vị trí mục tiêu luôn ở phía trước camera
                    // 1. Xác định vị trí cơ sở trong không gian cục bộ của camera (ví dụ: 400 đơn vị phía trước)
                    const targetLocalPosition = new THREE.Vector3(0, 0, -400);
                    // 2. Thêm offset trôi nổi ngẫu nhiên
                    targetLocalPosition.add(musicPlayerFloatInfo.targetOffset);
                    // 3. Chuyển đổi vị trí cục bộ cuối cùng thành tọa độ thế giới
                    const finalWorldPosition = targetLocalPosition.applyMatrix4(camera.matrixWorld);
                    // 4. Di chuyển mượt mà (lerp) đến vị trí mục tiêu trong thế giới
                    musicPlayerObject.position.lerp(finalWorldPosition, musicPlayerFloatInfo.lerpAlpha);
                } else {
                    // Khi ở chế độ Toàn cảnh, di chuyển mượt mà đến vị trí cố định ở trung tâm
                    musicPlayerObject.position.lerp(musicPlayerFloatInfo.overviewPosition, 0.02);
                }
            }

            // Animate star brightness for twinkling effect
            if (stars && starAnimationData.length > 0) {
                const currentTime = performance.now();
                const colors = stars.geometry.attributes.color.array;

                for (let i = 0; i < starAnimationData.length; i++) {
                    const starData = starAnimationData[i];

                    // If the star is static, skip it. Its color is fixed.
                    if (starData.isStatic) {
                        continue;
                    }

                    const colorIndex = i * 3;

                    if (starData.isTwinkling) {
                        // Star is currently twinkling, let's fade it out
                        if (currentTime > starData.twinkleEndTime) {
                            // Twinkle has ended
                            colors[colorIndex] = 0;
                            colors[colorIndex + 1] = 0;
                            colors[colorIndex + 2] = 0;

                            starData.isTwinkling = false;
                            // Set a random dark period from 1 to 10 seconds
                            starData.nextTwinkleTime = currentTime + 1000 + Math.random() * 9000;
                        } else {
                            // Fade out effect
                            const timeRemaining = starData.twinkleEndTime - currentTime;
                            const brightness = timeRemaining / starData.twinkleDuration; // Fades from 1 to 0
                            
                            colors[colorIndex] = starData.color.r * brightness;
                            colors[colorIndex + 1] = starData.color.g * brightness;
                            colors[colorIndex + 2] = starData.color.b * brightness;
                        }
                    } else {
                        // Star is dark, check if it's time to twinkle again
                        if (currentTime > starData.nextTwinkleTime) {
                            starData.isTwinkling = true;
                            // Set a short, random duration for the twinkle (e.g., 200-500ms)
                            starData.twinkleDuration = 200 + Math.random() * 300;
                            starData.twinkleEndTime = currentTime + starData.twinkleDuration;

                            // Set a new random bright color with a slight tint
                            const randomTint = Math.random();
                            if (randomTint < 0.25) { // Cyan tint
                                starData.color.setRGB(0.8, 1.0, 1.0);
                            } else if (randomTint < 0.5) { // Yellow tint
                                starData.color.setRGB(1.0, 1.0, 0.8);
                            } else if (randomTint < 0.75) { // Magenta tint
                                starData.color.setRGB(1.0, 0.8, 1.0);
                            } else { // Pure white
                                starData.color.setRGB(1.0, 1.0, 1.0);
                            }

                            // Start at full brightness
                            colors[colorIndex] = starData.color.r;
                            colors[colorIndex + 1] = starData.color.g;
                            colors[colorIndex + 2] = starData.color.b;
                        }
                    }
                }
                stars.geometry.attributes.color.needsUpdate = true;
            }

            const delta = Date.now() * 0.0001; // Slower, more majestic rotation

            if (sunMessageAnimation.active && sunMessageMesh) {
                const elapsedTime = Date.now() - sunMessageAnimation.startTime;
                if (elapsedTime >= sunMessageAnimation.duration) {
                    scene.remove(sunMessageMesh);
                    sunMessageMesh.geometry.dispose();
                    sunMessageMesh.material.map.dispose();
                    sunMessageMesh.material.dispose();
                    sunMessageMesh = null;
                    sunMessageAnimation.active = false;
                } else {
                    let opacity = 0;
                    if (elapsedTime < sunMessageAnimation.fadeIn) {
                        opacity = elapsedTime / sunMessageAnimation.fadeIn;
                    } else if (elapsedTime < sunMessageAnimation.duration - sunMessageAnimation.fadeOut) {
                        opacity = 1;
                    } else {
                        opacity = (sunMessageAnimation.duration - elapsedTime) / sunMessageAnimation.fadeOut;
                    }
                    sunMessageMesh.material.opacity = Math.max(0, opacity);
                }
            }

            // Two-stage Camera animation update
            if (isCameraAnimating) {
                const elapsedTime = Date.now() - cameraAnimationStartTime;
                
                if (cameraAnimationPhase === 1) { // Phase 1: Return to Home View
                    const progress = Math.min(elapsedTime / returnToHomeDuration, 1);
                    const easedProgress = easeInOutSine(progress); // Apply easing function

                    // Lerp camera position from current to home position
                    camera.position.lerpVectors(startCameraPosition, homeCameraPosition, easedProgress);
                    // Lerp controls target from current to home target (0,0,0)
                    controls.target.lerpVectors(startControlsTarget, homeControlsTarget, easedProgress);
                    
                    if (progress === 1) {
                        // Transition to the next phase
                        cameraAnimationPhase = 2;
                        cameraAnimationStartTime = Date.now(); // Reset timer for the next phase
                        // Update start positions for the next phase
                        // Đảm bảo vị trí cuối cùng chính xác trước khi bắt đầu giai đoạn tiếp theo
                        startCameraPosition.copy(homeCameraPosition); 
                        startControlsTarget.copy(homeControlsTarget);
                    }
                } else if (cameraAnimationPhase === 2) { // Phase 2: Move to Target Planet
                    const progress = Math.min(elapsedTime / moveToTargetDuration, 1);
                    const easedProgress = easeInOutSine(progress); // Apply easing function

                    // Lerp camera position from current (after zoom out) to final
                    camera.position.lerpVectors(startCameraPosition, finalCameraPosition, easedProgress);
                    // Lerp controls target from current (original target) to final (planet's world position)
                    controls.target.lerpVectors(startControlsTarget, finalControlsTarget, easedProgress);

                    if (progress === 1) {
                        isCameraAnimating = false;
                        cameraAnimationPhase = 0; // Animation finished
                        controls.enabled = true; // Re-enable controls after animation
                        // Ensure camera and controls target are exactly at their final positions
                        camera.position.copy(finalCameraPosition);
                        controls.target.copy(finalControlsTarget);
                    }
                } else if (cameraAnimationPhase === 3) { // Giai đoạn 3: Di chuyển đến chế độ xem toàn cảnh
                    const progress = Math.min(elapsedTime / moveToTargetDuration, 1); // Tái sử dụng moveToTargetDuration cho hoạt ảnh toàn cảnh
                    const easedProgress = easeInOutSine(progress);

                    camera.position.lerpVectors(startCameraPosition, finalCameraPosition, easedProgress);
                    controls.target.lerpVectors(startControlsTarget, finalControlsTarget, easedProgress);

                    if (progress === 1) {
                        isCameraAnimating = false;
                        cameraAnimationPhase = 0; // Hoạt ảnh kết thúc
                        controls.enabled = true; // Kích hoạt lại điều khiển sau hoạt ảnh
                        // Đảm bảo camera và mục tiêu điều khiển ở đúng vị trí cuối cùng
                        camera.position.copy(finalCameraPosition);
                        controls.target.copy(finalControlsTarget);
                        restoreDefaultControls(); // Đảm bảo min/max distance được đặt lại

                        // Temporarily disable interaction to prevent accidental clicks after overview
                        labelRenderer_fg.domElement.removeEventListener('click', onInteraction, true);
                        labelRenderer_fg.domElement.removeEventListener('touchend', onInteraction, true);

                        const reenableInteraction = () => {
                            labelRenderer_fg.domElement.addEventListener('click', onInteraction, true);
                            labelRenderer_fg.domElement.addEventListener('touchend', onInteraction, true);
                        };
                        controls.addEventListener('change', reenableInteraction, { once: true });
                    }

                }
                camera.lookAt(controls.target); // Ensure camera always looks at the interpolated target
            }
            if (stars) {
                stars.rotation.y += 0.0001;
            }
            sun.rotation.y += 0.001;

            planets.forEach(planet => {
                const data = planet.userData;
                data.angle += data.speed * planetSpeedMultiplier;
                planet.position.x = Math.cos(data.angle) * data.distance;
                planet.position.z = Math.sin(data.angle) * data.distance;
                planet.rotation.y += 0.001;

                // Only update image movement if the image group is visible
                if (!planet.userData.imageGroup.visible) {
                    return; // Skip if images are hidden (correct way to exit forEach callback)
                }
                // Revert to individual, chaotic rotation for each image
                planet.userData.imageGroup.children.forEach(image => {
                    image.position.applyAxisAngle(image.userData.orbitAxis, image.userData.orbitSpeed);
                    image.rotation.x += image.userData.selfRotationSpeedX;
                    image.rotation.y += image.userData.selfRotationSpeedY;
                    image.rotation.z += image.userData.selfRotationSpeedZ;
                });
            });

            // --- Camera Lock Logic ---
            if (isViewLocked && lockedPlanet) {
                // Lấy vị trí thế giới của hành tinh đang bị khóa
                const targetWorldPosition = new THREE.Vector3();
                lockedPlanet.getWorldPosition(targetWorldPosition);

                // Cập nhật mục tiêu của controls để camera luôn hướng vào hành tinh
                controls.target.copy(targetWorldPosition);

                // Nếu không có animation camera đang diễn ra, đảm bảo camera duy trì vị trí tương đối
                // OrbitControls.update() sẽ tự xử lý việc di chuyển camera tương đối với mục tiêu mới
                // Không cần đặt camera.position một cách rõ ràng ở đây.
            }
            
            controls.update();
            drawVisualizer(); // Call the visualizer drawing function

            // 1. Render background WebGL (stars)
            renderer_bg.render(scene_bg, camera);
            // 2. Render background CSS (music player)
            labelRenderer_bg.render(scene_bg, camera);
            // 3. Render foreground WebGL (solar system) with a transparent background
            renderer.render(scene, camera);
            // 4. Render foreground CSS (planet labels)
            labelRenderer_fg.render(scene, camera);
        }

        // --- Event Listeners & Initial Calls ---
        window.addEventListener('resize', () => { 
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer_bg.setSize(window.innerWidth, window.innerHeight);
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer_bg.setSize(window.innerWidth, window.innerHeight);
            labelRenderer_fg.setSize(window.innerWidth, window.innerHeight);
            // Recalculate overview position on resize
            overviewCameraPosition = calculateOverviewCameraPosition();
            // Nếu đang ở chế độ toàn cảnh, kích hoạt lại hoạt ảnh để cập nhật vị trí
            if (cameraAnimationPhase === 3) {
                animateCameraToOverview();
            }

            // Re-evaluate music player title scrolling on resize
            if (musicPlayerObject && currentSongIndex !== -1) {
                const titleDiv = musicPlayerObject.element.querySelector('.music-player-title');
                if (titleDiv) {
                    // Give a small delay to ensure DOM elements have settled after resize
                    setTimeout(() => {
                        applyScrollingToTitle(titleDiv, songs[currentSongIndex].name);
                    }, 100);
                }
            }
        }, false);
        
        // Handle visibility change to ensure AudioContext is resumed if needed
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') {
                // Tab is now visible
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log("AudioContext resumed due to tab becoming visible.");
                    }).catch(e => console.error("Error resuming AudioContext on visibilitychange:", e));
                }
            }
        });
        labelRenderer_fg.domElement.addEventListener('click', onInteraction, true); // Use capturing phase for click on foreground
        labelRenderer_fg.domElement.addEventListener('touchend', onInteraction, true); // Use capturing phase for touchend on foreground

        // Tự động mở khóa chế độ xem nếu người dùng tương tác thủ công với controls
        controls.addEventListener('start', () => {
            // Logic mới: Kích hoạt lại hiệu ứng trôi nổi khi người dùng bắt đầu thay đổi góc nhìn.
            // Điều này chỉ xảy ra khi người dùng thoát khỏi chế độ "Toàn cảnh" bằng cách di chuyển camera.
            if (musicPlayerFloatInfo.enabled === false) {
                musicPlayerFloatInfo.enabled = true;

                stopTvPlayer(); // Tắt TV khi người dùng tự xoay camera (thoát chế độ toàn cảnh)
                // Đặt lại vị trí và kích thước của trình phát nhạc 3D về trạng thái mặc định
                if (musicPlayerObject && musicPlayerObject.element) {
                    musicPlayerObject.element.style.transform = 'scale(1) translateY(0)';
                }
                // Đặt lại vị trí của các nút điều khiển 2D
                document.getElementById('music-controls-2d').style.transform = '';
            }

            if (isViewLocked && !isCameraAnimating) {
                const previouslyLockedPlanet = lockedPlanet; // Store before nulling
                // If user manually interacts, unlock view
                lockedPlanet = null;
                isViewLocked = false;
                restoreDefaultControls(); // Khôi phục cài đặt điều khiển mặc định
                console.log('Chế độ xem đã được mở khóa do người dùng tương tác.');
                // Nếu hành tinh đang ở trạng thái khóa (Trạng thái 1 hoặc Trạng thái 4),
                // chuyển nó sang trạng thái "hiện ảnh, bỏ khóa" (Trạng thái 2).
                if (previouslyLockedPlanet && (previouslyLockedPlanet.userData.interactionState === 1 || previouslyLockedPlanet.userData.interactionState === 4)) {
                    previouslyLockedPlanet.userData.interactionState = 2;
                }
            }
        });

        updateVolumeSliderVisual(volumeSlider.value); // Đặt giao diện ban đầu dựa trên giá trị mặc định của HTML
        updateZoomSliderVisual(parseFloat(zoomLevelSlider.value)); // Đặt giao diện ban đầu cho thanh trượt zoom
        // Tải các cài đặt đã lưu sau khi tất cả các phần tử và biến đã được khởi tạo
        loadSettings();

        // Note: The animate() call is now in loadingManager.onLoad
    </script>

</body>
</html>