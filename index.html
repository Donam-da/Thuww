<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Solar System Image Gallery</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; }
        canvas { display: block; }
        #main-scene { display: none; }
        #loader-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #000; display: flex; justify-content: center;
            align-items: center; z-index: 3000; transition: opacity 0.5s ease;
        }
        .loader-container { text-align: center; }
        .progress-circle {
            width: 120px; height: 120px; border-radius: 50%;
            background: conic-gradient(#3498db 0%, #1a1a1a 0%);
            display: flex; justify-content: center; align-items: center;
            margin: 0 auto 20px auto;
        }
        .progress-circle-inner {
            width: 100px; height: 100px; background-color: #000;
            border-radius: 50%; display: flex; justify-content: center;
            align-items: center;
        }
        .loader-text {
            font-size: 24px; color: white; font-family: Arial, sans-serif;
        }
        #fullscreen-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.85); display: none; justify-content: center;
            align-items: center; z-index: 1000;
        }
        #fullscreen-image { max-width: 90%; max-height: 80%; }
        #close-btn {
            position: absolute; top: 20px; right: 30px; color: white;
            font-size: 30px; cursor: pointer; text-decoration: none; font-family: Arial, sans-serif;
        }
        .planet-label {
            color: #FFF;
            font-family: sans-serif;
            padding: 2px 5px;
            background: transparent;
            font-size: 14px;
            white-space: nowrap;
            cursor: pointer;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.9);
        }
        #select-planet-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1001;
            padding: 10px 15px;
            background-color: transparent; /* Nền trong suốt */
            color: white;
            border: 1px solid #3498db; /* Thêm viền để nút vẫn dễ nhận biết */
            border-radius: 5px;
            cursor: pointer;
            font-family: Arial, sans-serif;
            font-size: 16px;
        }
        #planet-list-overlay {
            position: fixed;
            top: 60px; /* Định vị dưới nút "Chọn hành tinh" (top 20px + padding 10px + border 1px + khoảng cách) */
            left: 20px; /* Căn chỉnh với lề trái của nút */
            width: fit-content; /* Chiều rộng vừa với nội dung */
            min-width: 180px; /* Đảm bảo chiều rộng tối thiểu, có thể điều chỉnh */
            /* max-height và overflow-y bị loại bỏ để hiển thị tất cả và bỏ thanh cuộn */
            background-color: transparent; /* Nền của dropmenu trong suốt */
            padding: 15px; /* Giảm khoảng đệm bên trong dropmenu */
            border-radius: 8px;
            box-shadow: 0 0 15px rgba(0,255,255,0.5); /* Hiệu ứng đổ bóng cho dropmenu */
            z-index: 1002;
            display: none; /* Hidden by default */
            font-family: Arial, sans-serif;
        }
        #close-dropmenu-btn {
            position: absolute;
            top: 5px; /* Khoảng cách từ trên xuống */
            right: 10px; /* Khoảng cách từ phải sang */
            color: white;
            font-size: 20px; /* Kích thước chữ X */
            cursor: pointer;
            z-index: 1003; /* Đảm bảo nó nằm trên các phần tử khác trong overlay */
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js"></script>
</head>
<body>
    <div id="loader-overlay">
        <div class="loader-container">
            <div class="progress-circle">
                <div class="progress-circle-inner">
                    <span id="progress-text" class="loader-text">0%</span>
                </div>
            </div>
            <span class="loader-text">Đang tải tài nguyên ...</span>
        </div>
    </div>
    <div id="fullscreen-overlay">
        <span id="close-btn">&times;</span>
        <img id="fullscreen-image" src="" alt="fullscreen-image" />
    </div>

    <div id="main-scene">
        <button id="select-planet-btn">Chọn hành tinh</button>
        <div id="planet-list-overlay">
            <span id="close-dropmenu-btn">&times;</span>
            <ul id="planet-selection-list" style="list-style: none; padding: 0; margin: 0;">
                <!-- Planet items will be inserted here -->
            </ul>
        </div>
        <!-- Canvas and renderers will be appended here by Three.js -->
    </div>

    <script>
        // --- Image & Planet Data ---
        const totalImages = 62;
        const allImageUrls = Array.from({length: totalImages}, (_, i) => `images/${i + 1}.png`);
        const usedImageUrls = new Set();
        const planets = [];
        const planetData = [
            { name: 'Sao Thủy', distance: 20, size: 1, color: 0xaaaaaa, speed: 0.0005 },
            { name: 'Sao Kim', distance: 35, size: 1.5, color: 0xe8ab6f, speed: 0.0003 },
            { name: 'Trái Đất', distance: 50, size: 1.6, color: 0x6f94e8, speed: 0.0002 },
            { name: 'Sao Hỏa', distance: 70, size: 1.2, color: 0xe86f6f, speed: 0.00015 },
            { name: 'Sao Mộc', distance: 100, size: 4, color: 0xd8caa0, speed: 0.00008 },
            { name: 'Sao Thổ', distance: 140, size: 3.5, color: 0xead5a8, speed: 0.00006 },
            { name: 'Sao Thiên Vương', distance: 180, size: 2.5, color: 0xa8e0ea, speed: 0.00004 },
            { name: 'Sao Hải Vương', distance: 220, size: 2.4, color: 0x5c84f5, speed: 0.00002 }
        ];

        // --- Loading Manager ---
        const loadingManager = new THREE.LoadingManager();
        const textureLoader = new THREE.TextureLoader(loadingManager);
        const loaderOverlay = document.getElementById('loader-overlay');
        const progressCircle = document.querySelector('.progress-circle');
        const progressText = document.getElementById('progress-text');

        loadingManager.onProgress = function (url, itemsLoaded, itemsTotal) {
            const progress = (itemsLoaded / itemsTotal) * 100;
            const percentage = Math.round(progress);
            progressText.textContent = `${percentage}%`;
            progressCircle.style.background = `conic-gradient(#3498db ${progress}%, #1a1a1a 0%)`;
        };

        loadingManager.onLoad = function () {
            // Fade out loader
            loaderOverlay.style.opacity = '0';
            setTimeout(() => {
                loaderOverlay.style.display = 'none';
                // Show the main scene and start the animation
                document.getElementById('main-scene').style.display = 'block';
                animate();
            }, 500);
        };
        
        // --- Preload all images and cache them---
        const textureCache = {};
        allImageUrls.forEach(url => {
            textureCache[url] = textureLoader.load(url);
        });

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('main-scene').appendChild(renderer.domElement);
        
        // --- Starfield ---
        let stars;
        function addStarfield() {
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 1.2,
                transparent: true,
                blending: THREE.AdditiveBlending
            });

            const starVertices = [];
            for (let i = 0; i < 15000; i++) {
                const x = (Math.random() - 0.5) * 2500;
                const y = (Math.random() - 0.5) * 2500;
                const z = (Math.random() - 0.5) * 2500;
                starVertices.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }
        addStarfield();

        // --- Label Renderer Setup ---
        let labelRenderer = new THREE.CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        document.getElementById('main-scene').appendChild(labelRenderer.domElement);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        // --- Controls ---
        const controls = new THREE.OrbitControls(camera, labelRenderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 10;
        controls.maxDistance = 1500;

        // --- Sun ---
        const sunGeometry = new THREE.SphereGeometry(10, 32, 32);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffdd00 });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        sun.userData = { isSun: true, name: 'Mặt trời', size: 10 }; // Thêm tên và kích thước cho Mặt trời
        scene.add(sun);
        const sunLight = new THREE.PointLight(0xffffff, 1.5, 2000);
        sun.add(sunLight);

        // --- Create Planets and Orbits ---
        planetData.forEach(data => {
            const planetGeometry = new THREE.SphereGeometry(data.size, 32, 32);
            const planetMaterial = new THREE.MeshStandardMaterial({ color: data.color });
            const planet = new THREE.Mesh(planetGeometry, planetMaterial);
            
            const imageGroup = new THREE.Group();
            planet.add(imageGroup);

            // Create Label
            const planetDiv = document.createElement('div');
            planetDiv.className = 'planet-label';
            planetDiv.textContent = data.name;
            planetDiv.addEventListener('click', (event) => {
                event.stopPropagation();
                showImagesForPlanet(planet);
            });
            // Thêm lắng nghe sự kiện touchend cho nhãn để đảm bảo tương tác chạm trên di động
            planetDiv.addEventListener('touchend', (event) => {
                event.preventDefault(); // Ngăn chặn hành vi mặc định của trình duyệt (ví dụ: ghost click)
                event.stopPropagation(); // Ngăn chặn sự kiện lan truyền thêm (ví dụ: đến OrbitControls hoặc onInteraction)
                showImagesForPlanet(planet);
            });
            const planetLabel = new THREE.CSS2DObject(planetDiv);
            planetLabel.position.set(0, data.size + 2, 0);
            planet.add(planetLabel);

            // Tạo một hitbox hình cầu vô hình lớn hơn một chút so với hành tinh
            const hitboxGeometry = new THREE.SphereGeometry(data.size + 0.5, 32, 32); // Lớn hơn hành tinh 0.5 đơn vị
            const hitboxMaterial = new THREE.MeshBasicMaterial({
                transparent: true,
                opacity: 0, // Hoàn toàn vô hình
                depthWrite: false // Không ghi vào depth buffer để không ảnh hưởng đến các đối tượng khác
            });
            const hitboxSphere = new THREE.Mesh(hitboxGeometry, hitboxMaterial);
            hitboxSphere.userData = { isHitbox: true, parentPlanet: planet }; // Đánh dấu đây là hitbox và liên kết với hành tinh cha
            planet.add(hitboxSphere); // Thêm hitbox vào hành tinh để nó di chuyển cùng

            planet.userData = { 
                ...data, 
                isPlanet: true, 
                angle: Math.random() * Math.PI * 2,
                imageGroup: imageGroup
            };
            
            const orbitGeometry = new THREE.RingGeometry(data.distance - 0.1, data.distance + 0.1, 128);
            const orbitMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, opacity: 0.6, transparent: true });
            const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
            orbit.rotation.x = -Math.PI / 2;
            scene.add(orbit);
            
            if (data.name === 'Sao Thổ') {
                const ringGeometry = new THREE.RingGeometry(data.size * 1.5, data.size * 2.5, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({ color: 0xead5a8, side: THREE.DoubleSide, opacity: 0.7, transparent: true });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI * 0.4;
                planet.add(ring);
            }

            scene.add(planet);
            planets.push(planet);
        });

        // --- Camera Position ---
        camera.position.set(0, 100, 250);
        camera.lookAt(scene.position);

        // --- Raycasting for Clicks ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let sunMessage = null; // To track the sun message label
        let sunMessageMesh = null;
        let sunMessageAnimation = { active: false };
        let lastTouchTimestamp = 0;

        // New variables for camera animation
        let isCameraAnimating = false;
        let cameraAnimationStartTime = 0;
        const cameraAnimationDuration = 1500; // milliseconds
        let startCameraPosition = new THREE.Vector3();
        let startControlsTarget = new THREE.Vector3();
        let endCameraPosition = new THREE.Vector3();
        let endControlsTarget = new THREE.Vector3();
        const TOUCH_DELAY = 300; // Milliseconds to prevent ghost clicks

        function onInteraction(event) {
            console.log('onInteraction called, event type:', event.type); // Debugging line

            // Prevent ghost clicks on mobile: if a click event happens very soon after a touchend, ignore it.
            if (event.type === 'touchend') {
                lastTouchTimestamp = Date.now();
            } else if (event.type === 'click') {
                if (Date.now() - lastTouchTimestamp < TOUCH_DELAY) {
                    return; // This click is likely a ghost click, already handled by touchend
                }
            }

            if (event.target.closest('.planet-label')) {
                console.log('Tapped on planet label, ignoring raycast.'); // Debugging line
                return;
            }

            // Determine the correct clientX and clientY for both mouse and touch events
            const rect = renderer.domElement.getBoundingClientRect();
            let clientX, clientY;
            if (event.changedTouches && event.changedTouches.length > 0) { // For touchend, use changedTouches
                clientX = event.changedTouches[0].clientX;
                clientY = event.changedTouches[0].clientY;
            } else if (event.touches && event.touches.length > 0) { // For other touch events (e.g., touchstart, touchmove)
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else { // For mouse events
                clientX = event.clientX;
                clientY = event.clientY;
            }

            if (typeof clientX === 'undefined' || typeof clientY === 'undefined') {
                // No valid coordinates found, exit
                console.log('No valid coordinates found, exiting onInteraction.'); // Debugging line
                return;
            }

            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                // Nếu một đối tượng được nhấn, ngăn chặn OrbitControls xử lý chạm này như một thao tác camera
                if (event.type === 'touchend') {
                    event.preventDefault();
                    event.stopPropagation();
                }
                console.log('Raycaster hit something!', intersects[0].object); // Debugging line
                let clickedObject = intersects[0].object;

                if (clickedObject.userData.isHitbox) {
                    showImagesForPlanet(clickedObject.userData.parentPlanet);
                    return; // Process hitbox click, then exit
                }

                if (clickedObject.userData.isSun) {
                    showMessageOnSun();
                } else if (clickedObject.userData.isImagePlane) {
                    document.getElementById('fullscreen-image').src = clickedObject.userData.imageUrl;
                    document.getElementById('fullscreen-overlay').style.display = 'flex';
                    controls.enabled = false;
                } else {
                    let parentPlanet = clickedObject;
                    while (parentPlanet.parent && !parentPlanet.userData.isPlanet) {
                        parentPlanet = parentPlanet.parent;
                    }
                    if (parentPlanet.userData.isPlanet) {
                        showImagesForPlanet(parentPlanet);
                    }
                }
            } else {
                console.log('Raycaster hit nothing.'); // Debugging line
            }
        }

        // --- Planet Selection UI Logic ---
        const selectPlanetBtn = document.getElementById('select-planet-btn');
        const planetListOverlay = document.getElementById('planet-list-overlay');
        const planetSelectionList = document.getElementById('planet-selection-list');
        const closeDropmenuBtn = document.getElementById('close-dropmenu-btn'); // Đổi tên biến

        selectPlanetBtn.addEventListener('click', showPlanetList);
        closeDropmenuBtn.addEventListener('click', hidePlanetList); // Gắn sự kiện vào nút X mới

        function showPlanetList() {
            planetListOverlay.style.display = 'flex';
            populatePlanetList();
            controls.enabled = false; // Disable controls when list is open
        }

        function hidePlanetList() {
            planetListOverlay.style.display = 'none';
            controls.enabled = true; // Re-enable controls when list is closed
        }

        function populatePlanetList() {
            planetSelectionList.innerHTML = ''; // Clear previous list

            // Thêm Mặt trời vào danh sách
            const sunListItem = document.createElement('li');
            sunListItem.style.cssText = `
                color: white;
                padding: 10px;
                margin-bottom: 5px;
                background-color: rgba(0,0,0,0.5); /* Semi-transparent background */
                border-radius: 4px;
                cursor: pointer;
                transition: background-color 0.2s ease;
            `;
            sunListItem.textContent = sun.userData.name;
            sunListItem.addEventListener('mouseenter', () => sunListItem.style.backgroundColor = 'rgba(0,0,0,0.7)'); // Darker on hover
            sunListItem.addEventListener('mouseleave', () => sunListItem.style.backgroundColor = 'rgba(0,0,0,0.5)'); // Restore original
            sunListItem.addEventListener('click', () => {
                animateCameraToPlanet(sun); // Truyền đối tượng sun
                hidePlanetList();
            });
            planetSelectionList.appendChild(sunListItem);

            // Thêm các hành tinh vào danh sách
            planets.forEach(planet => {
                const listItem = document.createElement('li');
                listItem.style.cssText = `
                    color: white;
                    padding: 10px;
                    margin-bottom: 5px;
                    background-color: rgba(0,0,0,0.5); /* Semi-transparent background */
                    border-radius: 4px;
                    cursor: pointer;
                    transition: background-color 0.2s ease;
                `;
                listItem.textContent = planet.userData.name;
                listItem.addEventListener('mouseenter', () => listItem.style.backgroundColor = 'rgba(0,0,0,0.7)'); // Darker on hover
                listItem.addEventListener('mouseleave', () => listItem.style.backgroundColor = 'rgba(0,0,0,0.5)'); // Restore original
                listItem.addEventListener('click', () => {
                    animateCameraToPlanet(planet);
                    hidePlanetList();
                });
                planetSelectionList.appendChild(listItem);
            });
        }

        function animateCameraToPlanet(targetPlanet) {
            // Disable controls during animation
            controls.enabled = false;

            // Store current camera and controls target for animation start
            startCameraPosition.copy(camera.position);
            startControlsTarget.copy(controls.target);

            // Calculate target position for controls (planet's world position)
            const planetWorldPosition = new THREE.Vector3();
            targetPlanet.getWorldPosition(planetWorldPosition);
            endControlsTarget.copy(planetWorldPosition);

            // Calculate target position for camera (offset from planet)
            const offsetDistance = targetPlanet.userData.size * 10 + 20; // Example: 10x planet size + 20 units
            endCameraPosition.copy(planetWorldPosition).add(new THREE.Vector3(0, offsetDistance / 2, offsetDistance));

            isCameraAnimating = true;
            cameraAnimationStartTime = Date.now();
        }
        
        document.getElementById('close-btn').addEventListener('click', closeFullscreen);
        document.getElementById('close-btn').addEventListener('touchend', closeFullscreen);

        function closeFullscreen(event) {
            event.preventDefault(); // Prevent potential double-triggering on touch devices
            document.getElementById('fullscreen-overlay').style.display = 'none';
            controls.enabled = true;
        }

        // --- Core Functions ---
        function showMessageOnSun() {
            if (sunMessageMesh) return;

            // Get current time and create the dynamic message
            const now = new Date();
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');
            const currentTime = `${hours}:${minutes}`;
            const text = `Bây giờ là ${currentTime}, sắp đến giờ đi ngủ rồi đó!`;

            // Create canvas texture for the text
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const fontSize = 90;
            
            context.font = `bold ${fontSize}px Arial, sans-serif`;
            const textMetrics = context.measureText(text);
            canvas.width = textMetrics.width + 40;
            canvas.height = fontSize * 1.5;

            // Redraw text with final settings
            context.font = `bold ${fontSize}px Arial, sans-serif`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillStyle = 'rgba(255, 255, 220, 1)';
            context.shadowColor = 'rgba(255, 255, 0, 0.7)';
            context.shadowBlur = 25;
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                opacity: 0
            });

            const planeHeight = 150;
            const planeWidth = planeHeight * (canvas.width / canvas.height);
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);

            sunMessageMesh = new THREE.Mesh(geometry, material);

            // Position the message directly in front of the camera, but much further away
            const distance = 1500; 
            const positionVector = new THREE.Vector3();
            camera.getWorldDirection(positionVector);
            positionVector.multiplyScalar(distance);
            positionVector.add(camera.position);
            sunMessageMesh.position.copy(positionVector);
            sunMessageMesh.quaternion.copy(camera.quaternion);

            scene.add(sunMessageMesh);

            sunMessageAnimation = {
                active: true,
                startTime: Date.now(),
                duration: 10000, // Message lasts for 10 seconds
                fadeIn: 1000,
                fadeOut: 1000
            };
        }

        function showImagesForPlanet(planet) {
            if (planet.userData.imageGroup.children.length > 0) return;

            const availableUrls = allImageUrls.filter(url => !usedImageUrls.has(url));
            const imagesPerPlanet = 7;
            
            if (availableUrls.length < imagesPerPlanet) {
                console.warn("Not enough unique images available to display.");
                return;
            }

            const shuffled = availableUrls.sort(() => 0.5 - Math.random());
            let selectedUrls = shuffled.slice(0, imagesPerPlanet);

            selectedUrls.forEach(url => {
                usedImageUrls.add(url);

                const material = new THREE.MeshBasicMaterial({
                    map: textureCache[url],
                    side: THREE.DoubleSide,
                    transparent: true
                });
                const plane = new THREE.Mesh(new THREE.PlaneGeometry(4, 4), material);
                
                const radius = planet.userData.size + 9; // Fixed radius for all images
                const phi = Math.acos(-1 + (2 * Math.random()));
                const theta = Math.random() * 2 * Math.PI;

                plane.position.setFromSphericalCoords(radius, phi, theta);
                plane.lookAt(new THREE.Vector3(0, 0, 0)); // Look at the planet's local center
                
                plane.userData = { 
                    isImagePlane: true,
                    imageUrl: url,
                    selfRotationSpeed: (Math.random() - 0.5) * 0.04,
                    // Restore individual orbit properties for chaotic movement
                    orbitAxis: new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize(),
                    orbitSpeed: (Math.random() + 0.2) * 0.004
                };
                planet.userData.imageGroup.add(plane);
            });
        }



        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            if (sunMessageAnimation.active && sunMessageMesh) {
                const elapsedTime = Date.now() - sunMessageAnimation.startTime;
                if (elapsedTime >= sunMessageAnimation.duration) {
                    scene.remove(sunMessageMesh);
                    sunMessageMesh.geometry.dispose();
                    sunMessageMesh.material.map.dispose();
                    sunMessageMesh.material.dispose();
                    sunMessageMesh = null;
                    sunMessageAnimation.active = false;
                } else {
                    let opacity = 0;
                    if (elapsedTime < sunMessageAnimation.fadeIn) {
                        opacity = elapsedTime / sunMessageAnimation.fadeIn;
                    } else if (elapsedTime < sunMessageAnimation.duration - sunMessageAnimation.fadeOut) {
                        opacity = 1;
                    } else {
                        opacity = (sunMessageAnimation.duration - elapsedTime) / sunMessageAnimation.fadeOut;
                    }
                    sunMessageMesh.material.opacity = Math.max(0, opacity);
                }
            }

            // Camera animation update
            if (isCameraAnimating) {
                const elapsedTime = Date.now() - cameraAnimationStartTime;
                const progress = Math.min(elapsedTime / cameraAnimationDuration, 1);

                // Simple linear interpolation
                camera.position.lerpVectors(startCameraPosition, endCameraPosition, progress);
                controls.target.lerpVectors(startControlsTarget, endControlsTarget, progress);

                if (progress === 1) {
                    isCameraAnimating = false;
                    controls.enabled = true; // Re-enable controls after animation
                }
            }
            if (stars) {
                stars.rotation.y += 0.0001;
            }

            sun.rotation.y += 0.001;

            planets.forEach(planet => {
                const data = planet.userData;
                data.angle += data.speed;
                planet.position.x = Math.cos(data.angle) * data.distance;
                planet.position.z = Math.sin(data.angle) * data.distance;
                planet.rotation.y += 0.001;

                // Revert to individual, chaotic rotation for each image
                planet.userData.imageGroup.children.forEach(image => {
                    image.position.applyAxisAngle(image.userData.orbitAxis, image.userData.orbitSpeed);
                    image.lookAt(new THREE.Vector3(0,0,0));
                    image.rotation.z += image.userData.selfRotationSpeed;
                });
            });

            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        // --- Event Listeners & Initial Calls ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }, false);
        
        labelRenderer.domElement.addEventListener('click', onInteraction, true); // Use capturing phase for click
        labelRenderer.domElement.addEventListener('touchend', onInteraction, true); // Use capturing phase for touchend
        
        // Note: The animate() call is now in loadingManager.onLoad
    </script>
</body>
</html>